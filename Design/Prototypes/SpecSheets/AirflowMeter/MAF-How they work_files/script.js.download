$(document).ready(function(){
  if($("#owl-timeline").length){
    var owl = $("#owl-timeline");
    var totalItems;
    owl.owlCarousel({
      navigation:false,
      afterInit : function(elem){
        var that = this;
        that.owlControls.prependTo(elem);
        afterInitChanges();
        totalItems = $('.owl-item').length;
      },
      paginationNumbers: true,
      slideSpeed : 300,
      paginationSpeed : 400,
      rewindNav:false,
      singleItem:true,
      afterUpdate:afterInitChanges,
      afterMove:setPaginationPosition
    });

    $(".next").click(function(){
      owl.trigger('owl.next');
    });
    $(".previous").click(function(){
      owl.trigger('owl.prev');
    });
    $(".first").click(function(){
      owl.trigger('owl.goTo', 0);
    });
    $(".last").click(function(){
      owl.trigger('owl.goTo', totalItems);
    });


    $(".owl-pagination").css("width", ($(".owl-page").length*62)+"px");
  }

});

function afterInitChanges(){
  setTimeout(function(){
    var slides = $(".owl-item");
    var paginations = $(".owl-page");

    for (var i = 0; i < slides.length; i++) {
      var year = $(slides[i]).find(".year-layout").attr("data-year");
      $(paginations[i]).find("span").text(year);
    }

  }, 100);

}

function setPaginationPosition(){
  if($(".owl-page.active").length){
    var owlWidth = $(".owl-carousel").outerWidth()-($(".arrows").width()*4);
    var yearSize = $(".owl-page.active").outerWidth();
    var activeYearPosition = $(".owl-page.active").position().left;
    var paginationPosition = $(".owl-pagination").position().left;
    var paginationTotalWidth = $(".owl-pagination").outerWidth();
    var leftBorder = paginationPosition*-1;
    var pixelsLeftOfActive = activeYearPosition-leftBorder;
    var pixelsRightOfActive = owlWidth - (pixelsLeftOfActive+yearSize);
    var pixelsDifference = pixelsRightOfActive - pixelsLeftOfActive;

    var newPosition = paginationPosition+(pixelsDifference/2);
    var maxRightSide = (paginationTotalWidth-owlWidth)*-1;

    if(newPosition <= maxRightSide){
      newPosition = maxRightSide;
    } else if(newPosition >= 0){
      newPosition=0;
    }
    $(".owl-pagination").css("left", newPosition+"px");


  }

};$(document).ready(function(){
  if($(".about-content").length>0){

    backstretchAboutLandingImages();

    $("a.trigger").mouseover(function(){
      if (!isTabletSize && !isMobile) {
        $(this).find(".title h2").hide();
        $(this).find(".description").stop(true,true).fadeIn("fast");
        $(this).find(".bg").css("opacity", 1);
      }
    });
    $("a.trigger").mouseleave(function(){
      if (!isTabletSize && !isMobile) {
        $(this).find(".title h2").stop(true,true).fadeIn("fast");
        $(this).find(".description").hide();
        $(this).find(".bg").css("opacity", 0.7);
      }
    });



  }
});

function backstretchAboutLandingImages(){
  $(".about-content .block").each(function(index) {
    if( $(this).find("img.bg-image").length>0 ){
      $(this).backstretch($(this).find("img.bg-image").attr("src"));
    }
  });
};$(document).ready(function(){
  if($(".about-locations").length>0){

    $(".about-locations .selectric").selectric({
      disableOnMobile:false,
      optionsItemBuilder: function(itemData, element, index){
        return itemData.text+" <span class='hidden-id'>"+itemData.value+"</span>";
      },
      //by changes
      onClose: function(){
        $(".location-result").hide();

    		var id = $(".about-locations .selectric .selectricItems .selected .hidden-id").text();
        id = id.replace(" ", "");
        id = id.toLowerCase();

        $("."+id).show();

        $("."+id).ScrollTo({
          duration: 500,
          offsetTop: 50
        });
        $(".location-image").hide();
        $(".location-image."+id).show();
    	}
    });

  }
});;$(document).ready(function() {

	AboutProductsSlider.init();

});

var AboutProductsSlider = (function() {

	var self = {}, // Create object for public vars and methods
			$slider = $('.about-products-slider'),
			$controls = $('.slider-prev, .slider-next'),
			$thumbnails = $('.about-products-thumbnails img'),
			slideSpeed = 500;

	self.init = function() {
		if ($slider.length) {
			initSlider();
			initControls();
			initThumbnails();
		}
	};

	function initSlider() {
		$slider.owlCarousel({
			addClassActive: true,
			pagination: false,
			singleItem: true,
			slideSpeed: slideSpeed,
			afterMove: function() {
				var speed = slideSpeed;

				if (this.browser.isTouch) { // After dragging fade in should be faster
					speed = 100;
					$thumbnails.removeClass('active');
				}
				afterMove(speed);
			}
		});
	}

	function initControls() {
		var slider = $slider.data('owlCarousel');

		$('.slider-prev').on('click', function() {
			updateSlider('prev');
		});
		$('.slider-next').on('click', function() {
			updateSlider('next');
		});
	}

	function initThumbnails() {
		$thumbnails.each(function() {
			var $this = $(this);

			$this.on('click', function() {
				updateSlider($this.parent().index());
				$this.addClass('active');
			});
		});
	}

	function updateSlider(command) {
		var slider = $slider.data('owlCarousel');

		beforeMove();
		setTimeout(function() { // Fire command for slider
			if (command === 'prev') {
				slider.prev();
			} else if (command === 'next') {
				slider.next();
			} else {
				slider.goTo(command);
			}
		}, slideSpeed);
	}

	function beforeMove() { // Fade current content out
		$thumbnails.removeClass('active');
		$slider.find('.active .content').fadeOut(slideSpeed);
		$controls.fadeOut(slideSpeed);
	}

	function afterMove(speed) {
		setTimeout(function() { // Set active thumbail
			var active = $slider.find('.active').index();

			$thumbnails.eq(active).addClass('active');
		}, speed + 50);

		setTimeout(function() { // Fade new content in
			$slider.find('.active .content').fadeIn(speed);
			$controls.fadeIn(speed);
		}, (speed) + 100);
	}

	return self; // Return all public vars and methods

})();;var ArchiveFilters = {
    pageSize: 12,
    cookienameStoredFilters: 'storedFilters',
    cookienameStoredPage: 'storedPage',
    monthSwiper: null,
    currentMonthIndex: 0,

    init: function() {

        var $overviewWrap = $( '.filter-overview' );
        if ( $overviewWrap.length > 0 ) {

            var $filterForm = $( 'form', $overviewWrap );
            var filterDataType = $overviewWrap.data( 'filter-type' );

            if ( filterDataType === "events" ) {
                var curDate = new Date();
                var curYear = curDate.getFullYear();

                $( ".year-filter" ).find( "select[name='year']" ).val( curYear ).selectric('refresh');
                ArchiveFilters.initMonthSwiper( filterDataType );

                $(".filter-keyword input[type='text']" ).keydown( ArchiveFilters.resetFiltersWhenEnterKeyIsUsed );
            }

            if ( filterDataType === "events-small" ) {
                ArchiveFilters.initMonthSwiper( filterDataType );
            }

            $filterForm.on( 'submit', function( e ) {
                e.preventDefault();
                ArchiveFilters.submitForm( $( this ), $overviewWrap );
            } );

            $( 'select.selectric', $filterForm ).on( 'change', function() {
                $( this ).parents( 'form' ).submit();
            } );
            $( '.reset-search-btn', $filterForm ).on( 'click', function() {
                $('body, html').animate({
                    scrollTop : 0
                }, 200);
                ArchiveFilters.resetSearch( $filterForm, $overviewWrap );
            } );

            if ( Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredFilters ) ) {
                ArchiveFilters.setStoredFilterValues( $filterForm, filterDataType );
            } else {
                ArchiveFilters.storeCurrentFilterValues( $filterForm, filterDataType, $overviewWrap );
            }

            if ( Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredPage ) ) {
                ArchiveFilters.setStoredPageIndex( $filterForm, filterDataType );
            } else {
                ArchiveFilters.resetPage( $filterForm, filterDataType );
            }

            ArchiveFilters.showLoader();
            $filterForm.submit();
        }

    },

    resetFiltersWhenEnterKeyIsUsed:function(e){

        if( e.keyCode != 13) return;

        e.preventDefault();

        var $overviewWrap = $( '.filter-overview' );
        var $filterForm = $( 'form', $overviewWrap );

        $( 'select[name="country"]', $filterForm ).val( 0 );
        ArchiveFilters.setActiveSliderIndex( 0 );
        $( 'select[name="year"]', $filterForm ).val( 0 ).selectric('refresh');

        $filterForm.submit();

    },

    initMonthSwiper: function( filterDataType ) {

        if ( $( ".month-filter .swiper-container" ).length === 0 ) return;

        var date = new Date();
        var monthNumber = date.getMonth() + 1;

        if ( filterDataType === 'events-small' ) {
            var monthString = monthNumber + "-" + date.getFullYear();
            ArchiveFilters.currentMonthIndex = ArchiveFilters.getActiveSliderIndex( monthString );
        } else {
            ArchiveFilters.currentMonthIndex = monthNumber;
        }

        monthSwiper = $( ".month-filter .swiper-container" ).swiper( {
            mode: 'horizontal',
            loop: false,
            grabCursor: false,
            simulateTouch: false,
            initialSlide: ArchiveFilters.currentMonthIndex,
            roundLengths: true,
            onSlideChangeStart: function( swiper ) {
                $( '.month-filter' ).parents( 'form' ).submit();
                ArchiveFilters.setSwiperArrowEnabling( swiper.container, swiper.activeIndex, swiper.slides.length - 1 );
            },
            onSwiperCreated: function( swiper ) {
                ArchiveFilters.setSwiperArrowEnabling( swiper.container, swiper.activeIndex, swiper.slides.length - 1 );
            }
        } );


        $( ".month-swiper-button-next" ).click( function() {
            monthSwiper.swipeNext();
        } );

        $( ".month-swiper-button-prev" ).click( function() {
            monthSwiper.swipePrev();
        } );

    },

    setSwiperArrowEnabling: function( swiperContainer, activeIndex, totalIndex ) {

        if ( activeIndex === 0 ) {
            $( swiperContainer ).find( ".month-swiper-button-prev" ).addClass( "is-disabled" );
        } else {
            $( swiperContainer ).find( ".month-swiper-button-prev" ).removeClass( "is-disabled" );
        }

        if ( activeIndex === totalIndex ) {
            $( swiperContainer ).find( ".month-swiper-button-next" ).addClass( "is-disabled" );
        } else {
            $( swiperContainer ).find( ".month-swiper-button-next" ).removeClass( "is-disabled" );
        }

    },

    resetSearch: function( $filterForm, $overviewWrap ) {

        var filterDataType = $overviewWrap.data( 'filter-type' );

        ArchiveFilters.resetFilterValues( $filterForm, $overviewWrap );
        ArchiveFilters.storeCurrentFilterValues( $filterForm, filterDataType, $overviewWrap );
        ArchiveFilters.resetPage( $filterForm, filterDataType );

        $filterForm.submit();

    },

    resetFilterValues: function( $filterForm, $overviewWrap ) {

        var filterDataType = $overviewWrap.data( 'filter-type' );

        switch ( filterDataType ) {

            case 'downloads':

                $( 'select[name="language"]', $filterForm ).val( 0 );
                $( 'select[name="product"]', $filterForm ).val( 0 );
                $( 'select[name="collateral"]', $filterForm ).val( 0 );

                break;

            case 'events':

                $( 'select[name="country"]', $filterForm ).val( 0 );
                ArchiveFilters.setActiveSliderIndex( 0 );
                $( 'select[name="year"]', $filterForm ).val( 0 ).selectric('refresh');

                break;

            case 'events-small':

                $( 'select[name="country"]', $filterForm ).val( 0 );
                ArchiveFilters.setActiveSliderIndex( ArchiveFilters.currentMonthIndex );

                break;

            // by default news
            default:

                $( 'select[name="year"]', $filterForm ).val( 0 );
                $( 'select[name="month"]', $filterForm ).val( 0 );

                break;
        }

        $( 'input[name="searchTerm"]', $filterForm ).val( '' );

        // reset custom select boxes
        $( 'select.selectric', $filterForm ).selectric( 'refresh' );

    },

    setStoredFilterValues: function( $filterForm, filterDataType ) {

        var filterValues = JSON.parse( Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredFilters ) );

        switch ( filterDataType ) {

            case 'downloads':

                $( 'select[name="language"]', $filterForm ).val( filterValues.language );
                $( 'select[name="product"]', $filterForm ).val( filterValues.product );
                $( 'select[name="collateral"]', $filterForm ).val( filterValues.collateral );

                break;

            case 'events':

                $( 'select[name="country"]', $filterForm ).val( filterValues.country );
                ArchiveFilters.setActiveSliderMonthValue( filterValues.month );
                $( 'select[name="year"]', $filterForm ).val( filterValues.year ).selectric('refresh');

                break;

            case 'events-small':

                $( 'select[name="country"]', $filterForm ).val( filterValues.country );
                ArchiveFilters.setActiveSliderMonthValue( filterValues.month );

                break;

            // by default news
            default:

                $( 'select[name="year"]', $filterForm ).val( filterValues.year );
                $( 'select[name="month"]', $filterForm ).val( filterValues.month );

                break;
        }

        $( 'input[name="searchTerm"]', $filterForm ).val( filterValues.searchTerm );

    },

    getCurrentFilterValues: function( $filterForm, $overviewWrap ) {

        var filterValues = {};

        var filterDataType = $overviewWrap.data( 'filter-type' );

        switch ( filterDataType ) {

            case 'downloads':

                filterValues = {
                    'searchTerm': $( 'input[name="searchTerm"]', $filterForm ).val(),
                    'language': $( 'select[name="language"]', $filterForm ).val(),
                    'product': $( 'select[name="product"]', $filterForm ).val(),
                    'collateral': $( 'select[name="collateral"]', $filterForm ).val()
                };

                break;

            case 'events':

                filterValues = {
                    'searchTerm': $( 'input[name="searchTerm"]', $filterForm ).val(),
                    'country': $( 'select[name="country"]', $filterForm ).val(),
                    'year': $( 'select[name="year"]', $filterForm ).val(),
                    'month': ArchiveFilters.getActiveSliderMonthValue()
                };

                break;

            case 'events-small':

                filterValues = {
                    'country': $( 'select[name="country"]', $filterForm ).val(),
                    'month': ArchiveFilters.getActiveSliderMonthValue()
                };

                break;

            // by default news
            default:

                filterValues = {
                    'searchTerm': $( 'input[name="searchTerm"]', $filterForm ).val(),
                    'year': $( 'select[name="year"]', $filterForm ).val(),
                    'month': $( 'select[name="month"]', $filterForm ).val()
                };

                break;
        }

        return filterValues;

    },

    storeCurrentFilterValues: function( $filterForm, filterDataType, $overviewWrap ) {

        var filterValues = ArchiveFilters.getCurrentFilterValues( $filterForm, $overviewWrap );

        Cookie.setCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredFilters, JSON.stringify( filterValues ) );

    },

    compareCurrentFilterValues: function( $filterForm, filterDataType, $overviewWrap ) {

        var filterValues = ArchiveFilters.getCurrentFilterValues( $filterForm, $overviewWrap ),
            storedFilterValues = JSON.parse( Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredFilters ) ),
            filtersChanged = false;

        if ( storedFilterValues.searchTerm != filterValues.searchTerm ) {
            filtersChanged = true;
        }
        if ( storedFilterValues.country != filterValues.country ) {
            filtersChanged = true;
        }
        if ( storedFilterValues.year != filterValues.year ) {
            filtersChanged = true;
        }
        if ( storedFilterValues.month != filterValues.month ) {
            filtersChanged = true;
        }
        if ( storedFilterValues.language != filterValues.language ) {
            filtersChanged = true;
        }
        if ( storedFilterValues.product != filterValues.product ) {
            filtersChanged = true;
        }
        if ( storedFilterValues.collateral != filterValues.collateral ) {
            filtersChanged = true;
        }

        return filtersChanged;

    },

    setStoredPageIndex: function( $filterForm, filterDataType ) {

        var $pageIndexField = $( '#pageindex', $filterForm );
        $pageIndexField.val( Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredPage ) );

    },

    changePage: function( pageNum, $filterForm, $overviewWrap ) {

        var $pageIndexField = $( '#pageindex', $filterForm ),
            pageIndex = pageNum - 1,
            filterDataType = $overviewWrap.data( 'filter-type' );

        // store pageIndex in formfield and submit filter form
        $pageIndexField.val( pageIndex );
        Cookie.setCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredPage, pageIndex );
        $( 'form', $overviewWrap ).submit();

    },

    getActiveSmallSliderMonthValue: function() {

        return $( '.month-filter .swiper-container .swiper-slide-active' ).data( 'month-value' );

    },

    getActiveSmallSliderYearValue: function() {

        return $( '.month-filter .swiper-container .swiper-slide-active' ).data( 'year-value' );

    },

    getActiveSliderMonthValue: function() {

        return $( '.month-filter .swiper-container .swiper-slide-active' ).data( 'value' );

    },

    setActiveSliderMonthValue: function( monthValue ) {

        var slideIndex = ArchiveFilters.getActiveSliderIndex( monthValue );

        monthSwiper.swipeTo( slideIndex );

    },

    getActiveSliderIndex: function( monthValue ) {

        return $( '.month-filter .swiper-container .swiper-slide' ).index( $( '.swiper-slide[data-value="' + monthValue + '"]' ) );

    },

    setActiveSliderIndex: function( slideIndex ) {

        monthSwiper.swipeTo( slideIndex );

    },

    showLoader: function() {

        if ( $( ".archive-loader" ).length ) return;

        var $loader = $( '<div class="archive-loader"></div>' );

        $( '.filter-overview' ).find( ".media-blocks" ).prepend( $loader );
    },

    hideLoader: function() {
        $( ".archive-loader" ).remove();
    },

    resetPage: function( $filterForm, filterDataType ) {

        ArchiveFilters.showLoader();

        var $pageIndexField = $( '#pageindex', $filterForm );

        // store pageIndex in formfield
        $pageIndexField.val( 0 );
        Cookie.setCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredPage, 0 );
    },

    redrawPagination: function( totalCount, $overviewWrap ) {

        var pageAmount = Math.ceil( totalCount / ArchiveFilters.pageSize ),
            paginationLinkTemplate = '<a href="[NUM-href]" alt="Page [NUM-alt]" class="[CLASS]">[NUM-text]</a>',
            prevLinkHtml = '',
            nextLinkHtml = '',
            filterDataType = $overviewWrap.data( 'filter-type' ),
            currentPageIndex = Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredPage );

        currentPageIndex = parseInt( currentPageIndex );

        if ( currentPageIndex - 1 >= 0 ) {
            prevLinkHtml = '<a href="' + currentPageIndex + '" alt="Previous" class="page"><img class="icon" alt="Previous" src="/images/icons/icn_arrow_red_prev.svg"></a>';
        } else {
            prevLinkHtml = '<span class="page"><img class="icon" alt="Previous" src="/images/icons/icn_arrow_light_grey_prev.svg"></span>';
        }

        if ( (currentPageIndex + 1) < pageAmount ) {
            nextLinkHtml = '<a href="' + ( currentPageIndex + 2 ) + '" alt="Next" class="page"><img class="icon" alt="Next" src="/images/icons/icn_arrow_red_vertical.svg"></a>';
        } else {
            nextLinkHtml = '<span class="page"><img class="icon" alt="Next" src="/images/icons/icn_arrow_light_grey_vertical.svg"></span>';
        }

        var paginationHtml = prevLinkHtml;

        for ( var i = 0; i < pageAmount; i++ ) {
            var page = i + 1,
                classes = '';

            if ( Cookie.getCookie( filterDataType + '-' + ArchiveFilters.cookienameStoredPage ) == i ) {
                classes = 'current';
            }
            paginationHtml += paginationLinkTemplate.replace( '[NUM-href]', page ).replace( '[NUM-alt]', page ).replace( '[NUM-text]', page ).replace( '[CLASS]', classes );
        }

        paginationHtml += nextLinkHtml;

        $( '.pagination', $overviewWrap ).html( paginationHtml );
        if ( totalCount === 0 ) {
            $( '.pagination', $overviewWrap ).hide();
        } else {
            $( '.pagination', $overviewWrap ).show();
        }

        ArchiveFilters.activatePagination( $( 'form', $overviewWrap ), $overviewWrap );

    },

    activatePagination: function( $filterForm, $overviewWrap ) {

        $( '.pagination a' ).on( 'click', function( e ) {
            e.preventDefault();

            ArchiveFilters.showLoader();

            ArchiveFilters.changePage( $( this ).attr( 'href' ), $filterForm, $overviewWrap );
            ArchiveFilters.scrollToTop();
        } );
    },

    scrollToTop: function() {
        var pageTop = $( "h1.main" ).offset().top;

        if ( $( document ).scrollTop() > pageTop ) {
            $( 'html, body' ).animate( {'scrollTop': pageTop}, 800 );
        }
    },

    submitForm: function( $filterForm, $overviewWrap ) {

        var filterDataType = $overviewWrap.data( 'filter-type' ),
            filtersChanged = ArchiveFilters.compareCurrentFilterValues( $filterForm, filterDataType, $overviewWrap );

        // when one of the filters changes, we will go to page 1
        if ( filtersChanged ) {
            ArchiveFilters.resetPage( $filterForm, $overviewWrap, filterDataType );
        }

        // go and apply filters
        ArchiveFilters.applyFilters( $filterForm, $overviewWrap );

    },

    applyFilters: function( $filterForm, $overviewWrap ) {
        var filtervalues = $( $filterForm ).serialize(),
            filterDataType = $overviewWrap.data( 'filter-type' );

        ArchiveFilters.storeCurrentFilterValues( $filterForm, filterDataType, $overviewWrap );

        if ( filterDataType === 'events' ) {

            filtervalues += '&month=' + ArchiveFilters.getActiveSliderMonthValue();

        } else if ( filterDataType === 'events-small' ) {

            filtervalues += '&month=' + ArchiveFilters.getActiveSmallSliderMonthValue();
            filtervalues += '&year=' + ArchiveFilters.getActiveSmallSliderYearValue();

        }

        getImprovementRequest = $.ajax( {
            type: "GET",
            url: config.baseUrl + config.filterUrl[filterDataType],
            data: filtervalues,
            success: function( data ) {

                ArchiveFilters.updateOverview( data, filterDataType, $overviewWrap );

            },
            error: function( jqXHR, textStatus ) {
                ArchiveFilters.hideLoader();
            },

            dataType: 'json'
        } );

    },

    updateOverview: function( data, filterDataType, $overviewWrap ) {

        var outputHtml = '',
            dataItems = data.items;

        switch ( filterDataType ) {
            case 'events':

                for ( var i = 0, leni = dataItems.length; i < leni; i++ ) {
                    var eventObj = dataItems[i];
                    outputHtml += ArchiveFilters.createEvent( eventObj );
                }

                break;

            case 'events-small':

                for ( var l = 0, lenl = dataItems.length; l < lenl; l++ ) {
                    var eventSmallObj = dataItems[l];
                    outputHtml += ArchiveFilters.createEventSmall( eventSmallObj );
                }

                break;

            case 'downloads':

                for ( var j = 0, lenj = dataItems.length; j < lenj; j++ ) {
                    var downloadObj = dataItems[j];
                    outputHtml += ArchiveFilters.createDownload( downloadObj );
                }

                break;

            // display by default as news message
            default:

                for ( var k = 0, lenk = dataItems.length; k < lenk; k++ ) {
                    var newsObj = dataItems[k];
                    outputHtml += ArchiveFilters.createNews( newsObj );
                }

                break;
        }

        if ( data.totalCount === 0 ) {
            outputHtml = '<li class="no-results">'+ config.language.noresults +'</li>';
        }

        $( '.total-results .amount' ).html( data.totalCount );

        $( '.overview-list', $overviewWrap ).html( outputHtml );

        ArchiveFilters.redrawPagination( data.totalCount, $overviewWrap );
        ArchiveFilters.hideLoader();
    },

    createDownload: function( downloadObj ) {

        var template = '<li>' +
            '<div class="content">' +
            '<h2>[TITLE] - <span class="media-type">[TYPE]</span></h2>';

        if ( downloadObj.imageUrl !== "" ) {
            template += '<img src="[IMG]" alt="[ALT]"/>';
        }

        template += '<a href="[URL]" class="download-button">' + config.language.download + '</a>' +
            '</div>' +
            '</li>';

        var downloadHtml = template.replace( '[TYPE]', downloadObj.type )
            .replace( '[TITLE]', downloadObj.title )
            .replace( '[ALT]', downloadObj.title )
            .replace( '[URL]', downloadObj.url )
            .replace( '[IMG]', downloadObj.imageUrl );

        return downloadHtml;
    },

    createEventSmall: function( eventSmallObj ) {

        var template = '<li>' +
            '<a href="[URL]" title="[ALT]">' +
            '<div class="content">' +
            '<div class="day">[DAY]</div>' +
            '<p class="title">[TITLE]</p>' +
            '</div></a></li>';

        var eventSmallDate = new Date( eventSmallObj.timestamp );

        var eventSmallHtml = template.replace( '[HREF]', eventSmallObj.url )
            .replace( '[URL]', eventSmallObj.url )
            .replace( '[TITLE]', eventSmallObj.title )
            .replace( '[ALT]', eventSmallObj.title )
            .replace( '[DAY]', eventSmallDate.getDate() );

        return eventSmallHtml;

    },

    createEvent: function( eventObj ) {

        var template = '<li>' +
            '<div class="content [PASTCLASS]">';

        if ( eventObj.imageUrl !== "" ) {
            template += '<img src="[IMG]" alt="[ALT]"/>';
        }

        template += '<div class="title-block ">' +
            '<div class="date">' +
            '<span class="day">[DAY]</span> [MONTH]' +
            '</div>' +
            '<span>[YEAR][ALREADYTOOKPLACE] [COUNTRY]</span>' +
            '<h2>[TITLE]</h2>' +
            '</div>' +
            '<div class="content-block">' +
            '<p>[INTRO]</p>' +
            '<a href="[URL]" class="read-more">' + config.language.goToDetailPage + '</a>' +
            '</div>' +
            '</div>' +
            '</li>';

        var eventDate = new Date( eventObj.timestamp );

        var pastClass = "";
        var eventDateWithoutTime = eventDate.setHours( 0, 0, 0, 0 );
        var currentDateWithoutTime = new Date().setHours( 0, 0, 0, 0 );

        var alreadyTookPlace = "";
        //today is not yet in the past :)
        if ( eventDateWithoutTime < currentDateWithoutTime ) {
            pastClass = "content-past";
            alreadyTookPlace = " (" + config.language.alreadyTookPlace + ")";
        }

        var eventHtml = template.replace( '[HREF]', eventObj.url )
            .replace( '[TITLE]', eventObj.title )
            .replace( '[ALT]', eventObj.title )
            .replace( '[DAY]', eventDate.getDate() )
            .replace( '[MONTH]', config.language.monthNamesShort[eventDate.getMonth()] )
            .replace( '[YEAR]', eventDate.getFullYear() )
            .replace( '[ALREADYTOOKPLACE]', alreadyTookPlace )
            .replace( '[IMG]', eventObj.imageUrl )
            .replace( '[PASTCLASS]', pastClass )
            .replace( '[URL]', eventObj.url );

        if ( eventObj.introduction !== null ) {
            eventHtml = eventHtml.replace( '[INTRO]', eventObj.introduction );
        } else {
            eventHtml = eventHtml.replace( '[INTRO]', '' );
        }
        if ( eventObj.country !== null ) {
            eventHtml = eventHtml.replace( '[COUNTRY]', '- ' + eventObj.country );
        } else {
            eventHtml = eventHtml.replace( '[COUNTRY]', '' );
        }

        return eventHtml;
    },

    createNews: function( newsObj ) {
        var template = '<li><a href="[HREF]">' +
            '<img src="[IMG]" alt="[ALTTITLE]"/>' +
            '<div class="summary">' +
            '<h2>[TITLE]</h2>' +
            '<span class="date">' +
            '[DAY] [MONTH] [YEAR] [COUNTRY]' +
            '</span>' +
            '<p>[INTRO]</p>' +
            '<span class="read-more">' + config.language.readmore + '</span>' +
            '</div>' +
            '</a></li>';

        var newsDate = new Date( newsObj.timestamp );

        var newsHtml = template.replace( '[HREF]', newsObj.url )
            .replace( '[DAY]', newsDate.getDate() )
            .replace( '[MONTH]', config.language.monthNamesLong[newsDate.getMonth()] )
            .replace( '[YEAR]', newsDate.getFullYear() )
            .replace( '[TITLE]', newsObj.title )
            .replace( '[IMG]', config.baseUrl + newsObj.imageUrl )
            .replace( '[ALTTITLE]', newsObj.title );

        if ( newsObj.introduction !== null ) {
            newsHtml = newsHtml.replace( '[INTRO]', newsObj.introduction );
        } else {
            newsHtml = newsHtml.replace( '[INTRO]', '' );
        }

        if ( newsObj.country !== null && newsObj.country !== "" ) {
            newsHtml = newsHtml.replace( '[COUNTRY]', '| ' + newsObj.country );
        } else {
            newsHtml = newsHtml.replace( '[COUNTRY]', '' );
        }

        return newsHtml;
    }
};

var Cookie = {
    setCookie: function( name, value, days ) {
        var expires = "";
        if ( days ) {
            var date = new Date();
            date.setTime( date.getTime() + (days * 24 * 60 * 60 * 1000) );
            expires = "; expires=" + date.toGMTString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    },

    getCookie: function( name ) {
        var nameEQ = name + "=";
        var ca = document.cookie.split( ';' );
        for ( var i = 0; i < ca.length; i++ ) {
            var c = ca[i];
            while ( c.charAt( 0 ) == ' ' ) c = c.substring( 1, c.length );
            if ( c.indexOf( nameEQ ) === 0 ) return c.substring( nameEQ.length, c.length );
        }
        return null;
    },

    deleteCookie: function( name ) {
        Cookie.setCookie( name, "", -1 );
    }
};

$( document ).ready( function() {
    ArchiveFilters.init();
} );
;var Swiper = function (selector, params) {
    'use strict';

    /*=========================
      A little bit dirty but required part for IE8 and old FF support
      ===========================*/
    if (document.body.__defineGetter__) {
        if (HTMLElement) {
            var element = HTMLElement.prototype;
            if (element.__defineGetter__) {
                element.__defineGetter__('outerHTML', function () { return new XMLSerializer().serializeToString(this); });
            }
        }
    }

    if (!window.getComputedStyle) {
        window.getComputedStyle = function (el, pseudo) {
            this.el = el;
            this.getPropertyValue = function (prop) {
                var re = /(\-([a-z]){1})/g;
                if (prop === 'float') prop = 'styleFloat';
                if (re.test(prop)) {
                    prop = prop.replace(re, function () {
                        return arguments[2].toUpperCase();
                    });
                }
                return el.currentStyle[prop] ? el.currentStyle[prop] : null;
            };
            return this;
        };
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (obj, start) {
            for (var i = (start || 0), j = this.length; i < j; i++) {
                if (this[i] === obj) { return i; }
            }
            return -1;
        };
    }
    if (!document.querySelectorAll) {
        if (!window.jQuery) return;
    }
    function $$(selector, context) {
        if (document.querySelectorAll)
            return (context || document).querySelectorAll(selector);
        else
            return jQuery(selector, context);
    }

    /*=========================
      Check for correct selector
      ===========================*/
    if (typeof selector === 'undefined') return;

    if (!(selector.nodeType)) {
        if ($$(selector).length === 0) return;
    }

     /*=========================
      _this
      ===========================*/
    var _this = this;

     /*=========================
      Default Flags and vars
      ===========================*/
    _this.touches = {
        start: 0,
        startX: 0,
        startY: 0,
        current: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
        abs: 0
    };
    _this.positions = {
        start: 0,
        abs: 0,
        diff: 0,
        current: 0
    };
    _this.times = {
        start: 0,
        end: 0
    };

    _this.id = (new Date()).getTime();
    _this.container = (selector.nodeType) ? selector : $$(selector)[0];
    _this.isTouched = false;
    _this.isMoved = false;
    _this.activeIndex = 0;
    _this.centerIndex = 0;
    _this.activeLoaderIndex = 0;
    _this.activeLoopIndex = 0;
    _this.previousIndex = null;
    _this.velocity = 0;
    _this.snapGrid = [];
    _this.slidesGrid = [];
    _this.imagesToLoad = [];
    _this.imagesLoaded = 0;
    _this.wrapperLeft = 0;
    _this.wrapperRight = 0;
    _this.wrapperTop = 0;
    _this.wrapperBottom = 0;
    _this.isAndroid = navigator.userAgent.toLowerCase().indexOf('android') >= 0;
    var wrapper, slideSize, wrapperSize, direction, isScrolling, containerSize;

    /*=========================
      Default Parameters
      ===========================*/
    var defaults = {
        eventTarget: 'wrapper', // or 'container'
        mode : 'horizontal', // or 'vertical'
        touchRatio : 1,
        speed : 300,
        freeMode : false,
        freeModeFluid : false,
        momentumRatio: 1,
        momentumBounce: true,
        momentumBounceRatio: 1,
        slidesPerView : 1,
        slidesPerGroup : 1,
        slidesPerViewFit: true, //Fit to slide when spv "auto" and slides larger than container
        simulateTouch : true,
        followFinger : true,
        shortSwipes : true,
        longSwipesRatio: 0.5,
        moveStartThreshold: false,
        onlyExternal : false,
        createPagination : true,
        pagination : false,
        paginationElement: 'span',
        paginationClickable: false,
        paginationAsRange: true,
        resistance : true, // or false or 100%
        scrollContainer : false,
        preventLinks : true,
        preventLinksPropagation: false,
        noSwiping : false, // or class
        noSwipingClass : 'swiper-no-swiping', //:)
        initialSlide: 0,
        keyboardControl: false,
        mousewheelControl : false,
        mousewheelControlForceToAxis : false,
        useCSS3Transforms : true,
        // Autoplay
        autoplay: false,
        autoplayDisableOnInteraction: true,
        autoplayStopOnLast: false,
        //Loop mode
        loop: false,
        loopAdditionalSlides: 0,
        // Round length values
        roundLengths: false,
        //Auto Height
        calculateHeight: false,
        cssWidthAndHeight: false,
        //Images Preloader
        updateOnImagesReady : true,
        //Form elements
        releaseFormElements : true,
        //Watch for active slide, useful when use effects on different slide states
        watchActiveIndex: false,
        //Slides Visibility Fit
        visibilityFullFit : false,
        //Slides Offset
        offsetPxBefore : 0,
        offsetPxAfter : 0,
        offsetSlidesBefore : 0,
        offsetSlidesAfter : 0,
        centeredSlides: false,
        //Queue callbacks
        queueStartCallbacks : false,
        queueEndCallbacks : false,
        //Auto Resize
        autoResize : true,
        resizeReInit : false,
        //DOMAnimation
        DOMAnimation : true,
        //Slides Loader
        loader: {
            slides: [], //array with slides
            slidesHTMLType: 'inner', // or 'outer'
            surroundGroups: 1, //keep preloaded slides groups around view
            logic: 'reload', //or 'change'
            loadAllSlides: false
        },
        //Namespace
        slideElement: 'div',
        slideClass: 'swiper-slide',
        slideActiveClass: 'swiper-slide-active',
        slideVisibleClass: 'swiper-slide-visible',
        slideDuplicateClass: 'swiper-slide-duplicate',
        wrapperClass: 'swiper-wrapper',
        paginationElementClass: 'swiper-pagination-switch',
        paginationActiveClass: 'swiper-active-switch',
        paginationVisibleClass: 'swiper-visible-switch'
    };
    params = params || {};
    for (var prop in defaults) {
        if (prop in params && typeof params[prop] === 'object') {
            for (var subProp in defaults[prop]) {
                if (! (subProp in params[prop])) {
                    params[prop][subProp] = defaults[prop][subProp];
                }
            }
        }
        else if (! (prop in params)) {
            params[prop] = defaults[prop];
        }
    }
    _this.params = params;
    if (params.scrollContainer) {
        params.freeMode = true;
        params.freeModeFluid = true;
    }
    if (params.loop) {
        params.resistance = '100%';
    }
    var isH = params.mode === 'horizontal';

    /*=========================
      Define Touch Events
      ===========================*/
    var desktopEvents = ['mousedown', 'mousemove', 'mouseup'];
    if (_this.browser.ie10) desktopEvents = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
    if (_this.browser.ie11) desktopEvents = ['pointerdown', 'pointermove', 'pointerup'];

    _this.touchEvents = {
        touchStart : _this.support.touch || !params.simulateTouch  ? 'touchstart' : desktopEvents[0],
        touchMove : _this.support.touch || !params.simulateTouch ? 'touchmove' : desktopEvents[1],
        touchEnd : _this.support.touch || !params.simulateTouch ? 'touchend' : desktopEvents[2]
    };

    /*=========================
      Wrapper
      ===========================*/
    for (var i = _this.container.childNodes.length - 1; i >= 0; i--) {
        if (_this.container.childNodes[i].className) {
            var _wrapperClasses = _this.container.childNodes[i].className.split(/\s+/);
            for (var j = 0; j < _wrapperClasses.length; j++) {
                if (_wrapperClasses[j] === params.wrapperClass) {
                    wrapper = _this.container.childNodes[i];
                }
            }
        }
    }

    _this.wrapper = wrapper;
    /*=========================
      Slide API
      ===========================*/
    _this._extendSwiperSlide = function  (el) {
        el.append = function () {
            if (params.loop) {
                el.insertAfter(_this.slides.length - _this.loopedSlides);
            }
            else {
                _this.wrapper.appendChild(el);
                _this.reInit();
            }

            return el;
        };
        el.prepend = function () {
            if (params.loop) {
                _this.wrapper.insertBefore(el, _this.slides[_this.loopedSlides]);
                _this.removeLoopedSlides();
                _this.calcSlides();
                _this.createLoop();
            }
            else {
                _this.wrapper.insertBefore(el, _this.wrapper.firstChild);
            }
            _this.reInit();
            return el;
        };
        el.insertAfter = function (index) {
            if (typeof index === 'undefined') return false;
            var beforeSlide;

            if (params.loop) {
                beforeSlide = _this.slides[index + 1 + _this.loopedSlides];
                if (beforeSlide) {
                    _this.wrapper.insertBefore(el, beforeSlide);
                }
                else {
                    _this.wrapper.appendChild(el);
                }
                _this.removeLoopedSlides();
                _this.calcSlides();
                _this.createLoop();
            }
            else {
                beforeSlide = _this.slides[index + 1];
                _this.wrapper.insertBefore(el, beforeSlide);
            }
            _this.reInit();
            return el;
        };
        el.clone = function () {
            return _this._extendSwiperSlide(el.cloneNode(true));
        };
        el.remove = function () {
            _this.wrapper.removeChild(el);
            _this.reInit();
        };
        el.html = function (html) {
            if (typeof html === 'undefined') {
                return el.innerHTML;
            }
            else {
                el.innerHTML = html;
                return el;
            }
        };
        el.index = function () {
            var index;
            for (var i = _this.slides.length - 1; i >= 0; i--) {
                if (el === _this.slides[i]) index = i;
            }
            return index;
        };
        el.isActive = function () {
            if (el.index() === _this.activeIndex) return true;
            else return false;
        };
        if (!el.swiperSlideDataStorage) el.swiperSlideDataStorage = {};
        el.getData = function (name) {
            return el.swiperSlideDataStorage[name];
        };
        el.setData = function (name, value) {
            el.swiperSlideDataStorage[name] = value;
            return el;
        };
        el.data = function (name, value) {
            if (typeof value === 'undefined') {
                return el.getAttribute('data-' + name);
            }
            else {
                el.setAttribute('data-' + name, value);
                return el;
            }
        };
        el.getWidth = function (outer, round) {
            return _this.h.getWidth(el, outer, round);
        };
        el.getHeight = function (outer, round) {
            return _this.h.getHeight(el, outer, round);
        };
        el.getOffset = function () {
            return _this.h.getOffset(el);
        };
        return el;
    };

    //Calculate information about number of slides
    _this.calcSlides = function (forceCalcSlides) {
        var oldNumber = _this.slides ? _this.slides.length : false;
        _this.slides = [];
        _this.displaySlides = [];
        for (var i = 0; i < _this.wrapper.childNodes.length; i++) {
            if (_this.wrapper.childNodes[i].className) {
                var _className = _this.wrapper.childNodes[i].className;
                var _slideClasses = _className.split(/\s+/);
                for (var j = 0; j < _slideClasses.length; j++) {
                    if (_slideClasses[j] === params.slideClass) {
                        _this.slides.push(_this.wrapper.childNodes[i]);
                    }
                }
            }
        }
        for (i = _this.slides.length - 1; i >= 0; i--) {
            _this._extendSwiperSlide(_this.slides[i]);
        }
        if (oldNumber === false) return;
        if (oldNumber !== _this.slides.length || forceCalcSlides) {

            // Number of slides has been changed
            removeSlideEvents();
            addSlideEvents();
            _this.updateActiveSlide();
            if (_this.params.pagination) _this.createPagination();
            _this.callPlugins('numberOfSlidesChanged');
        }
    };

    //Create Slide
    _this.createSlide = function (html, slideClassList, el) {
        slideClassList = slideClassList || _this.params.slideClass;
        el = el || params.slideElement;
        var newSlide = document.createElement(el);
        newSlide.innerHTML = html || '';
        newSlide.className = slideClassList;
        return _this._extendSwiperSlide(newSlide);
    };

    //Append Slide
    _this.appendSlide = function (html, slideClassList, el) {
        if (!html) return;
        if (html.nodeType) {
            return _this._extendSwiperSlide(html).append();
        }
        else {
            return _this.createSlide(html, slideClassList, el).append();
        }
    };
    _this.prependSlide = function (html, slideClassList, el) {
        if (!html) return;
        if (html.nodeType) {
            return _this._extendSwiperSlide(html).prepend();
        }
        else {
            return _this.createSlide(html, slideClassList, el).prepend();
        }
    };
    _this.insertSlideAfter = function (index, html, slideClassList, el) {
        if (typeof index === 'undefined') return false;
        if (html.nodeType) {
            return _this._extendSwiperSlide(html).insertAfter(index);
        }
        else {
            return _this.createSlide(html, slideClassList, el).insertAfter(index);
        }
    };
    _this.removeSlide = function (index) {
        if (_this.slides[index]) {
            if (params.loop) {
                if (!_this.slides[index + _this.loopedSlides]) return false;
                _this.slides[index + _this.loopedSlides].remove();
                _this.removeLoopedSlides();
                _this.calcSlides();
                _this.createLoop();
            }
            else _this.slides[index].remove();
            return true;
        }
        else return false;
    };
    _this.removeLastSlide = function () {
        if (_this.slides.length > 0) {
            if (params.loop) {
                _this.slides[_this.slides.length - 1 - _this.loopedSlides].remove();
                _this.removeLoopedSlides();
                _this.calcSlides();
                _this.createLoop();
            }
            else _this.slides[_this.slides.length - 1].remove();
            return true;
        }
        else {
            return false;
        }
    };
    _this.removeAllSlides = function () {
        for (var i = _this.slides.length - 1; i >= 0; i--) {
            _this.slides[i].remove();
        }
    };
    _this.getSlide = function (index) {
        return _this.slides[index];
    };
    _this.getLastSlide = function () {
        return _this.slides[_this.slides.length - 1];
    };
    _this.getFirstSlide = function () {
        return _this.slides[0];
    };

    //Currently Active Slide
    _this.activeSlide = function () {
        return _this.slides[_this.activeIndex];
    };

    /*=========================
     Wrapper for Callbacks : Allows additive callbacks via function arrays
     ===========================*/
    _this.fireCallback = function () {
        var callback = arguments[0];
        if (Object.prototype.toString.call(callback) === '[object Array]') {
            for (var i = 0; i < callback.length; i++) {
                if (typeof callback[i] === 'function') {
                    callback[i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
        } else if (Object.prototype.toString.call(callback) === '[object String]') {
            if (params['on' + callback]) _this.fireCallback(params['on' + callback]);
        } else {
            callback(arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
    };
    function isArray(obj) {
        if (Object.prototype.toString.apply(obj) === '[object Array]') return true;
        return false;
    }

    /**
     * Allows user to add callbacks, rather than replace them
     * @param callback
     * @param func
     * @return {*}
     */
    _this.addCallback = function (callback, func) {
        var _this = this, tempFunc;
        if (_this.params['on' + callback]) {
            if (isArray(this.params['on' + callback])) {
                return this.params['on' + callback].push(func);
            } else if (typeof this.params['on' + callback] === 'function') {
                tempFunc = this.params['on' + callback];
                this.params['on' + callback] = [];
                this.params['on' + callback].push(tempFunc);
                return this.params['on' + callback].push(func);
            }
        } else {
            this.params['on' + callback] = [];
            return this.params['on' + callback].push(func);
        }
    };
    _this.removeCallbacks = function (callback) {
        if (_this.params['on' + callback]) {
            _this.params['on' + callback] = null;
        }
    };

    /*=========================
      Plugins API
      ===========================*/
    var _plugins = [];
    for (var plugin in _this.plugins) {
        if (params[plugin]) {
            var p = _this.plugins[plugin](_this, params[plugin]);
            if (p) _plugins.push(p);
        }
    }
    _this.callPlugins = function (method, args) {
        if (!args) args = {};
        for (var i = 0; i < _plugins.length; i++) {
            if (method in _plugins[i]) {
                _plugins[i][method](args);
            }
        }
    };

    /*=========================
      Windows Phone 8 Fix
      ===========================*/
    if ((_this.browser.ie10 || _this.browser.ie11) && !params.onlyExternal) {
        _this.wrapper.classList.add('swiper-wp8-' + (isH ? 'horizontal' : 'vertical'));
    }

    /*=========================
      Free Mode Class
      ===========================*/
    if (params.freeMode) {
        _this.container.className += ' swiper-free-mode';
    }

    /*==================================================
        Init/Re-init/Resize Fix
    ====================================================*/
    _this.initialized = false;
    _this.init = function (force, forceCalcSlides) {
        var _width = _this.h.getWidth(_this.container, false, params.roundLengths);
        var _height = _this.h.getHeight(_this.container, false, params.roundLengths);
        if (_width === _this.width && _height === _this.height && !force) return;

        _this.width = _width;
        _this.height = _height;

        var slideWidth, slideHeight, slideMaxHeight, wrapperWidth, wrapperHeight, slideLeft;
        var i; // loop index variable to avoid JSHint W004 / W038
        containerSize = isH ? _width : _height;
        var wrapper = _this.wrapper;

        if (force) {
            _this.calcSlides(forceCalcSlides);
        }

        if (params.slidesPerView === 'auto') {
            //Auto mode
            var slidesWidth = 0;
            var slidesHeight = 0;

            //Unset Styles
            if (params.slidesOffset > 0) {
                wrapper.style.paddingLeft = '';
                wrapper.style.paddingRight = '';
                wrapper.style.paddingTop = '';
                wrapper.style.paddingBottom = '';
            }
            wrapper.style.width = '';
            wrapper.style.height = '';
            if (params.offsetPxBefore > 0) {
                if (isH) _this.wrapperLeft = params.offsetPxBefore;
                else _this.wrapperTop = params.offsetPxBefore;
            }
            if (params.offsetPxAfter > 0) {
                if (isH) _this.wrapperRight = params.offsetPxAfter;
                else _this.wrapperBottom = params.offsetPxAfter;
            }

            if (params.centeredSlides) {
                if (isH) {
                    _this.wrapperLeft = (containerSize - this.slides[0].getWidth(true, params.roundLengths)) / 2;
                    _this.wrapperRight = (containerSize - _this.slides[_this.slides.length - 1].getWidth(true, params.roundLengths)) / 2;
                }
                else {
                    _this.wrapperTop = (containerSize - _this.slides[0].getHeight(true, params.roundLengths)) / 2;
                    _this.wrapperBottom = (containerSize - _this.slides[_this.slides.length - 1].getHeight(true, params.roundLengths)) / 2;
                }
            }

            if (isH) {
                if (_this.wrapperLeft >= 0) wrapper.style.paddingLeft = _this.wrapperLeft + 'px';
                if (_this.wrapperRight >= 0) wrapper.style.paddingRight = _this.wrapperRight + 'px';
            }
            else {
                if (_this.wrapperTop >= 0) wrapper.style.paddingTop = _this.wrapperTop + 'px';
                if (_this.wrapperBottom >= 0) wrapper.style.paddingBottom = _this.wrapperBottom + 'px';
            }
            slideLeft = 0;
            var centeredSlideLeft = 0;
            _this.snapGrid = [];
            _this.slidesGrid = [];

            slideMaxHeight = 0;
            for (i = 0; i < _this.slides.length; i++) {
                slideWidth = _this.slides[i].getWidth(true, params.roundLengths);
                slideHeight = _this.slides[i].getHeight(true, params.roundLengths);
                if (params.calculateHeight) {
                    slideMaxHeight = Math.max(slideMaxHeight, slideHeight);
                }
                var _slideSize = isH ? slideWidth : slideHeight;
                if (params.centeredSlides) {
                    var nextSlideWidth = i === _this.slides.length - 1 ? 0 : _this.slides[i + 1].getWidth(true, params.roundLengths);
                    var nextSlideHeight = i === _this.slides.length - 1 ? 0 : _this.slides[i + 1].getHeight(true, params.roundLengths);
                    var nextSlideSize = isH ? nextSlideWidth : nextSlideHeight;
                    if (_slideSize > containerSize) {
                        if (params.slidesPerViewFit) {
                            _this.snapGrid.push(slideLeft + _this.wrapperLeft);
                            _this.snapGrid.push(slideLeft + _slideSize - containerSize + _this.wrapperLeft);
                        }
                        else {
                            for (var j = 0; j <= Math.floor(_slideSize / (containerSize + _this.wrapperLeft)); j++) {
                                if (j === 0) _this.snapGrid.push(slideLeft + _this.wrapperLeft);
                                else _this.snapGrid.push(slideLeft + _this.wrapperLeft + containerSize * j);
                            }
                        }
                        _this.slidesGrid.push(slideLeft + _this.wrapperLeft);
                    }
                    else {
                        _this.snapGrid.push(centeredSlideLeft);
                        _this.slidesGrid.push(centeredSlideLeft);
                    }
                    centeredSlideLeft += _slideSize / 2 + nextSlideSize / 2;
                }
                else {
                    if (_slideSize > containerSize) {
                        if (params.slidesPerViewFit) {
                            _this.snapGrid.push(slideLeft);
                            _this.snapGrid.push(slideLeft + _slideSize - containerSize);
                        }
                        else {
                            if (containerSize !== 0) {
                                for (var k = 0; k <= Math.floor(_slideSize / containerSize); k++) {
                                    _this.snapGrid.push(slideLeft + containerSize * k);
                                }
                            }
                            else {
                                _this.snapGrid.push(slideLeft);
                            }
                        }

                    }
                    else {
                        _this.snapGrid.push(slideLeft);
                    }
                    _this.slidesGrid.push(slideLeft);
                }

                slideLeft += _slideSize;

                slidesWidth += slideWidth;
                slidesHeight += slideHeight;
            }
            if (params.calculateHeight) _this.height = slideMaxHeight;
            if (isH) {
                wrapperSize = slidesWidth + _this.wrapperRight + _this.wrapperLeft;
                wrapper.style.width = (slidesWidth) + 'px';
                wrapper.style.height = (_this.height) + 'px';
            }
            else {
                wrapperSize = slidesHeight + _this.wrapperTop + _this.wrapperBottom;
                wrapper.style.width = (_this.width) + 'px';
                wrapper.style.height = (slidesHeight) + 'px';
            }

        }
        else if (params.scrollContainer) {
            //Scroll Container
            wrapper.style.width = '';
            wrapper.style.height = '';
            wrapperWidth = _this.slides[0].getWidth(true, params.roundLengths);
            wrapperHeight = _this.slides[0].getHeight(true, params.roundLengths);
            wrapperSize = isH ? wrapperWidth : wrapperHeight;
            wrapper.style.width = wrapperWidth + 'px';
            wrapper.style.height = wrapperHeight + 'px';
            slideSize = isH ? wrapperWidth : wrapperHeight;

        }
        else {
            //For usual slides
            if (params.calculateHeight) {
                slideMaxHeight = 0;
                wrapperHeight = 0;
                //ResetWrapperSize
                if (!isH) _this.container.style.height = '';
                wrapper.style.height = '';

                for (i = 0; i < _this.slides.length; i++) {
                    //ResetSlideSize
                    _this.slides[i].style.height = '';
                    slideMaxHeight = Math.max(_this.slides[i].getHeight(true), slideMaxHeight);
                    if (!isH) wrapperHeight += _this.slides[i].getHeight(true);
                }
                slideHeight = slideMaxHeight;
                _this.height = slideHeight;

                if (isH) wrapperHeight = slideHeight;
                else {
                    containerSize = slideHeight;
                    _this.container.style.height = containerSize + 'px';
                }
            }
            else {
                slideHeight = isH ? _this.height : _this.height / params.slidesPerView;
                if (params.roundLengths) slideHeight = Math.round(slideHeight);
                wrapperHeight = isH ? _this.height : _this.slides.length * slideHeight;
            }
            slideWidth = isH ? _this.width / params.slidesPerView : _this.width;
            if (params.roundLengths) slideWidth = Math.round(slideWidth);
            wrapperWidth = isH ? _this.slides.length * slideWidth : _this.width;
            slideSize = isH ? slideWidth : slideHeight;

            if (params.offsetSlidesBefore > 0) {
                if (isH) _this.wrapperLeft = slideSize * params.offsetSlidesBefore;
                else _this.wrapperTop = slideSize * params.offsetSlidesBefore;
            }
            if (params.offsetSlidesAfter > 0) {
                if (isH) _this.wrapperRight = slideSize * params.offsetSlidesAfter;
                else _this.wrapperBottom = slideSize * params.offsetSlidesAfter;
            }
            if (params.offsetPxBefore > 0) {
                if (isH) _this.wrapperLeft = params.offsetPxBefore;
                else _this.wrapperTop = params.offsetPxBefore;
            }
            if (params.offsetPxAfter > 0) {
                if (isH) _this.wrapperRight = params.offsetPxAfter;
                else _this.wrapperBottom = params.offsetPxAfter;
            }
            if (params.centeredSlides) {
                if (isH) {
                    _this.wrapperLeft = (containerSize - slideSize) / 2;
                    _this.wrapperRight = (containerSize - slideSize) / 2;
                }
                else {
                    _this.wrapperTop = (containerSize - slideSize) / 2;
                    _this.wrapperBottom = (containerSize - slideSize) / 2;
                }
            }
            if (isH) {
                if (_this.wrapperLeft > 0) wrapper.style.paddingLeft = _this.wrapperLeft + 'px';
                if (_this.wrapperRight > 0) wrapper.style.paddingRight = _this.wrapperRight + 'px';
            }
            else {
                if (_this.wrapperTop > 0) wrapper.style.paddingTop = _this.wrapperTop + 'px';
                if (_this.wrapperBottom > 0) wrapper.style.paddingBottom = _this.wrapperBottom + 'px';
            }

            wrapperSize = isH ? wrapperWidth + _this.wrapperRight + _this.wrapperLeft : wrapperHeight + _this.wrapperTop + _this.wrapperBottom;
            if (!params.cssWidthAndHeight) {
                if (parseFloat(wrapperWidth) > 0) {
                    wrapper.style.width = wrapperWidth + 'px';
                }
                if (parseFloat(wrapperHeight) > 0) {
                    wrapper.style.height = wrapperHeight + 'px';
                }
            }
            slideLeft = 0;
            _this.snapGrid = [];
            _this.slidesGrid = [];
            for (i = 0; i < _this.slides.length; i++) {
                _this.snapGrid.push(slideLeft);
                _this.slidesGrid.push(slideLeft);
                slideLeft += slideSize;
                if (!params.cssWidthAndHeight) {
                    if (parseFloat(slideWidth) > 0) {
                        _this.slides[i].style.width = slideWidth + 'px';
                    }
                    if (parseFloat(slideHeight) > 0) {
                        _this.slides[i].style.height = slideHeight + 'px';
                    }
                }
            }

        }

        if (!_this.initialized) {
            _this.callPlugins('onFirstInit');
            if (params.onFirstInit) _this.fireCallback(params.onFirstInit, _this);
        }
        else {
            _this.callPlugins('onInit');
            if (params.onInit) _this.fireCallback(params.onInit, _this);
        }
        _this.initialized = true;
    };

    _this.reInit = function (forceCalcSlides) {
        _this.init(true, forceCalcSlides);
    };

    _this.resizeFix = function (reInit) {
        _this.callPlugins('beforeResizeFix');

        _this.init(params.resizeReInit || reInit);

        // swipe to active slide in fixed mode
        if (!params.freeMode) {
            _this.swipeTo((params.loop ? _this.activeLoopIndex : _this.activeIndex), 0, false);
            // Fix autoplay
            if (params.autoplay) {
                if (_this.support.transitions && typeof autoplayTimeoutId !== 'undefined') {
                    if (typeof autoplayTimeoutId !== 'undefined') {
                        clearTimeout(autoplayTimeoutId);
                        autoplayTimeoutId = undefined;
                        _this.startAutoplay();
                    }
                }
                else {
                    if (typeof autoplayIntervalId !== 'undefined') {
                        clearInterval(autoplayIntervalId);
                        autoplayIntervalId = undefined;
                        _this.startAutoplay();
                    }
                }
            }
        }
        // move wrapper to the beginning in free mode
        else if (_this.getWrapperTranslate() < -maxWrapperPosition()) {
            _this.setWrapperTransition(0);
            _this.setWrapperTranslate(-maxWrapperPosition());
        }

        _this.callPlugins('afterResizeFix');
    };

    /*==========================================
        Max and Min Positions
    ============================================*/
    function maxWrapperPosition() {
        var a = (wrapperSize - containerSize);
        if (params.freeMode) {
            a = wrapperSize - containerSize;
        }
        // if (params.loop) a -= containerSize;
        if (params.slidesPerView > _this.slides.length && !params.centeredSlides) {
            a = 0;
        }
        if (a < 0) a = 0;
        return a;
    }

    /*==========================================
        Event Listeners
    ============================================*/
    function initEvents() {
        var bind = _this.h.addEventListener;
        var eventTarget = params.eventTarget === 'wrapper' ? _this.wrapper : _this.container;
        //Touch Events
        if (! (_this.browser.ie10 || _this.browser.ie11)) {
            if (_this.support.touch) {
                bind(eventTarget, 'touchstart', onTouchStart);
                bind(eventTarget, 'touchmove', onTouchMove);
                bind(eventTarget, 'touchend', onTouchEnd);
            }
            if (params.simulateTouch) {
                bind(eventTarget, 'mousedown', onTouchStart);
                bind(document, 'mousemove', onTouchMove);
                bind(document, 'mouseup', onTouchEnd);
            }
        }
        else {
            bind(eventTarget, _this.touchEvents.touchStart, onTouchStart);
            bind(document, _this.touchEvents.touchMove, onTouchMove);
            bind(document, _this.touchEvents.touchEnd, onTouchEnd);
        }

        //Resize Event
        if (params.autoResize) {
            bind(window, 'resize', _this.resizeFix);
        }
        //Slide Events
        addSlideEvents();
        //Mousewheel
        _this._wheelEvent = false;
        if (params.mousewheelControl) {
            if (document.onmousewheel !== undefined) {
                _this._wheelEvent = 'mousewheel';
            }
            if (!_this._wheelEvent) {
                try {
                    new WheelEvent('wheel');
                    _this._wheelEvent = 'wheel';
                } catch (e) {}
            }
            if (!_this._wheelEvent) {
                _this._wheelEvent = 'DOMMouseScroll';
            }
            if (_this._wheelEvent) {
                bind(_this.container, _this._wheelEvent, handleMousewheel);
            }
        }

        //Keyboard
        function _loadImage(src) {
            var image = new Image();
            image.onload = function () {
                if (_this && _this.imagesLoaded !== undefined) _this.imagesLoaded++;
                if (_this.imagesLoaded === _this.imagesToLoad.length) {
                    _this.reInit();
                    if (params.onImagesReady) _this.fireCallback(params.onImagesReady, _this);
                }
            };
            image.src = src;
        }

        if (params.keyboardControl) {
            bind(document, 'keydown', handleKeyboardKeys);
        }
        if (params.updateOnImagesReady) {
            _this.imagesToLoad = $$('img', _this.container);

            for (var i = 0; i < _this.imagesToLoad.length; i++) {
                _loadImage(_this.imagesToLoad[i].getAttribute('src'));
            }
        }
    }

    //Remove Event Listeners
    _this.destroy = function () {
        var unbind = _this.h.removeEventListener;
        var eventTarget = params.eventTarget === 'wrapper' ? _this.wrapper : _this.container;
        //Touch Events
        if (! (_this.browser.ie10 || _this.browser.ie11)) {
            if (_this.support.touch) {
                unbind(eventTarget, 'touchstart', onTouchStart);
                unbind(eventTarget, 'touchmove', onTouchMove);
                unbind(eventTarget, 'touchend', onTouchEnd);
            }
            if (params.simulateTouch) {
                unbind(eventTarget, 'mousedown', onTouchStart);
                unbind(document, 'mousemove', onTouchMove);
                unbind(document, 'mouseup', onTouchEnd);
            }
        }
        else {
            unbind(eventTarget, _this.touchEvents.touchStart, onTouchStart);
            unbind(document, _this.touchEvents.touchMove, onTouchMove);
            unbind(document, _this.touchEvents.touchEnd, onTouchEnd);
        }

        //Resize Event
        if (params.autoResize) {
            unbind(window, 'resize', _this.resizeFix);
        }

        //Init Slide Events
        removeSlideEvents();

        //Pagination
        if (params.paginationClickable) {
            removePaginationEvents();
        }

        //Mousewheel
        if (params.mousewheelControl && _this._wheelEvent) {
            unbind(_this.container, _this._wheelEvent, handleMousewheel);
        }

        //Keyboard
        if (params.keyboardControl) {
            unbind(document, 'keydown', handleKeyboardKeys);
        }

        //Stop autoplay
        if (params.autoplay) {
            _this.stopAutoplay();
        }
        _this.callPlugins('onDestroy');

        //Destroy variable
        _this = null;
    };

    function addSlideEvents() {
        var bind = _this.h.addEventListener,
            i;

        //Prevent Links Events
        if (params.preventLinks) {
            var links = $$('a', _this.container);
            for (i = 0; i < links.length; i++) {
                bind(links[i], 'click', preventClick);
            }
        }
        //Release Form Elements
        if (params.releaseFormElements) {
            var formElements = $$('input, textarea, select', _this.container);
            for (i = 0; i < formElements.length; i++) {
                bind(formElements[i], _this.touchEvents.touchStart, releaseForms, true);
            }
        }

        //Slide Clicks & Touches
        if (params.onSlideClick) {
            for (i = 0; i < _this.slides.length; i++) {
                bind(_this.slides[i], 'click', slideClick);
            }
        }
        if (params.onSlideTouch) {
            for (i = 0; i < _this.slides.length; i++) {
                bind(_this.slides[i], _this.touchEvents.touchStart, slideTouch);
            }
        }
    }
    function removeSlideEvents() {
        var unbind = _this.h.removeEventListener,
            i;

        //Slide Clicks & Touches
        if (params.onSlideClick) {
            for (i = 0; i < _this.slides.length; i++) {
                unbind(_this.slides[i], 'click', slideClick);
            }
        }
        if (params.onSlideTouch) {
            for (i = 0; i < _this.slides.length; i++) {
                unbind(_this.slides[i], _this.touchEvents.touchStart, slideTouch);
            }
        }
        //Release Form Elements
        if (params.releaseFormElements) {
            var formElements = $$('input, textarea, select', _this.container);
            for (i = 0; i < formElements.length; i++) {
                unbind(formElements[i], _this.touchEvents.touchStart, releaseForms, true);
            }
        }
        //Prevent Links Events
        if (params.preventLinks) {
            var links = $$('a', _this.container);
            for (i = 0; i < links.length; i++) {
                unbind(links[i], 'click', preventClick);
            }
        }
    }
    /*==========================================
        Keyboard Control
    ============================================*/
    function handleKeyboardKeys(e) {
        var kc = e.keyCode || e.charCode;
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return;
        if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
            var inView = false;
            //Check that swiper should be inside of visible area of window
            var swiperOffset = _this.h.getOffset(_this.container);
            var scrollLeft = _this.h.windowScroll().left;
            var scrollTop = _this.h.windowScroll().top;
            var windowWidth = _this.h.windowWidth();
            var windowHeight = _this.h.windowHeight();
            var swiperCoord = [
                [swiperOffset.left, swiperOffset.top],
                [swiperOffset.left + _this.width, swiperOffset.top],
                [swiperOffset.left, swiperOffset.top + _this.height],
                [swiperOffset.left + _this.width, swiperOffset.top + _this.height]
            ];
            for (var i = 0; i < swiperCoord.length; i++) {
                var point = swiperCoord[i];
                if (
                    point[0] >= scrollLeft && point[0] <= scrollLeft + windowWidth &&
                    point[1] >= scrollTop && point[1] <= scrollTop + windowHeight
                ) {
                    inView = true;
                }

            }
            if (!inView) return;
        }
        if (isH) {
            if (kc === 37 || kc === 39) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if (kc === 39) _this.swipeNext();
            if (kc === 37) _this.swipePrev();
        }
        else {
            if (kc === 38 || kc === 40) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if (kc === 40) _this.swipeNext();
            if (kc === 38) _this.swipePrev();
        }
    }

    _this.disableKeyboardControl = function () {
        params.keyboardControl = false;
        _this.h.removeEventListener(document, 'keydown', handleKeyboardKeys);
    };

    _this.enableKeyboardControl = function () {
        params.keyboardControl = true;
        _this.h.addEventListener(document, 'keydown', handleKeyboardKeys);
    };

    /*==========================================
        Mousewheel Control
    ============================================*/
    var lastScrollTime = (new Date()).getTime();
    function handleMousewheel(e) {
        var we = _this._wheelEvent;
        var delta = 0;

        //Opera & IE
        if (e.detail) delta = -e.detail;
        //WebKits
        else if (we === 'mousewheel') {
            if (params.mousewheelControlForceToAxis) {
                if (isH) {
                    if (Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY)) delta = e.wheelDeltaX;
                    else return;
                }
                else {
                    if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)) delta = e.wheelDeltaY;
                    else return;
                }
            }
            else {
                delta = e.wheelDelta;
            }
        }
        //Old FireFox
        else if (we === 'DOMMouseScroll') delta = -e.detail;
        //New FireFox
        else if (we === 'wheel') {
            if (params.mousewheelControlForceToAxis) {
                if (isH) {
                    if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) delta = -e.deltaX;
                    else return;
                }
                else {
                    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) delta = -e.deltaY;
                    else return;
                }
            }
            else {
                delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? - e.deltaX : - e.deltaY;
            }
        }

        if (!params.freeMode) {
            if ((new Date()).getTime() - lastScrollTime > 60) {
                if (delta < 0) _this.swipeNext();
                else _this.swipePrev();
            }
            lastScrollTime = (new Date()).getTime();

        }
        else {
            //Freemode or scrollContainer:
            var position = _this.getWrapperTranslate() + delta;

            if (position > 0) position = 0;
            if (position < -maxWrapperPosition()) position = -maxWrapperPosition();

            _this.setWrapperTransition(0);
            _this.setWrapperTranslate(position);
            _this.updateActiveSlide(position);

            // Return page scroll on edge positions
            if (position === 0 || position === -maxWrapperPosition()) return;
        }
        if (params.autoplay) _this.stopAutoplay(true);

        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return false;
    }

    /*=========================
      Grab Cursor
      ===========================*/
    if (params.grabCursor) {
        var containerStyle = _this.container.style;
        containerStyle.cursor = 'move';
        containerStyle.cursor = 'grab';
        containerStyle.cursor = '-moz-grab';
        containerStyle.cursor = '-webkit-grab';
    }

    /*=========================
      Slides Events Handlers
      ===========================*/

    _this.allowSlideClick = true;
    function slideClick(event) {
        if (_this.allowSlideClick) {
            setClickedSlide(event);
            _this.fireCallback(params.onSlideClick, _this, event);
        }
    }

    function slideTouch(event) {
        setClickedSlide(event);
        _this.fireCallback(params.onSlideTouch, _this, event);
    }

    function setClickedSlide(event) {

        // IE 6-8 support
        if (!event.currentTarget) {
            var element = event.srcElement;
            do {
                if (element.className.indexOf(params.slideClass) > -1) {
                    break;
                }
                element = element.parentNode;
            } while (element);
            _this.clickedSlide = element;
        }
        else {
            _this.clickedSlide = event.currentTarget;
        }

        _this.clickedSlideIndex     = _this.slides.indexOf(_this.clickedSlide);
        _this.clickedSlideLoopIndex = _this.clickedSlideIndex - (_this.loopedSlides || 0);
    }

    _this.allowLinks = true;
    function preventClick(e) {
        if (!_this.allowLinks) {
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            if (params.preventLinksPropagation && 'stopPropagation' in e) {
                e.stopPropagation();
            }
            return false;
        }
    }
    function releaseForms(e) {
        if (e.stopPropagation) e.stopPropagation();
        else e.returnValue = false;
        return false;

    }

    /*==================================================
        Event Handlers
    ====================================================*/
    var isTouchEvent = false;
    var allowThresholdMove;
    var allowMomentumBounce = true;
    function onTouchStart(event) {
        if (params.preventLinks) _this.allowLinks = true;
        //Exit if slider is already was touched
        if (_this.isTouched || params.onlyExternal) {
            return false;
        }

        if (params.noSwiping && (event.target || event.srcElement) && noSwipingSlide(event.target || event.srcElement)) return false;
        allowMomentumBounce = false;
        //Check For Nested Swipers
        _this.isTouched = true;
        isTouchEvent = event.type === 'touchstart';

        if (!isTouchEvent || event.targetTouches.length === 1) {
            _this.callPlugins('onTouchStartBegin');

            if (!isTouchEvent && !_this.isAndroid) {
                if (event.preventDefault) event.preventDefault();
                else event.returnValue = false;
            }

            var pageX = isTouchEvent ? event.targetTouches[0].pageX : (event.pageX || event.clientX);
            var pageY = isTouchEvent ? event.targetTouches[0].pageY : (event.pageY || event.clientY);

            //Start Touches to check the scrolling
            _this.touches.startX = _this.touches.currentX = pageX;
            _this.touches.startY = _this.touches.currentY = pageY;

            _this.touches.start = _this.touches.current = isH ? pageX : pageY;

            //Set Transition Time to 0
            _this.setWrapperTransition(0);

            //Get Start Translate Position
            _this.positions.start = _this.positions.current = _this.getWrapperTranslate();

            //Set Transform
            _this.setWrapperTranslate(_this.positions.start);

            //TouchStartTime
            _this.times.start = (new Date()).getTime();

            //Unset Scrolling
            isScrolling = undefined;

            //Set Treshold
            if (params.moveStartThreshold > 0) {
                allowThresholdMove = false;
            }

            //CallBack
            if (params.onTouchStart) _this.fireCallback(params.onTouchStart, _this);
            _this.callPlugins('onTouchStartEnd');

        }
    }
    var velocityPrevPosition, velocityPrevTime;
    function onTouchMove(event) {
        // If slider is not touched - exit
        if (!_this.isTouched || params.onlyExternal) return;
        if (isTouchEvent && event.type === 'mousemove') return;

        var pageX = isTouchEvent ? event.targetTouches[0].pageX : (event.pageX || event.clientX);
        var pageY = isTouchEvent ? event.targetTouches[0].pageY : (event.pageY || event.clientY);

        //check for scrolling
        if (typeof isScrolling === 'undefined' && isH) {
            isScrolling = !!(isScrolling || Math.abs(pageY - _this.touches.startY) > Math.abs(pageX - _this.touches.startX));
        }
        if (typeof isScrolling === 'undefined' && !isH) {
            isScrolling = !!(isScrolling || Math.abs(pageY - _this.touches.startY) < Math.abs(pageX - _this.touches.startX));
        }
        if (isScrolling) {
            _this.isTouched = false;
            return;
        }

        //Check For Nested Swipers
        if (event.assignedToSwiper) {
            _this.isTouched = false;
            return;
        }
        event.assignedToSwiper = true;

        //Block inner links
        if (params.preventLinks) {
            _this.allowLinks = false;
        }
        if (params.onSlideClick) {
            _this.allowSlideClick = false;
        }

        //Stop AutoPlay if exist
        if (params.autoplay) {
            _this.stopAutoplay(true);
        }
        if (!isTouchEvent || event.touches.length === 1) {

            //Moved Flag
            if (!_this.isMoved) {
                _this.callPlugins('onTouchMoveStart');

                if (params.loop) {
                    _this.fixLoop();
                    _this.positions.start = _this.getWrapperTranslate();
                }
                if (params.onTouchMoveStart) _this.fireCallback(params.onTouchMoveStart, _this);
            }
            _this.isMoved = true;

            // cancel event
            if (event.preventDefault) event.preventDefault();
            else event.returnValue = false;

            _this.touches.current = isH ? pageX : pageY;

            _this.positions.current = (_this.touches.current - _this.touches.start) * params.touchRatio + _this.positions.start;

            //Resistance Callbacks
            if (_this.positions.current > 0 && params.onResistanceBefore) {
                _this.fireCallback(params.onResistanceBefore, _this, _this.positions.current);
            }
            if (_this.positions.current < -maxWrapperPosition() && params.onResistanceAfter) {
                _this.fireCallback(params.onResistanceAfter, _this, Math.abs(_this.positions.current + maxWrapperPosition()));
            }
            //Resistance
            if (params.resistance && params.resistance !== '100%') {
                var resistance;
                //Resistance for Negative-Back sliding
                if (_this.positions.current > 0) {
                    resistance = 1 - _this.positions.current / containerSize / 2;
                    if (resistance < 0.5)
                        _this.positions.current = (containerSize / 2);
                    else
                        _this.positions.current = _this.positions.current * resistance;
                }
                //Resistance for After-End Sliding
                if (_this.positions.current < -maxWrapperPosition()) {

                    var diff = (_this.touches.current - _this.touches.start) * params.touchRatio + (maxWrapperPosition() + _this.positions.start);
                    resistance = (containerSize + diff) / (containerSize);
                    var newPos = _this.positions.current - diff * (1 - resistance) / 2;
                    var stopPos = -maxWrapperPosition() - containerSize / 2;

                    if (newPos < stopPos || resistance <= 0)
                        _this.positions.current = stopPos;
                    else
                        _this.positions.current = newPos;
                }
            }
            if (params.resistance && params.resistance === '100%') {
                //Resistance for Negative-Back sliding
                if (_this.positions.current > 0 && !(params.freeMode && !params.freeModeFluid)) {
                    _this.positions.current = 0;
                }
                //Resistance for After-End Sliding
                if (_this.positions.current < -maxWrapperPosition() && !(params.freeMode && !params.freeModeFluid)) {
                    _this.positions.current = -maxWrapperPosition();
                }
            }
            //Move Slides
            if (!params.followFinger) return;

            if (!params.moveStartThreshold) {
                _this.setWrapperTranslate(_this.positions.current);
            }
            else {
                if (Math.abs(_this.touches.current - _this.touches.start) > params.moveStartThreshold || allowThresholdMove) {
                    if (!allowThresholdMove) {
                        allowThresholdMove = true;
                        _this.touches.start = _this.touches.current;
                        return;
                    }
                    _this.setWrapperTranslate(_this.positions.current);
                }
                else {
                    _this.positions.current = _this.positions.start;
                }
            }

            if (params.freeMode || params.watchActiveIndex) {
                _this.updateActiveSlide(_this.positions.current);
            }

            //Grab Cursor
            if (params.grabCursor) {
                _this.container.style.cursor = 'move';
                _this.container.style.cursor = 'grabbing';
                _this.container.style.cursor = '-moz-grabbin';
                _this.container.style.cursor = '-webkit-grabbing';
            }
            //Velocity
            if (!velocityPrevPosition) velocityPrevPosition = _this.touches.current;
            if (!velocityPrevTime) velocityPrevTime = (new Date()).getTime();
            _this.velocity = (_this.touches.current - velocityPrevPosition) / ((new Date()).getTime() - velocityPrevTime) / 2;
            if (Math.abs(_this.touches.current - velocityPrevPosition) < 2) _this.velocity = 0;
            velocityPrevPosition = _this.touches.current;
            velocityPrevTime = (new Date()).getTime();
            //Callbacks
            _this.callPlugins('onTouchMoveEnd');
            if (params.onTouchMove) _this.fireCallback(params.onTouchMove, _this);

            return false;
        }
    }
    function onTouchEnd(event) {
        //Check For scrolling
        if (isScrolling) {
            _this.swipeReset();
        }
        // If slider is not touched exit
        if (params.onlyExternal || !_this.isTouched) return;
        _this.isTouched = false;

        //Return Grab Cursor
        if (params.grabCursor) {
            _this.container.style.cursor = 'move';
            _this.container.style.cursor = 'grab';
            _this.container.style.cursor = '-moz-grab';
            _this.container.style.cursor = '-webkit-grab';
        }

        //Check for Current Position
        if (!_this.positions.current && _this.positions.current !== 0) {
            _this.positions.current = _this.positions.start;
        }

        //For case if slider touched but not moved
        if (params.followFinger) {
            _this.setWrapperTranslate(_this.positions.current);
        }

        // TouchEndTime
        _this.times.end = (new Date()).getTime();

        //Difference
        _this.touches.diff = _this.touches.current - _this.touches.start;
        _this.touches.abs = Math.abs(_this.touches.diff);

        _this.positions.diff = _this.positions.current - _this.positions.start;
        _this.positions.abs = Math.abs(_this.positions.diff);

        var diff = _this.positions.diff;
        var diffAbs = _this.positions.abs;
        var timeDiff = _this.times.end - _this.times.start;

        if (diffAbs < 5 && (timeDiff) < 300 && _this.allowLinks === false) {
            if (!params.freeMode && diffAbs !== 0) _this.swipeReset();
            //Release inner links
            if (params.preventLinks) {
                _this.allowLinks = true;
            }
            if (params.onSlideClick) {
                _this.allowSlideClick = true;
            }
        }

        setTimeout(function () {
            //Release inner links
            if (params.preventLinks) {
                _this.allowLinks = true;
            }
            if (params.onSlideClick) {
                _this.allowSlideClick = true;
            }
        }, 100);

        var maxPosition = maxWrapperPosition();

        //Not moved or Prevent Negative Back Sliding/After-End Sliding
        if (!_this.isMoved && params.freeMode) {
            _this.isMoved = false;
            if (params.onTouchEnd) _this.fireCallback(params.onTouchEnd, _this);
            _this.callPlugins('onTouchEnd');
            return;
        }
        if (!_this.isMoved || _this.positions.current > 0 || _this.positions.current < -maxPosition) {
            _this.swipeReset();
            if (params.onTouchEnd) _this.fireCallback(params.onTouchEnd, _this);
            _this.callPlugins('onTouchEnd');
            return;
        }

        _this.isMoved = false;

        //Free Mode
        if (params.freeMode) {
            if (params.freeModeFluid) {
                var momentumDuration = 1000 * params.momentumRatio;
                var momentumDistance = _this.velocity * momentumDuration;
                var newPosition = _this.positions.current + momentumDistance;
                var doBounce = false;
                var afterBouncePosition;
                var bounceAmount = Math.abs(_this.velocity) * 20 * params.momentumBounceRatio;
                if (newPosition < -maxPosition) {
                    if (params.momentumBounce && _this.support.transitions) {
                        if (newPosition + maxPosition < -bounceAmount) newPosition = -maxPosition - bounceAmount;
                        afterBouncePosition = -maxPosition;
                        doBounce = true;
                        allowMomentumBounce = true;
                    }
                    else newPosition = -maxPosition;
                }
                if (newPosition > 0) {
                    if (params.momentumBounce && _this.support.transitions) {
                        if (newPosition > bounceAmount) newPosition = bounceAmount;
                        afterBouncePosition = 0;
                        doBounce = true;
                        allowMomentumBounce = true;
                    }
                    else newPosition = 0;
                }
                //Fix duration
                if (_this.velocity !== 0) momentumDuration = Math.abs((newPosition - _this.positions.current) / _this.velocity);

                _this.setWrapperTranslate(newPosition);

                _this.setWrapperTransition(momentumDuration);

                if (params.momentumBounce && doBounce) {
                    _this.wrapperTransitionEnd(function () {
                        if (!allowMomentumBounce) return;
                        if (params.onMomentumBounce) _this.fireCallback(params.onMomentumBounce, _this);
                        _this.callPlugins('onMomentumBounce');

                        _this.setWrapperTranslate(afterBouncePosition);
                        _this.setWrapperTransition(300);
                    });
                }

                _this.updateActiveSlide(newPosition);
            }
            if (!params.freeModeFluid || timeDiff >= 300) _this.updateActiveSlide(_this.positions.current);

            if (params.onTouchEnd) _this.fireCallback(params.onTouchEnd, _this);
            _this.callPlugins('onTouchEnd');
            return;
        }

        //Direction
        direction = diff < 0 ? 'toNext' : 'toPrev';

        //Short Touches
        if (direction === 'toNext' && (timeDiff <= 300)) {
            if (diffAbs < 30 || !params.shortSwipes) _this.swipeReset();
            else _this.swipeNext(true);
        }

        if (direction === 'toPrev' && (timeDiff <= 300)) {
            if (diffAbs < 30 || !params.shortSwipes) _this.swipeReset();
            else _this.swipePrev(true);
        }

        //Long Touches
        var targetSlideSize = 0;
        if (params.slidesPerView === 'auto') {
            //Define current slide's width
            var currentPosition = Math.abs(_this.getWrapperTranslate());
            var slidesOffset = 0;
            var _slideSize;
            for (var i = 0; i < _this.slides.length; i++) {
                _slideSize = isH ? _this.slides[i].getWidth(true, params.roundLengths) : _this.slides[i].getHeight(true, params.roundLengths);
                slidesOffset += _slideSize;
                if (slidesOffset > currentPosition) {
                    targetSlideSize = _slideSize;
                    break;
                }
            }
            if (targetSlideSize > containerSize) targetSlideSize = containerSize;
        }
        else {
            targetSlideSize = slideSize * params.slidesPerView;
        }
        if (direction === 'toNext' && (timeDiff > 300)) {
            if (diffAbs >= targetSlideSize * params.longSwipesRatio) {
                _this.swipeNext(true);
            }
            else {
                _this.swipeReset();
            }
        }
        if (direction === 'toPrev' && (timeDiff > 300)) {
            if (diffAbs >= targetSlideSize * params.longSwipesRatio) {
                _this.swipePrev(true);
            }
            else {
                _this.swipeReset();
            }
        }
        if (params.onTouchEnd) _this.fireCallback(params.onTouchEnd, _this);
        _this.callPlugins('onTouchEnd');
    }


    /*==================================================
        noSwiping Bubble Check by Isaac Strack
    ====================================================*/
    function noSwipingSlide(el) {
        /*This function is specifically designed to check the parent elements for the noSwiping class, up to the wrapper.
        We need to check parents because while onTouchStart bubbles, _this.isTouched is checked in onTouchStart, which stops the bubbling.
        So, if a text box, for example, is the initial target, and the parent slide container has the noSwiping class, the _this.isTouched
        check will never find it, and what was supposed to be noSwiping is able to be swiped.
        This function will iterate up and check for the noSwiping class in parents, up through the wrapperClass.*/

        // First we create a truthy variable, which is that swiping is allowd (noSwiping = false)
        var noSwiping = false;

        // Now we iterate up (parentElements) until we reach the node with the wrapperClass.
        do {

            // Each time, we check to see if there's a 'swiper-no-swiping' class (noSwipingClass).
            if (el.className.indexOf(params.noSwipingClass) > -1)
            {
                noSwiping = true; // If there is, we set noSwiping = true;
            }

            el = el.parentElement;  // now we iterate up (parent node)

        } while (!noSwiping && el.parentElement && el.className.indexOf(params.wrapperClass) === -1); // also include el.parentElement truthy, just in case.

        // because we didn't check the wrapper itself, we do so now, if noSwiping is false:
        if (!noSwiping && el.className.indexOf(params.wrapperClass) > -1 && el.className.indexOf(params.noSwipingClass) > -1)
            noSwiping = true; // if the wrapper has the noSwipingClass, we set noSwiping = true;

        return noSwiping;
    }

    function addClassToHtmlString(klass, outerHtml) {
        var par = document.createElement('div');
        var child;

        par.innerHTML = outerHtml;
        child = par.firstChild;
        child.className += ' ' + klass;

        return child.outerHTML;
    }


    /*==================================================
        Swipe Functions
    ====================================================*/
    _this.swipeNext = function (internal) {
        if (!internal && params.loop) _this.fixLoop();
        if (!internal && params.autoplay) _this.stopAutoplay(true);
        _this.callPlugins('onSwipeNext');
        var currentPosition = _this.getWrapperTranslate();
        var newPosition = currentPosition;
        if (params.slidesPerView === 'auto') {
            for (var i = 0; i < _this.snapGrid.length; i++) {
                if (-currentPosition >= _this.snapGrid[i] && -currentPosition < _this.snapGrid[i + 1]) {
                    newPosition = -_this.snapGrid[i + 1];
                    break;
                }
            }
        }
        else {
            var groupSize = slideSize * params.slidesPerGroup;
            newPosition = -(Math.floor(Math.abs(currentPosition) / Math.floor(groupSize)) * groupSize + groupSize);
        }
        if (newPosition < -maxWrapperPosition()) {
            newPosition = -maxWrapperPosition();
        }
        if (newPosition === currentPosition) return false;
        swipeToPosition(newPosition, 'next');
        return true;
    };
    _this.swipePrev = function (internal) {
        if (!internal && params.loop) _this.fixLoop();
        if (!internal && params.autoplay) _this.stopAutoplay(true);
        _this.callPlugins('onSwipePrev');

        var currentPosition = Math.ceil(_this.getWrapperTranslate());
        var newPosition;
        if (params.slidesPerView === 'auto') {
            newPosition = 0;
            for (var i = 1; i < _this.snapGrid.length; i++) {
                if (-currentPosition === _this.snapGrid[i]) {
                    newPosition = -_this.snapGrid[i - 1];
                    break;
                }
                if (-currentPosition > _this.snapGrid[i] && -currentPosition < _this.snapGrid[i + 1]) {
                    newPosition = -_this.snapGrid[i];
                    break;
                }
            }
        }
        else {
            var groupSize = slideSize * params.slidesPerGroup;
            newPosition = -(Math.ceil(-currentPosition / groupSize) - 1) * groupSize;
        }

        if (newPosition > 0) newPosition = 0;

        if (newPosition === currentPosition) return false;
        swipeToPosition(newPosition, 'prev');
        return true;

    };
    _this.swipeReset = function () {
        _this.callPlugins('onSwipeReset');
        var currentPosition = _this.getWrapperTranslate();
        var groupSize = slideSize * params.slidesPerGroup;
        var newPosition;
        var maxPosition = -maxWrapperPosition();
        if (params.slidesPerView === 'auto') {
            newPosition = 0;
            for (var i = 0; i < _this.snapGrid.length; i++) {
                if (-currentPosition === _this.snapGrid[i]) return;
                if (-currentPosition >= _this.snapGrid[i] && -currentPosition < _this.snapGrid[i + 1]) {
                    if (_this.positions.diff > 0) newPosition = -_this.snapGrid[i + 1];
                    else newPosition = -_this.snapGrid[i];
                    break;
                }
            }
            if (-currentPosition >= _this.snapGrid[_this.snapGrid.length - 1]) newPosition = -_this.snapGrid[_this.snapGrid.length - 1];
            if (currentPosition <= -maxWrapperPosition()) newPosition = -maxWrapperPosition();
        }
        else {
            newPosition = currentPosition < 0 ? Math.round(currentPosition / groupSize) * groupSize : 0;
        }
        if (params.scrollContainer)  {
            newPosition = currentPosition < 0 ? currentPosition : 0;
        }
        if (newPosition < -maxWrapperPosition()) {
            newPosition = -maxWrapperPosition();
        }
        if (params.scrollContainer && (containerSize > slideSize)) {
            newPosition = 0;
        }

        if (newPosition === currentPosition) return false;

        swipeToPosition(newPosition, 'reset');
        return true;
    };

    _this.swipeTo = function (index, speed, runCallbacks) {
        index = parseInt(index, 10);
        _this.callPlugins('onSwipeTo', {index: index, speed: speed});
        if (params.loop) index = index + _this.loopedSlides;
        var currentPosition = _this.getWrapperTranslate();
        if (index > (_this.slides.length - 1) || index < 0) return;
        var newPosition;
        if (params.slidesPerView === 'auto') {
            newPosition = -_this.slidesGrid[index];
        }
        else {
            newPosition = -index * slideSize;
        }
        if (newPosition < - maxWrapperPosition()) {
            newPosition = - maxWrapperPosition();
        }

        if (newPosition === currentPosition) return false;

        runCallbacks = runCallbacks === false ? false : true;
        swipeToPosition(newPosition, 'to', {index: index, speed: speed, runCallbacks: runCallbacks});
        return true;
    };

    function swipeToPosition(newPosition, action, toOptions) {
        var speed = (action === 'to' && toOptions.speed >= 0) ? toOptions.speed : params.speed;
        var timeOld = + new Date();

        function anim() {
            var timeNew = + new Date();
            var time = timeNew - timeOld;
            currentPosition += animationStep * time / (1000 / 60);
            condition = direction === 'toNext' ? currentPosition > newPosition : currentPosition < newPosition;
            if (condition) {
                _this.setWrapperTranslate(Math.round(currentPosition));
                _this._DOMAnimating = true;
                window.setTimeout(function () {
                    anim();
                }, 1000 / 60);
            }
            else {
                if (params.onSlideChangeEnd) {
                    if (action === 'to') {
                        if (toOptions.runCallbacks === true) _this.fireCallback(params.onSlideChangeEnd, _this);
                    }
                    else {
                        _this.fireCallback(params.onSlideChangeEnd, _this);
                    }

                }
                _this.setWrapperTranslate(newPosition);
                _this._DOMAnimating = false;
            }
        }

        if (_this.support.transitions || !params.DOMAnimation) {
            _this.setWrapperTranslate(newPosition);
            _this.setWrapperTransition(speed);
        }
        else {
            //Try the DOM animation
            var currentPosition = _this.getWrapperTranslate();
            var animationStep = Math.ceil((newPosition - currentPosition) / speed * (1000 / 60));
            var direction = currentPosition > newPosition ? 'toNext' : 'toPrev';
            var condition = direction === 'toNext' ? currentPosition > newPosition : currentPosition < newPosition;
            if (_this._DOMAnimating) return;

            anim();
        }

        //Update Active Slide Index
        _this.updateActiveSlide(newPosition);

        //Callbacks
        if (params.onSlideNext && action === 'next') {
            _this.fireCallback(params.onSlideNext, _this, newPosition);
        }
        if (params.onSlidePrev && action === 'prev') {
            _this.fireCallback(params.onSlidePrev, _this, newPosition);
        }
        //'Reset' Callback
        if (params.onSlideReset && action === 'reset') {
            _this.fireCallback(params.onSlideReset, _this, newPosition);
        }

        //'Next', 'Prev' and 'To' Callbacks
        if (action === 'next' || action === 'prev' || (action === 'to' && toOptions.runCallbacks === true))
            slideChangeCallbacks(action);
    }
    /*==================================================
        Transition Callbacks
    ====================================================*/
    //Prevent Multiple Callbacks
    _this._queueStartCallbacks = false;
    _this._queueEndCallbacks = false;
    function slideChangeCallbacks(direction) {
        //Transition Start Callback
        _this.callPlugins('onSlideChangeStart');
        if (params.onSlideChangeStart) {
            if (params.queueStartCallbacks && _this.support.transitions) {
                if (_this._queueStartCallbacks) return;
                _this._queueStartCallbacks = true;
                _this.fireCallback(params.onSlideChangeStart, _this, direction);
                _this.wrapperTransitionEnd(function () {
                    _this._queueStartCallbacks = false;
                });
            }
            else _this.fireCallback(params.onSlideChangeStart, _this, direction);
        }
        //Transition End Callback
        if (params.onSlideChangeEnd) {
            if (_this.support.transitions) {
                if (params.queueEndCallbacks) {
                    if (_this._queueEndCallbacks) return;
                    _this._queueEndCallbacks = true;
                    _this.wrapperTransitionEnd(function (swiper) {
                        _this.fireCallback(params.onSlideChangeEnd, swiper, direction);
                    });
                }
                else {
                    _this.wrapperTransitionEnd(function (swiper) {
                        _this.fireCallback(params.onSlideChangeEnd, swiper, direction);
                    });
                }
            }
            else {
                if (!params.DOMAnimation) {
                    setTimeout(function () {
                        _this.fireCallback(params.onSlideChangeEnd, _this, direction);
                    }, 10);
                }
            }
        }
    }

    /*==================================================
        Update Active Slide Index
    ====================================================*/
    _this.updateActiveSlide = function (position) {
        if (!_this.initialized) return;
        if (_this.slides.length === 0) return;
        _this.previousIndex = _this.activeIndex;
        if (typeof position === 'undefined') position = _this.getWrapperTranslate();
        if (position > 0) position = 0;
        var i;
        if (params.slidesPerView === 'auto') {
            var slidesOffset = 0;
            _this.activeIndex = _this.slidesGrid.indexOf(-position);
            if (_this.activeIndex < 0) {
                for (i = 0; i < _this.slidesGrid.length - 1; i++) {
                    if (-position > _this.slidesGrid[i] && -position < _this.slidesGrid[i + 1]) {
                        break;
                    }
                }
                var leftDistance = Math.abs(_this.slidesGrid[i] + position);
                var rightDistance = Math.abs(_this.slidesGrid[i + 1] + position);
                if (leftDistance <= rightDistance) _this.activeIndex = i;
                else _this.activeIndex = i + 1;
            }
        }
        else {
            _this.activeIndex = Math[params.visibilityFullFit ? 'ceil' : 'round'](-position / slideSize);
        }

        if (_this.activeIndex === _this.slides.length) _this.activeIndex = _this.slides.length - 1;
        if (_this.activeIndex < 0) _this.activeIndex = 0;

        // Check for slide
        if (!_this.slides[_this.activeIndex]) return;

        // Calc Visible slides
        _this.calcVisibleSlides(position);

        // Mark visible and active slides with additonal classes
        if (_this.support.classList) {
            var slide;
            for (i = 0; i < _this.slides.length; i++) {
                slide = _this.slides[i];
                slide.classList.remove(params.slideActiveClass);
                if (_this.visibleSlides.indexOf(slide) >= 0) {
                    slide.classList.add(params.slideVisibleClass);
                } else {
                    slide.classList.remove(params.slideVisibleClass);
                }
            }
            _this.slides[_this.activeIndex].classList.add(params.slideActiveClass);
        } else {
            var activeClassRegexp = new RegExp('\\s*' + params.slideActiveClass);
            var inViewClassRegexp = new RegExp('\\s*' + params.slideVisibleClass);

            for (i = 0; i < _this.slides.length; i++) {
                _this.slides[i].className = _this.slides[i].className.replace(activeClassRegexp, '').replace(inViewClassRegexp, '');
                if (_this.visibleSlides.indexOf(_this.slides[i]) >= 0) {
                    _this.slides[i].className += ' ' + params.slideVisibleClass;
                }
            }
            _this.slides[_this.activeIndex].className += ' ' + params.slideActiveClass;
        }

        //Update loop index
        if (params.loop) {
            var ls = _this.loopedSlides;
            _this.activeLoopIndex = _this.activeIndex - ls;
            if (_this.activeLoopIndex >= _this.slides.length - ls * 2) {
                _this.activeLoopIndex = _this.slides.length - ls * 2 - _this.activeLoopIndex;
            }
            if (_this.activeLoopIndex < 0) {
                _this.activeLoopIndex = _this.slides.length - ls * 2 + _this.activeLoopIndex;
            }
            if (_this.activeLoopIndex < 0) _this.activeLoopIndex = 0;
        }
        else {
            _this.activeLoopIndex = _this.activeIndex;
        }
        //Update Pagination
        if (params.pagination) {
            _this.updatePagination(position);
        }
    };
    /*==================================================
        Pagination
    ====================================================*/
    _this.createPagination = function (firstInit) {
        if (params.paginationClickable && _this.paginationButtons) {
            removePaginationEvents();
        }
        _this.paginationContainer = params.pagination.nodeType ? params.pagination : $$(params.pagination)[0];
        if (params.createPagination) {
            var paginationHTML = '';
            var numOfSlides = _this.slides.length;
            var numOfButtons = numOfSlides;
            if (params.loop) numOfButtons -= _this.loopedSlides * 2;
            for (var i = 0; i < numOfButtons; i++) {
                paginationHTML += '<' + params.paginationElement + ' class="' + params.paginationElementClass + '"></' + params.paginationElement + '>';
            }
            _this.paginationContainer.innerHTML = paginationHTML;
        }
        _this.paginationButtons = $$('.' + params.paginationElementClass, _this.paginationContainer);
        if (!firstInit) _this.updatePagination();
        _this.callPlugins('onCreatePagination');
        if (params.paginationClickable) {
            addPaginationEvents();
        }
    };
    function removePaginationEvents() {
        var pagers = _this.paginationButtons;
        if (pagers) {
            for (var i = 0; i < pagers.length; i++) {
                _this.h.removeEventListener(pagers[i], 'click', paginationClick);
            }
        }
    }
    function addPaginationEvents() {
        var pagers = _this.paginationButtons;
        if (pagers) {
            for (var i = 0; i < pagers.length; i++) {
                _this.h.addEventListener(pagers[i], 'click', paginationClick);
            }
        }
    }
    function paginationClick(e) {
        var index;
        var target = e.target || e.srcElement;
        var pagers = _this.paginationButtons;
        for (var i = 0; i < pagers.length; i++) {
            if (target === pagers[i]) index = i;
        }
        _this.swipeTo(index);
    }
    _this.updatePagination = function (position) {
        if (!params.pagination) return;
        if (_this.slides.length < 1) return;
        var activePagers = $$('.' + params.paginationActiveClass, _this.paginationContainer);
        if (!activePagers) return;

        //Reset all Buttons' class to not active
        var pagers = _this.paginationButtons;
        if (pagers.length === 0) return;
        for (var i = 0; i < pagers.length; i++) {
            pagers[i].className = params.paginationElementClass;
        }

        var indexOffset = params.loop ? _this.loopedSlides : 0;
        if (params.paginationAsRange) {
            if (!_this.visibleSlides) _this.calcVisibleSlides(position);
            //Get Visible Indexes
            var visibleIndexes = [];
            var j; // lopp index - avoid JSHint W004 / W038
            for (j = 0; j < _this.visibleSlides.length; j++) {
                var visIndex = _this.slides.indexOf(_this.visibleSlides[j]) - indexOffset;

                if (params.loop && visIndex < 0) {
                    visIndex = _this.slides.length - _this.loopedSlides * 2 + visIndex;
                }
                if (params.loop && visIndex >= _this.slides.length - _this.loopedSlides * 2) {
                    visIndex = _this.slides.length - _this.loopedSlides * 2 - visIndex;
                    visIndex = Math.abs(visIndex);
                }
                visibleIndexes.push(visIndex);
            }

            for (j = 0; j < visibleIndexes.length; j++) {
                if (pagers[visibleIndexes[j]]) pagers[visibleIndexes[j]].className += ' ' + params.paginationVisibleClass;
            }

            if (params.loop) {
                if (pagers[_this.activeLoopIndex] !== undefined) {
                    pagers[_this.activeLoopIndex].className += ' ' + params.paginationActiveClass;
                }
            }
            else {
                pagers[_this.activeIndex].className += ' ' + params.paginationActiveClass;
            }
        }
        else {
            if (params.loop) {
                if (pagers[_this.activeLoopIndex]) pagers[_this.activeLoopIndex].className += ' ' + params.paginationActiveClass + ' ' + params.paginationVisibleClass;
            }
            else {
                pagers[_this.activeIndex].className += ' ' + params.paginationActiveClass + ' ' + params.paginationVisibleClass;
            }
        }
    };
    _this.calcVisibleSlides = function (position) {
        var visibleSlides = [];
        var _slideLeft = 0, _slideSize = 0, _slideRight = 0;
        if (isH && _this.wrapperLeft > 0) position = position + _this.wrapperLeft;
        if (!isH && _this.wrapperTop > 0) position = position + _this.wrapperTop;

        for (var i = 0; i < _this.slides.length; i++) {
            _slideLeft += _slideSize;
            if (params.slidesPerView === 'auto')
                _slideSize  = isH ? _this.h.getWidth(_this.slides[i], true, params.roundLengths) : _this.h.getHeight(_this.slides[i], true, params.roundLengths);
            else _slideSize = slideSize;

            _slideRight = _slideLeft + _slideSize;
            var isVisibile = false;
            if (params.visibilityFullFit) {
                if (_slideLeft >= -position && _slideRight <= -position + containerSize) isVisibile = true;
                if (_slideLeft <= -position && _slideRight >= -position + containerSize) isVisibile = true;
            }
            else {
                if (_slideRight > -position && _slideRight <= ((-position + containerSize))) isVisibile = true;
                if (_slideLeft >= -position && _slideLeft < ((-position + containerSize))) isVisibile = true;
                if (_slideLeft < -position && _slideRight > ((-position + containerSize))) isVisibile = true;
            }

            if (isVisibile) visibleSlides.push(_this.slides[i]);

        }
        if (visibleSlides.length === 0) visibleSlides = [_this.slides[_this.activeIndex]];

        _this.visibleSlides = visibleSlides;
    };

    /*==========================================
        Autoplay
    ============================================*/
    var autoplayTimeoutId, autoplayIntervalId;
    _this.startAutoplay = function () {
        if (_this.support.transitions) {
            if (typeof autoplayTimeoutId !== 'undefined') return false;
            if (!params.autoplay) return;
            _this.callPlugins('onAutoplayStart');
            if (params.onAutoplayStart) _this.fireCallback(params.onAutoplayStart, _this);
            autoplay();
        }
        else {
            if (typeof autoplayIntervalId !== 'undefined') return false;
            if (!params.autoplay) return;
            _this.callPlugins('onAutoplayStart');
            if (params.onAutoplayStart) _this.fireCallback(params.onAutoplayStart, _this);
            autoplayIntervalId = setInterval(function () {
                if (params.loop) {
                    _this.fixLoop();
                    _this.swipeNext(true);
                }
                else if (!_this.swipeNext(true)) {
                    if (!params.autoplayStopOnLast) _this.swipeTo(0);
                    else {
                        clearInterval(autoplayIntervalId);
                        autoplayIntervalId = undefined;
                    }
                }
            }, params.autoplay);
        }
    };
    _this.stopAutoplay = function (internal) {
        if (_this.support.transitions) {
            if (!autoplayTimeoutId) return;
            if (autoplayTimeoutId) clearTimeout(autoplayTimeoutId);
            autoplayTimeoutId = undefined;
            if (internal && !params.autoplayDisableOnInteraction) {
                _this.wrapperTransitionEnd(function () {
                    autoplay();
                });
            }
            _this.callPlugins('onAutoplayStop');
            if (params.onAutoplayStop) _this.fireCallback(params.onAutoplayStop, _this);
        }
        else {
            if (autoplayIntervalId) clearInterval(autoplayIntervalId);
            autoplayIntervalId = undefined;
            _this.callPlugins('onAutoplayStop');
            if (params.onAutoplayStop) _this.fireCallback(params.onAutoplayStop, _this);
        }
    };
    function autoplay() {
        autoplayTimeoutId = setTimeout(function () {
            if (params.loop) {
                _this.fixLoop();
                _this.swipeNext(true);
            }
            else if (!_this.swipeNext(true)) {
                if (!params.autoplayStopOnLast) _this.swipeTo(0);
                else {
                    clearTimeout(autoplayTimeoutId);
                    autoplayTimeoutId = undefined;
                }
            }
            _this.wrapperTransitionEnd(function () {
                if (typeof autoplayTimeoutId !== 'undefined') autoplay();
            });
        }, params.autoplay);
    }
    /*==================================================
        Loop
    ====================================================*/
    _this.loopCreated = false;
    _this.removeLoopedSlides = function () {
        if (_this.loopCreated) {
            for (var i = 0; i < _this.slides.length; i++) {
                if (_this.slides[i].getData('looped') === true) _this.wrapper.removeChild(_this.slides[i]);
            }
        }
    };

    _this.createLoop = function () {
        if (_this.slides.length === 0) return;
        if (params.slidesPerView === 'auto') {
            _this.loopedSlides = params.loopedSlides || 1;
        }
        else {
            _this.loopedSlides = params.slidesPerView + params.loopAdditionalSlides;
        }

        if (_this.loopedSlides > _this.slides.length) {
            _this.loopedSlides = _this.slides.length;
        }

        var slideFirstHTML = '',
            slideLastHTML = '',
            i;
        var slidesSetFullHTML = '';
        /**
                loopedSlides is too large if loopAdditionalSlides are set.
                Need to divide the slides by maximum number of slides existing.

                @author        Tomaz Lovrec <tomaz.lovrec@blanc-noir.at>
        */
        var numSlides = _this.slides.length;
        var fullSlideSets = Math.floor(_this.loopedSlides / numSlides);
        var remainderSlides = _this.loopedSlides % numSlides;
        // assemble full sets of slides
        for (i = 0; i < (fullSlideSets * numSlides); i++) {
            var j = i;
            if (i >= numSlides) {
                var over = Math.floor(i / numSlides);
                j = i - (numSlides * over);
            }
            slidesSetFullHTML += _this.slides[j].outerHTML;
        }
        // assemble remainder slides
        // assemble remainder appended to existing slides
        for (i = 0; i < remainderSlides;i++) {
            slideLastHTML += addClassToHtmlString(params.slideDuplicateClass, _this.slides[i].outerHTML);
        }
        // assemble slides that get preppended to existing slides
        for (i = numSlides - remainderSlides; i < numSlides;i++) {
            slideFirstHTML += addClassToHtmlString(params.slideDuplicateClass, _this.slides[i].outerHTML);
        }
        // assemble all slides
        var slides = slideFirstHTML + slidesSetFullHTML + wrapper.innerHTML + slidesSetFullHTML + slideLastHTML;
        // set the slides
        wrapper.innerHTML = slides;

        _this.loopCreated = true;
        _this.calcSlides();

        //Update Looped Slides with special class
        for (i = 0; i < _this.slides.length; i++) {
            if (i < _this.loopedSlides || i >= _this.slides.length - _this.loopedSlides) _this.slides[i].setData('looped', true);
        }
        _this.callPlugins('onCreateLoop');

    };

    _this.fixLoop = function () {
        var newIndex;
        //Fix For Negative Oversliding
        if (_this.activeIndex < _this.loopedSlides) {
            newIndex = _this.slides.length - _this.loopedSlides * 3 + _this.activeIndex;
            _this.swipeTo(newIndex, 0, false);
        }
        //Fix For Positive Oversliding
        else if ((params.slidesPerView === 'auto' && _this.activeIndex >= _this.loopedSlides * 2) || (_this.activeIndex > _this.slides.length - params.slidesPerView * 2)) {
            newIndex = -_this.slides.length + _this.activeIndex + _this.loopedSlides;
            _this.swipeTo(newIndex, 0, false);
        }
    };

    /*==================================================
        Slides Loader
    ====================================================*/
    _this.loadSlides = function () {
        var slidesHTML = '';
        _this.activeLoaderIndex = 0;
        var slides = params.loader.slides;
        var slidesToLoad = params.loader.loadAllSlides ? slides.length : params.slidesPerView * (1 + params.loader.surroundGroups);
        for (var i = 0; i < slidesToLoad; i++) {
            if (params.loader.slidesHTMLType === 'outer') slidesHTML += slides[i];
            else {
                slidesHTML += '<' + params.slideElement + ' class="' + params.slideClass + '" data-swiperindex="' + i + '">' + slides[i] + '</' + params.slideElement + '>';
            }
        }
        _this.wrapper.innerHTML = slidesHTML;
        _this.calcSlides(true);
        //Add permanent transitionEnd callback
        if (!params.loader.loadAllSlides) {
            _this.wrapperTransitionEnd(_this.reloadSlides, true);
        }
    };

    _this.reloadSlides = function () {
        var slides = params.loader.slides;
        var newActiveIndex = parseInt(_this.activeSlide().data('swiperindex'), 10);
        if (newActiveIndex < 0 || newActiveIndex > slides.length - 1) return; //<-- Exit
        _this.activeLoaderIndex = newActiveIndex;
        var firstIndex = Math.max(0, newActiveIndex - params.slidesPerView * params.loader.surroundGroups);
        var lastIndex = Math.min(newActiveIndex + params.slidesPerView * (1 + params.loader.surroundGroups) - 1, slides.length - 1);
        //Update Transforms
        if (newActiveIndex > 0) {
            var newTransform = -slideSize * (newActiveIndex - firstIndex);
            _this.setWrapperTranslate(newTransform);
            _this.setWrapperTransition(0);
        }
        var i; // loop index
        //New Slides
        if (params.loader.logic === 'reload') {
            _this.wrapper.innerHTML = '';
            var slidesHTML = '';
            for (i = firstIndex; i <= lastIndex; i++) {
                slidesHTML += params.loader.slidesHTMLType === 'outer' ? slides[i] : '<' + params.slideElement + ' class="' + params.slideClass + '" data-swiperindex="' + i + '">' + slides[i] + '</' + params.slideElement + '>';
            }
            _this.wrapper.innerHTML = slidesHTML;
        }
        else {
            var minExistIndex = 1000;
            var maxExistIndex = 0;

            for (i = 0; i < _this.slides.length; i++) {
                var index = _this.slides[i].data('swiperindex');
                if (index < firstIndex || index > lastIndex) {
                    _this.wrapper.removeChild(_this.slides[i]);
                }
                else {
                    minExistIndex = Math.min(index, minExistIndex);
                    maxExistIndex = Math.max(index, maxExistIndex);
                }
            }
            for (i = firstIndex; i <= lastIndex; i++) {
                var newSlide;
                if (i < minExistIndex) {
                    newSlide = document.createElement(params.slideElement);
                    newSlide.className = params.slideClass;
                    newSlide.setAttribute('data-swiperindex', i);
                    newSlide.innerHTML = slides[i];
                    _this.wrapper.insertBefore(newSlide, _this.wrapper.firstChild);
                }
                if (i > maxExistIndex) {
                    newSlide = document.createElement(params.slideElement);
                    newSlide.className = params.slideClass;
                    newSlide.setAttribute('data-swiperindex', i);
                    newSlide.innerHTML = slides[i];
                    _this.wrapper.appendChild(newSlide);
                }
            }
        }
        //reInit
        _this.reInit(true);
    };

    /*==================================================
        Make Swiper
    ====================================================*/
    function makeSwiper() {
        _this.calcSlides();
        if (params.loader.slides.length > 0 && _this.slides.length === 0) {
            _this.loadSlides();
        }
        if (params.loop) {
            _this.createLoop();
        }
        _this.init();
        initEvents();
        if (params.pagination) {
            _this.createPagination(true);
        }

        if (params.loop || params.initialSlide > 0) {
            _this.swipeTo(params.initialSlide, 0, false);
        }
        else {
            _this.updateActiveSlide(0);
        }
        if (params.autoplay) {
            _this.startAutoplay();
        }
        /**
         * Set center slide index.
         *
         * @author        Tomaz Lovrec <tomaz.lovrec@gmail.com>
         */
        _this.centerIndex = _this.activeIndex;

        // Callbacks
        if (params.onSwiperCreated) _this.fireCallback(params.onSwiperCreated, _this);
        _this.callPlugins('onSwiperCreated');
    }

    makeSwiper();
};

Swiper.prototype = {
    plugins : {},

    /*==================================================
        Wrapper Operations
    ====================================================*/
    wrapperTransitionEnd : function (callback, permanent) {
        'use strict';
        var a = this,
            el = a.wrapper,
            events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
            i;

        function fireCallBack() {
            callback(a);
            if (a.params.queueEndCallbacks) a._queueEndCallbacks = false;
            if (!permanent) {
                for (i = 0; i < events.length; i++) {
                    a.h.removeEventListener(el, events[i], fireCallBack);
                }
            }
        }

        if (callback) {
            for (i = 0; i < events.length; i++) {
                a.h.addEventListener(el, events[i], fireCallBack);
            }
        }
    },

    getWrapperTranslate : function (axis) {
        'use strict';
        var el = this.wrapper,
            matrix, curTransform, curStyle, transformMatrix;

        // automatic axis detection
        if (typeof axis === 'undefined') {
            axis = this.params.mode === 'horizontal' ? 'x' : 'y';
        }

        if (this.support.transforms && this.params.useCSS3Transforms) {
            curStyle = window.getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                // Some old versions of Webkit choke when 'none' is passed; pass
                // empty string instead in this case
                transformMatrix = new WebKitCSSMatrix(curStyle.webkitTransform === 'none' ? '' : curStyle.webkitTransform);
            }
            else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform  || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }

            if (axis === 'x') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m41;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[12]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m42;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[13]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[5]);
            }
        }
        else {
            if (axis === 'x') curTransform = parseFloat(el.style.left, 10) || 0;
            if (axis === 'y') curTransform = parseFloat(el.style.top, 10) || 0;
        }
        return curTransform || 0;
    },

    setWrapperTranslate : function (x, y, z) {
        'use strict';
        var es = this.wrapper.style,
            coords = {x: 0, y: 0, z: 0},
            translate;

        // passed all coordinates
        if (arguments.length === 3) {
            coords.x = x;
            coords.y = y;
            coords.z = z;
        }

        // passed one coordinate and optional axis
        else {
            if (typeof y === 'undefined') {
                y = this.params.mode === 'horizontal' ? 'x' : 'y';
            }
            coords[y] = x;
        }

        if (this.support.transforms && this.params.useCSS3Transforms) {
            translate = this.support.transforms3d ? 'translate3d(' + coords.x + 'px, ' + coords.y + 'px, ' + coords.z + 'px)' : 'translate(' + coords.x + 'px, ' + coords.y + 'px)';
            es.webkitTransform = es.MsTransform = es.msTransform = es.MozTransform = es.OTransform = es.transform = translate;
        }
        else {
            es.left = coords.x + 'px';
            es.top  = coords.y + 'px';
        }
        this.callPlugins('onSetWrapperTransform', coords);
        if (this.params.onSetWrapperTransform) this.fireCallback(this.params.onSetWrapperTransform, this, coords);
    },

    setWrapperTransition : function (duration) {
        'use strict';
        var es = this.wrapper.style;
        es.webkitTransitionDuration = es.MsTransitionDuration = es.msTransitionDuration = es.MozTransitionDuration = es.OTransitionDuration = es.transitionDuration = (duration / 1000) + 's';
        this.callPlugins('onSetWrapperTransition', {duration: duration});
        if (this.params.onSetWrapperTransition) this.fireCallback(this.params.onSetWrapperTransition, this, duration);

    },

    /*==================================================
        Helpers
    ====================================================*/
    h : {
        getWidth: function (el, outer, round) {
            'use strict';
            var width = window.getComputedStyle(el, null).getPropertyValue('width');
            var returnWidth = parseFloat(width);
            //IE Fixes
            if (isNaN(returnWidth) || width.indexOf('%') > 0) {
                returnWidth = el.offsetWidth - parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-left')) - parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-right'));
            }
            if (outer) returnWidth += parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-left')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-right'));
            if (round) return Math.round(returnWidth);
            else return returnWidth;
        },
        getHeight: function (el, outer, round) {
            'use strict';
            if (outer) return el.offsetHeight;

            var height = window.getComputedStyle(el, null).getPropertyValue('height');
            var returnHeight = parseFloat(height);
            //IE Fixes
            if (isNaN(returnHeight) || height.indexOf('%') > 0) {
                returnHeight = el.offsetHeight - parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-top')) - parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-bottom'));
            }
            if (outer) returnHeight += parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue('padding-bottom'));
            if (round) return Math.round(returnHeight);
            else return returnHeight;
        },
        getOffset: function (el) {
            'use strict';
            var box = el.getBoundingClientRect();
            var body = document.body;
            var clientTop  = el.clientTop  || body.clientTop  || 0;
            var clientLeft = el.clientLeft || body.clientLeft || 0;
            var scrollTop  = window.pageYOffset || el.scrollTop;
            var scrollLeft = window.pageXOffset || el.scrollLeft;
            if (document.documentElement && !window.pageYOffset) {
                //IE7-8
                scrollTop  = document.documentElement.scrollTop;
                scrollLeft = document.documentElement.scrollLeft;
            }
            return {
                top: box.top  + scrollTop  - clientTop,
                left: box.left + scrollLeft - clientLeft
            };
        },
        windowWidth : function () {
            'use strict';
            if (window.innerWidth) return window.innerWidth;
            else if (document.documentElement && document.documentElement.clientWidth) return document.documentElement.clientWidth;
        },
        windowHeight : function () {
            'use strict';
            if (window.innerHeight) return window.innerHeight;
            else if (document.documentElement && document.documentElement.clientHeight) return document.documentElement.clientHeight;
        },
        windowScroll : function () {
            'use strict';
            if (typeof pageYOffset !== 'undefined') {
                return {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                };
            }
            else if (document.documentElement) {
                return {
                    left: document.documentElement.scrollLeft,
                    top: document.documentElement.scrollTop
                };
            }
        },

        addEventListener : function (el, event, listener, useCapture) {
            'use strict';
            if (typeof useCapture === 'undefined') {
                useCapture = false;
            }

            if (el.addEventListener) {
                el.addEventListener(event, listener, useCapture);
            }
            else if (el.attachEvent) {
                el.attachEvent('on' + event, listener);
            }
        },

        removeEventListener : function (el, event, listener, useCapture) {
            'use strict';
            if (typeof useCapture === 'undefined') {
                useCapture = false;
            }

            if (el.removeEventListener) {
                el.removeEventListener(event, listener, useCapture);
            }
            else if (el.detachEvent) {
                el.detachEvent('on' + event, listener);
            }
        }
    },
    setTransform : function (el, transform) {
        'use strict';
        var es = el.style;
        es.webkitTransform = es.MsTransform = es.msTransform = es.MozTransform = es.OTransform = es.transform = transform;
    },
    setTranslate : function (el, translate) {
        'use strict';
        var es = el.style;
        var pos = {
            x : translate.x || 0,
            y : translate.y || 0,
            z : translate.z || 0
        };
        var transformString = this.support.transforms3d ? 'translate3d(' + (pos.x) + 'px,' + (pos.y) + 'px,' + (pos.z) + 'px)' : 'translate(' + (pos.x) + 'px,' + (pos.y) + 'px)';
        es.webkitTransform = es.MsTransform = es.msTransform = es.MozTransform = es.OTransform = es.transform = transformString;
        if (!this.support.transforms) {
            es.left = pos.x + 'px';
            es.top = pos.y + 'px';
        }
    },
    setTransition : function (el, duration) {
        'use strict';
        var es = el.style;
        es.webkitTransitionDuration = es.MsTransitionDuration = es.msTransitionDuration = es.MozTransitionDuration = es.OTransitionDuration = es.transitionDuration = duration + 'ms';
    },
    /*==================================================
        Feature Detection
    ====================================================*/
    support: {

        touch : (window.Modernizr && Modernizr.touch === true) || (function () {
            'use strict';
            return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
        })(),

        transforms3d : (window.Modernizr && Modernizr.csstransforms3d === true) || (function () {
            'use strict';
            var div = document.createElement('div').style;
            return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
        })(),

        transforms : (window.Modernizr && Modernizr.csstransforms === true) || (function () {
            'use strict';
            var div = document.createElement('div').style;
            return ('transform' in div || 'WebkitTransform' in div || 'MozTransform' in div || 'msTransform' in div || 'MsTransform' in div || 'OTransform' in div);
        })(),

        transitions : (window.Modernizr && Modernizr.csstransitions === true) || (function () {
            'use strict';
            var div = document.createElement('div').style;
            return ('transition' in div || 'WebkitTransition' in div || 'MozTransition' in div || 'msTransition' in div || 'MsTransition' in div || 'OTransition' in div);
        })(),

        classList : (function () {
            'use strict';
            var div = document.createElement('div').style;
            return 'classList' in div;
        })()
    },

    browser : {

        ie8 : (function () {
            'use strict';
            var rv = -1; // Return value assumes failure.
            if (navigator.appName === 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent;
                var re = new RegExp(/MSIE ([0-9]{1,}[\.0-9]{0,})/);
                if (re.exec(ua) !== null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv !== -1 && rv < 9;
        })(),

        ie10 : window.navigator.msPointerEnabled,
        ie11 : window.navigator.pointerEnabled
    }
};

/*=========================
  jQuery & Zepto Plugins
  ===========================*/
if (window.jQuery || window.Zepto) {
    (function ($) {
        'use strict';
        $.fn.swiper = function (params) {
            var s = new Swiper($(this)[0], params);
            $(this).data('swiper', s);
            return s;
        };
    })(window.jQuery || window.Zepto);
}

// component
if (typeof(module) !== 'undefined')
{
    module.exports = Swiper;
}

// requirejs support
if (typeof define === 'function' && define.amd) {
    define([], function () {
        'use strict';
        return Swiper;
    });
}
;var App = (function() {

	var self = {}; // Create object for public vars and methods

  self.srcAttributes = "";

	self.isRetina = "devicePixelRatio" in window && window.devicePixelRatio === 2;
  self.isMobile = window.innerWidth <= 944;
	self.isSmallMobile = window.innerWidth <= 480;

	self.init = function() {
		setImages();
	};

	function setImages() {
    //set correct attributes
    if(self.isRetina){
      self.srcAttributes += "&retina=true";
    }

    if(self.isSmallMobile) {
      self.srcAttributes += "&mob=true";
    }

    //pick correct data-img
    if(self.isMobile){
			$('img[data-mobile-img]').each(function() {
				$(this).attr('src', $(this).attr('data-mobile-img') + self.srcAttributes);
			});
    } else {
			$('img[data-desktop-img]').each(function() {
				$(this).attr('src', $(this).attr('data-desktop-img') + self.srcAttributes);
			});
    }

	}

	return self; // Return all public vars and methods

})();

App.init();;// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url https://raw.githubusercontent.com/google/closure-compiler/master/contrib/externs/maps/google_maps_api_v3_16.js
// ==/ClosureCompiler==

/**
 * @name CSS3 InfoBubble with tabs for Google Maps API V3
 * @version 0.8
 * @author Luke Mahe
 * @fileoverview
 * This library is a CSS Infobubble with tabs. It uses css3 rounded corners and
 * drop shadows and animations. It also allows tabs
 */

/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A CSS3 InfoBubble v0.8
 * @param {Object.<string, *>=} opt_options Optional properties to set.
 * @extends {google.maps.OverlayView}
 * @constructor
 */
function InfoBubble(opt_options) {
  this.extend(InfoBubble, google.maps.OverlayView);
  this.tabs_ = [];
  this.activeTab_ = null;
  this.baseZIndex_ = 100;
  this.isOpen_ = false;

  var options = opt_options || {};

  if (options['backgroundColor'] == undefined) {
    options['backgroundColor'] = this.BACKGROUND_COLOR_;
  }

  if (options['borderColor'] == undefined) {
    options['borderColor'] = this.BORDER_COLOR_;
  }

  if (options['borderRadius'] == undefined) {
    options['borderRadius'] = this.BORDER_RADIUS_;
  }

  if (options['borderWidth'] == undefined) {
    options['borderWidth'] = this.BORDER_WIDTH_;
  }

  if (options['padding'] == undefined) {
    options['padding'] = this.PADDING_;
  }

  if (options['arrowPosition'] == undefined) {
    options['arrowPosition'] = this.ARROW_POSITION_;
  }

  if (options['disableAutoPan'] == undefined) {
    options['disableAutoPan'] = false;
  }

  if (options['disableAnimation'] == undefined) {
    options['disableAnimation'] = false;
  }

  if (options['minWidth'] == undefined) {
    options['minWidth'] = this.MIN_WIDTH_;
  }

  if (options['shadowStyle'] == undefined) {
    options['shadowStyle'] = this.SHADOW_STYLE_;
  }

  if (options['arrowSize'] == undefined) {
    options['arrowSize'] = this.ARROW_SIZE_;
  }

  if (options['arrowStyle'] == undefined) {
    options['arrowStyle'] = this.ARROW_STYLE_;
  }

  if (options['closeSrc'] == undefined) {
    options['closeSrc'] = this.CLOSE_SRC_;
  }

  this.buildDom_();
  this.setValues(options);
}
window['InfoBubble'] = InfoBubble;


/**
 * Default arrow size
 * @const
 * @private
 */
InfoBubble.prototype.ARROW_SIZE_ = 15;


/**
 * Default arrow style
 * @const
 * @private
 */
InfoBubble.prototype.ARROW_STYLE_ = 0;


/**
 * Default shadow style
 * @const
 * @private
 */
InfoBubble.prototype.SHADOW_STYLE_ = 1;


/**
 * Default min width
 * @const
 * @private
 */
InfoBubble.prototype.MIN_WIDTH_ = 50;


/**
 * Default arrow position
 * @const
 * @private
 */
InfoBubble.prototype.ARROW_POSITION_ = 50;


/**
 * Default padding
 * @const
 * @private
 */
InfoBubble.prototype.PADDING_ = 10;


/**
 * Default border width
 * @const
 * @private
 */
InfoBubble.prototype.BORDER_WIDTH_ = 1;


/**
 * Default border color
 * @const
 * @private
 */
InfoBubble.prototype.BORDER_COLOR_ = '#ccc';


/**
 * Default border radius
 * @const
 * @private
 */
InfoBubble.prototype.BORDER_RADIUS_ = 10;


/**
 * Default background color
 * @const
 * @private
 */
InfoBubble.prototype.BACKGROUND_COLOR_ = '#fff';

/**
 * Default close image source
 * @const
 * @private
 */
InfoBubble.prototype.CLOSE_SRC_ = 'https://maps.gstatic.com/intl/en_us/mapfiles/iw_close.gif';

/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
InfoBubble.prototype.extend = function(obj1, obj2) {
  return (function(object) {
    for (var property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * Builds the InfoBubble dom
 * @private
 */
InfoBubble.prototype.buildDom_ = function() {
  var bubble = this.bubble_ = document.createElement('DIV');
  bubble.style['position'] = 'absolute';
  bubble.style['zIndex'] = this.baseZIndex_;

  var tabsContainer = this.tabsContainer_ = document.createElement('DIV');
  tabsContainer.style['position'] = 'relative';

  // Close button
  var close = this.close_ = document.createElement('IMG');
  close.style['position'] = 'absolute';
  close.style['border'] = 0;
  close.style['zIndex'] = this.baseZIndex_ + 1;
  close.style['cursor'] = 'pointer';
  close.src = this.get('closeSrc');

  var that = this;
  google.maps.event.addDomListener(close, 'click', function() {
    that.close();
    google.maps.event.trigger(that, 'closeclick');
  });

  // Content area
  var contentContainer = this.contentContainer_ = document.createElement('DIV');
  contentContainer.style['overflowX'] = 'auto';
  contentContainer.style['overflowY'] = 'auto';
  contentContainer.style['cursor'] = 'default';
  contentContainer.style['clear'] = 'both';
  contentContainer.style['position'] = 'relative';

  var content = this.content_ = document.createElement('DIV');
  contentContainer.appendChild(content);

  // Arrow
  var arrow = this.arrow_ = document.createElement('DIV');
  arrow.style['position'] = 'relative';

  var arrowOuter = this.arrowOuter_ = document.createElement('DIV');
  var arrowInner = this.arrowInner_ = document.createElement('DIV');

  var arrowSize = this.getArrowSize_();

  arrowOuter.style['position'] = arrowInner.style['position'] = 'absolute';
  arrowOuter.style['left'] = arrowInner.style['left'] = '50%';
  arrowOuter.style['height'] = arrowInner.style['height'] = '0';
  arrowOuter.style['width'] = arrowInner.style['width'] = '0';
  arrowOuter.style['marginLeft'] = this.px(-arrowSize);
  arrowOuter.style['borderWidth'] = this.px(arrowSize);
  arrowOuter.style['borderBottomWidth'] = 0;

  // Shadow
  var bubbleShadow = this.bubbleShadow_ = document.createElement('DIV');
  bubbleShadow.style['position'] = 'absolute';

  // Hide the InfoBubble by default
  bubble.style['display'] = bubbleShadow.style['display'] = 'none';

  bubble.appendChild(this.tabsContainer_);
  bubble.appendChild(close);
  bubble.appendChild(contentContainer);
  arrow.appendChild(arrowOuter);
  arrow.appendChild(arrowInner);
  bubble.appendChild(arrow);

  var stylesheet = document.createElement('style');
  stylesheet.setAttribute('type', 'text/css');

  /**
   * The animation for the infobubble
   * @type {string}
   */
  this.animationName_ = '_ibani_' + Math.round(Math.random() * 10000);

  var css = '.' + this.animationName_ + '{-webkit-animation-name:' +
      this.animationName_ + ';-webkit-animation-duration:0.5s;' +
      '-webkit-animation-iteration-count:1;}' +
      '@-webkit-keyframes ' + this.animationName_ + ' {from {' +
      '-webkit-transform: scale(0)}50% {-webkit-transform: scale(1.2)}90% ' +
      '{-webkit-transform: scale(0.95)}to {-webkit-transform: scale(1)}}';

  stylesheet.textContent = css;
  document.getElementsByTagName('head')[0].appendChild(stylesheet);
};


/**
 * Sets the background class name
 *
 * @param {string} className The class name to set.
 */
InfoBubble.prototype.setBackgroundClassName = function(className) {
  this.set('backgroundClassName', className);
};
InfoBubble.prototype['setBackgroundClassName'] = InfoBubble.prototype.setBackgroundClassName;


/**
 * changed MVC callback
 */
InfoBubble.prototype.backgroundClassName_changed = function() {
  this.content_.className = this.get('backgroundClassName');
};
InfoBubble.prototype['backgroundClassName_changed'] = InfoBubble.prototype.backgroundClassName_changed;


/**
 * Sets the class of the tab
 *
 * @param {string} className the class name to set.
 */
InfoBubble.prototype.setTabClassName = function(className) {
  this.set('tabClassName', className);
};
InfoBubble.prototype['setTabClassName'] = InfoBubble.prototype.setTabClassName;


/**
 * tabClassName changed MVC callback
 */
InfoBubble.prototype.tabClassName_changed = function() {
  this.updateTabStyles_();
};
InfoBubble.prototype['tabClassName_changed'] = InfoBubble.prototype.tabClassName_changed;


/**
 * Gets the style of the arrow
 *
 * @private
 * @return {number} The style of the arrow.
 */
InfoBubble.prototype.getArrowStyle_ = function() {
  return parseInt(this.get('arrowStyle'), 10) || 0;
};


/**
 * Sets the style of the arrow
 *
 * @param {number} style The style of the arrow.
 */
InfoBubble.prototype.setArrowStyle = function(style) {
  this.set('arrowStyle', style);
};
InfoBubble.prototype['setArrowStyle'] = InfoBubble.prototype.setArrowStyle;


/**
 * Arrow style changed MVC callback
 */
InfoBubble.prototype.arrowStyle_changed = function() {
  this.arrowSize_changed();
};
InfoBubble.prototype['arrowStyle_changed'] = InfoBubble.prototype.arrowStyle_changed;


/**
 * Gets the size of the arrow
 *
 * @private
 * @return {number} The size of the arrow.
 */
InfoBubble.prototype.getArrowSize_ = function() {
  return parseInt(this.get('arrowSize'), 10) || 0;
};


/**
 * Sets the size of the arrow
 *
 * @param {number} size The size of the arrow.
 */
InfoBubble.prototype.setArrowSize = function(size) {
  this.set('arrowSize', size);
};
InfoBubble.prototype['setArrowSize'] = InfoBubble.prototype.setArrowSize;


/**
 * Arrow size changed MVC callback
 */
InfoBubble.prototype.arrowSize_changed = function() {
  this.borderWidth_changed();
};
InfoBubble.prototype['arrowSize_changed'] = InfoBubble.prototype.arrowSize_changed;


/**
 * Set the position of the InfoBubble arrow
 *
 * @param {number} pos The position to set.
 */
InfoBubble.prototype.setArrowPosition = function(pos) {
  this.set('arrowPosition', pos);
};
InfoBubble.prototype['setArrowPosition'] = InfoBubble.prototype.setArrowPosition;


/**
 * Get the position of the InfoBubble arrow
 *
 * @private
 * @return {number} The position..
 */
InfoBubble.prototype.getArrowPosition_ = function() {
  return parseInt(this.get('arrowPosition'), 10) || 0;
};


/**
 * arrowPosition changed MVC callback
 */
InfoBubble.prototype.arrowPosition_changed = function() {
  var pos = this.getArrowPosition_();
  this.arrowOuter_.style['left'] = this.arrowInner_.style['left'] = pos + '%';

  this.redraw_();
};
InfoBubble.prototype['arrowPosition_changed'] = InfoBubble.prototype.arrowPosition_changed;


/**
 * Set the zIndex of the InfoBubble
 *
 * @param {number} zIndex The zIndex to set.
 */
InfoBubble.prototype.setZIndex = function(zIndex) {
  this.set('zIndex', zIndex);
};
InfoBubble.prototype['setZIndex'] = InfoBubble.prototype.setZIndex;


/**
 * Get the zIndex of the InfoBubble
 *
 * @return {number} The zIndex to set.
 */
InfoBubble.prototype.getZIndex = function() {
  return parseInt(this.get('zIndex'), 10) || this.baseZIndex_;
};


/**
 * zIndex changed MVC callback
 */
InfoBubble.prototype.zIndex_changed = function() {
  var zIndex = this.getZIndex();

  this.bubble_.style['zIndex'] = this.baseZIndex_ = zIndex;
  this.close_.style['zIndex'] = zIndex + 1;
};
InfoBubble.prototype['zIndex_changed'] = InfoBubble.prototype.zIndex_changed;


/**
 * Set the style of the shadow
 *
 * @param {number} shadowStyle The style of the shadow.
 */
InfoBubble.prototype.setShadowStyle = function(shadowStyle) {
  this.set('shadowStyle', shadowStyle);
};
InfoBubble.prototype['setShadowStyle'] = InfoBubble.prototype.setShadowStyle;


/**
 * Get the style of the shadow
 *
 * @private
 * @return {number} The style of the shadow.
 */
InfoBubble.prototype.getShadowStyle_ = function() {
  return parseInt(this.get('shadowStyle'), 10) || 0;
};


/**
 * shadowStyle changed MVC callback
 */
InfoBubble.prototype.shadowStyle_changed = function() {
  var shadowStyle = this.getShadowStyle_();

  var display = '';
  var shadow = '';
  var backgroundColor = '';
  switch (shadowStyle) {
    case 0:
      display = 'none';
      break;
    case 1:
      shadow = '40px 15px 10px rgba(33,33,33,0.3)';
      backgroundColor = 'transparent';
      break;
    case 2:
      shadow = '0 0 2px rgba(33,33,33,0.3)';
      backgroundColor = 'rgba(33,33,33,0.35)';
      break;
  }
  this.bubbleShadow_.style['boxShadow'] =
      this.bubbleShadow_.style['webkitBoxShadow'] =
      this.bubbleShadow_.style['MozBoxShadow'] = shadow;
  this.bubbleShadow_.style['backgroundColor'] = backgroundColor;
  if (this.isOpen_) {
    this.bubbleShadow_.style['display'] = display;
    this.draw();
  }
};
InfoBubble.prototype['shadowStyle_changed'] = InfoBubble.prototype.shadowStyle_changed;


/**
 * Show the close button
 */
InfoBubble.prototype.showCloseButton = function() {
  this.set('hideCloseButton', false);
};
InfoBubble.prototype['showCloseButton'] = InfoBubble.prototype.showCloseButton;


/**
 * Hide the close button
 */
InfoBubble.prototype.hideCloseButton = function() {
  this.set('hideCloseButton', true);
};
InfoBubble.prototype['hideCloseButton'] = InfoBubble.prototype.hideCloseButton;


/**
 * hideCloseButton changed MVC callback
 */
InfoBubble.prototype.hideCloseButton_changed = function() {
  this.close_.style['display'] = this.get('hideCloseButton') ? 'none' : '';
};
InfoBubble.prototype['hideCloseButton_changed'] = InfoBubble.prototype.hideCloseButton_changed;


/**
 * Set the background color
 *
 * @param {string} color The color to set.
 */
InfoBubble.prototype.setBackgroundColor = function(color) {
  if (color) {
    this.set('backgroundColor', color);
  }
};
InfoBubble.prototype['setBackgroundColor'] = InfoBubble.prototype.setBackgroundColor;


/**
 * backgroundColor changed MVC callback
 */
InfoBubble.prototype.backgroundColor_changed = function() {
  var backgroundColor = this.get('backgroundColor');
  this.contentContainer_.style['backgroundColor'] = backgroundColor;

  this.arrowInner_.style['borderColor'] = backgroundColor +
      ' transparent transparent';
  this.updateTabStyles_();
};
InfoBubble.prototype['backgroundColor_changed'] = InfoBubble.prototype.backgroundColor_changed;


/**
 * Set the border color
 *
 * @param {string} color The border color.
 */
InfoBubble.prototype.setBorderColor = function(color) {
  if (color) {
    this.set('borderColor', color);
  }
};
InfoBubble.prototype['setBorderColor'] = InfoBubble.prototype.setBorderColor;


/**
 * borderColor changed MVC callback
 */
InfoBubble.prototype.borderColor_changed = function() {
  var borderColor = this.get('borderColor');

  var contentContainer = this.contentContainer_;
  var arrowOuter = this.arrowOuter_;
  contentContainer.style['borderColor'] = borderColor;

  arrowOuter.style['borderColor'] = borderColor +
      ' transparent transparent';

  contentContainer.style['borderStyle'] =
      arrowOuter.style['borderStyle'] =
      this.arrowInner_.style['borderStyle'] = 'solid';

  this.updateTabStyles_();
};
InfoBubble.prototype['borderColor_changed'] = InfoBubble.prototype.borderColor_changed;


/**
 * Set the radius of the border
 *
 * @param {number} radius The radius of the border.
 */
InfoBubble.prototype.setBorderRadius = function(radius) {
  this.set('borderRadius', radius);
};
InfoBubble.prototype['setBorderRadius'] = InfoBubble.prototype.setBorderRadius;


/**
 * Get the radius of the border
 *
 * @private
 * @return {number} The radius of the border.
 */
InfoBubble.prototype.getBorderRadius_ = function() {
  return parseInt(this.get('borderRadius'), 10) || 0;
};


/**
 * borderRadius changed MVC callback
 */
InfoBubble.prototype.borderRadius_changed = function() {
  var borderRadius = this.getBorderRadius_();
  var borderWidth = this.getBorderWidth_();

  this.contentContainer_.style['borderRadius'] =
      this.contentContainer_.style['MozBorderRadius'] =
      this.contentContainer_.style['webkitBorderRadius'] =
      this.bubbleShadow_.style['borderRadius'] =
      this.bubbleShadow_.style['MozBorderRadius'] =
      this.bubbleShadow_.style['webkitBorderRadius'] = this.px(borderRadius);

  this.tabsContainer_.style['paddingLeft'] =
      this.tabsContainer_.style['paddingRight'] =
      this.px(borderRadius + borderWidth);

  this.redraw_();
};
InfoBubble.prototype['borderRadius_changed'] = InfoBubble.prototype.borderRadius_changed;


/**
 * Get the width of the border
 *
 * @private
 * @return {number} width The width of the border.
 */
InfoBubble.prototype.getBorderWidth_ = function() {
  return parseInt(this.get('borderWidth'), 10) || 0;
};


/**
 * Set the width of the border
 *
 * @param {number} width The width of the border.
 */
InfoBubble.prototype.setBorderWidth = function(width) {
  this.set('borderWidth', width);
};
InfoBubble.prototype['setBorderWidth'] = InfoBubble.prototype.setBorderWidth;


/**
 * borderWidth change MVC callback
 */
InfoBubble.prototype.borderWidth_changed = function() {
  var borderWidth = this.getBorderWidth_();

  this.contentContainer_.style['borderWidth'] = this.px(borderWidth);
  this.tabsContainer_.style['top'] = this.px(borderWidth);

  this.updateArrowStyle_();
  this.updateTabStyles_();
  this.borderRadius_changed();
  this.redraw_();
};
InfoBubble.prototype['borderWidth_changed'] = InfoBubble.prototype.borderWidth_changed;


/**
 * Update the arrow style
 * @private
 */
InfoBubble.prototype.updateArrowStyle_ = function() {
  var borderWidth = this.getBorderWidth_();
  var arrowSize = this.getArrowSize_();
  var arrowStyle = this.getArrowStyle_();
  var arrowOuterSizePx = this.px(arrowSize);
  var arrowInnerSizePx = this.px(Math.max(0, arrowSize - borderWidth));

  var outer = this.arrowOuter_;
  var inner = this.arrowInner_;

  this.arrow_.style['marginTop'] = this.px(-borderWidth);
  outer.style['borderTopWidth'] = arrowOuterSizePx;
  inner.style['borderTopWidth'] = arrowInnerSizePx;

  // Full arrow or arrow pointing to the left
  if (arrowStyle == 0 || arrowStyle == 1) {
    outer.style['borderLeftWidth'] = arrowOuterSizePx;
    inner.style['borderLeftWidth'] = arrowInnerSizePx;
  } else {
    outer.style['borderLeftWidth'] = inner.style['borderLeftWidth'] = 0;
  }

  // Full arrow or arrow pointing to the right
  if (arrowStyle == 0 || arrowStyle == 2) {
    outer.style['borderRightWidth'] = arrowOuterSizePx;
    inner.style['borderRightWidth'] = arrowInnerSizePx;
  } else {
    outer.style['borderRightWidth'] = inner.style['borderRightWidth'] = 0;
  }

  if (arrowStyle < 2) {
    outer.style['marginLeft'] = this.px(-(arrowSize));
    inner.style['marginLeft'] = this.px(-(arrowSize - borderWidth));
  } else {
    outer.style['marginLeft'] = inner.style['marginLeft'] = 0;
  }

  // If there is no border then don't show thw outer arrow
  if (borderWidth == 0) {
    outer.style['display'] = 'none';
  } else {
    outer.style['display'] = '';
  }
};


/**
 * Set the padding of the InfoBubble
 *
 * @param {number} padding The padding to apply.
 */
InfoBubble.prototype.setPadding = function(padding) {
  this.set('padding', padding);
};
InfoBubble.prototype['setPadding'] = InfoBubble.prototype.setPadding;


/**
 * Set the close image url
 *
 * @param {string} src The url of the image used as a close icon
 */
InfoBubble.prototype.setCloseSrc = function(src) {
  if (src && this.close_) {
    this.close_.src = src;
  }
};
InfoBubble.prototype['setCloseSrc'] = InfoBubble.prototype.setCloseSrc;


/**
 * Set the padding of the InfoBubble
 *
 * @private
 * @return {number} padding The padding to apply.
 */
InfoBubble.prototype.getPadding_ = function() {
  return parseInt(this.get('padding'), 10) || 0;
};


/**
 * padding changed MVC callback
 */
InfoBubble.prototype.padding_changed = function() {
  var padding = this.getPadding_();
  this.contentContainer_.style['padding'] = this.px(padding);
  this.updateTabStyles_();

  this.redraw_();
};
InfoBubble.prototype['padding_changed'] = InfoBubble.prototype.padding_changed;


/**
 * Add px extention to the number
 *
 * @param {number} num The number to wrap.
 * @return {string|number} A wrapped number.
 */
InfoBubble.prototype.px = function(num) {
  if (num) {
    // 0 doesn't need to be wrapped
    return num + 'px';
  }
  return num;
};


/**
 * Add events to stop propagation
 * @private
 */
InfoBubble.prototype.addEvents_ = function() {
  // We want to cancel all the events so they do not go to the map
  var events = ['mousedown', 'mousemove', 'mouseover', 'mouseout', 'mouseup',
      'mousewheel', 'DOMMouseScroll', 'touchstart', 'touchend', 'touchmove',
      'dblclick', 'contextmenu', 'click'];

  var bubble = this.bubble_;
  this.listeners_ = [];
  for (var i = 0, event; event = events[i]; i++) {
    this.listeners_.push(
      google.maps.event.addDomListener(bubble, event, function(e) {
        e.cancelBubble = true;
        if (e.stopPropagation) {
          e.stopPropagation();
        }
      })
    );
  }
};


/**
 * On Adding the InfoBubble to a map
 * Implementing the OverlayView interface
 */
InfoBubble.prototype.onAdd = function() {
  if (!this.bubble_) {
    this.buildDom_();
  }

  this.addEvents_();

  var panes = this.getPanes();
  if (panes) {
    panes.floatPane.appendChild(this.bubble_);
    panes.floatShadow.appendChild(this.bubbleShadow_);
  }

  /* once the infoBubble has been added to the DOM, fire 'domready' event */
  google.maps.event.trigger(this, 'domready');
};
InfoBubble.prototype['onAdd'] = InfoBubble.prototype.onAdd;


/**
 * Draw the InfoBubble
 * Implementing the OverlayView interface
 */
InfoBubble.prototype.draw = function() {
  var projection = this.getProjection();

  if (!projection) {
    // The map projection is not ready yet so do nothing
    return;
  }

  var latLng = /** @type {google.maps.LatLng} */ (this.get('position'));

  if (!latLng) {
    this.close();
    return;
  }

  var tabHeight = 0;

  if (this.activeTab_) {
    tabHeight = this.activeTab_.offsetHeight;
  }

  var anchorHeight = this.getAnchorHeight_();
  var arrowSize = this.getArrowSize_();
  var arrowPosition = this.getArrowPosition_();

  arrowPosition = arrowPosition / 100;

  var pos = projection.fromLatLngToDivPixel(latLng);
  var width = this.contentContainer_.offsetWidth;
  var height = this.bubble_.offsetHeight;

  if (!width) {
    return;
  }

  // Adjust for the height of the info bubble
  var top = pos.y - (height + arrowSize);

  if (anchorHeight) {
    // If there is an anchor then include the height
    top -= anchorHeight;
  }

  var left = pos.x - (width * arrowPosition);

  this.bubble_.style['top'] = this.px(top);
  this.bubble_.style['left'] = this.px(left);

  var shadowStyle = parseInt(this.get('shadowStyle'), 10);

  switch (shadowStyle) {
    case 1:
      // Shadow is behind
      this.bubbleShadow_.style['top'] = this.px(top + tabHeight - 1);
      this.bubbleShadow_.style['left'] = this.px(left);
      this.bubbleShadow_.style['width'] = this.px(width);
      this.bubbleShadow_.style['height'] =
          this.px(this.contentContainer_.offsetHeight - arrowSize);
      break;
    case 2:
      // Shadow is below
      width = width * 0.8;
      if (anchorHeight) {
        this.bubbleShadow_.style['top'] = this.px(pos.y);
      } else {
        this.bubbleShadow_.style['top'] = this.px(pos.y + arrowSize);
      }
      this.bubbleShadow_.style['left'] = this.px(pos.x - width * arrowPosition);

      this.bubbleShadow_.style['width'] = this.px(width);
      this.bubbleShadow_.style['height'] = this.px(2);
      break;
  }
};
InfoBubble.prototype['draw'] = InfoBubble.prototype.draw;


/**
 * Removing the InfoBubble from a map
 */
InfoBubble.prototype.onRemove = function() {
  if (this.bubble_ && this.bubble_.parentNode) {
    this.bubble_.parentNode.removeChild(this.bubble_);
  }
  if (this.bubbleShadow_ && this.bubbleShadow_.parentNode) {
    this.bubbleShadow_.parentNode.removeChild(this.bubbleShadow_);
  }

  for (var i = 0, listener; listener = this.listeners_[i]; i++) {
    google.maps.event.removeListener(listener);
  }
};
InfoBubble.prototype['onRemove'] = InfoBubble.prototype.onRemove;


/**
 * Is the InfoBubble open
 *
 * @return {boolean} If the InfoBubble is open.
 */
InfoBubble.prototype.isOpen = function() {
  return this.isOpen_;
};
InfoBubble.prototype['isOpen'] = InfoBubble.prototype.isOpen;


/**
 * Close the InfoBubble
 */
InfoBubble.prototype.close = function() {
  if (this.bubble_) {
    this.bubble_.style['display'] = 'none';
    // Remove the animation so we next time it opens it will animate again
    this.bubble_.className =
        this.bubble_.className.replace(this.animationName_, '');
  }

  if (this.bubbleShadow_) {
    this.bubbleShadow_.style['display'] = 'none';
    this.bubbleShadow_.className =
        this.bubbleShadow_.className.replace(this.animationName_, '');
  }
  this.isOpen_ = false;
};
InfoBubble.prototype['close'] = InfoBubble.prototype.close;


/**
 * Open the InfoBubble (asynchronous).
 *
 * @param {google.maps.Map=} opt_map Optional map to open on.
 * @param {google.maps.MVCObject=} opt_anchor Optional anchor to position at.
 */
InfoBubble.prototype.open = function(opt_map, opt_anchor) {
  var that = this;
  window.setTimeout(function() {
    that.open_(opt_map, opt_anchor);
  }, 0);
};


/**
 * Open the InfoBubble
 * @private
 * @param {google.maps.Map=} opt_map Optional map to open on.
 * @param {google.maps.MVCObject=} opt_anchor Optional anchor to position at.
 */
InfoBubble.prototype.open_ = function(opt_map, opt_anchor) {
  this.updateContent_();

  if (opt_map) {
    this.setMap(opt_map);
  }

  if (opt_anchor) {
    this.set('anchor', opt_anchor);
    this.bindTo('anchorPoint', opt_anchor);
    this.bindTo('position', opt_anchor);
  }

  // Show the bubble and the show
  this.bubble_.style['display'] = this.bubbleShadow_.style['display'] = '';
  var animation = !this.get('disableAnimation');

  if (animation) {
    // Add the animation
    this.bubble_.className += ' ' + this.animationName_;
    this.bubbleShadow_.className += ' ' + this.animationName_;
  }

  this.redraw_();
  this.isOpen_ = true;

  var pan = !this.get('disableAutoPan');
  if (pan) {
    var that = this;
    window.setTimeout(function() {
      // Pan into view, done in a time out to make it feel nicer :)
      that.panToView();
    }, 200);
  }
};
InfoBubble.prototype['open'] = InfoBubble.prototype.open;


/**
 * Set the position of the InfoBubble
 *
 * @param {google.maps.LatLng} position The position to set.
 */
InfoBubble.prototype.setPosition = function(position) {
  if (position) {
    this.set('position', position);
  }
};
InfoBubble.prototype['setPosition'] = InfoBubble.prototype.setPosition;


/**
 * Returns the position of the InfoBubble
 *
 * @return {google.maps.LatLng} the position.
 */
InfoBubble.prototype.getPosition = function() {
  return /** @type {google.maps.LatLng} */ (this.get('position'));
};
InfoBubble.prototype['getPosition'] = InfoBubble.prototype.getPosition;


/**
 * position changed MVC callback
 */
InfoBubble.prototype.position_changed = function() {
  this.draw();
};
InfoBubble.prototype['position_changed'] = InfoBubble.prototype.position_changed;


/**
 * Pan the InfoBubble into view
 */
InfoBubble.prototype.panToView = function() {
  var projection = this.getProjection();

  if (!projection) {
    // The map projection is not ready yet so do nothing
    return;
  }

  if (!this.bubble_) {
    // No Bubble yet so do nothing
    return;
  }

  var anchorHeight = this.getAnchorHeight_();
  var height = this.bubble_.offsetHeight + anchorHeight;
  var map = this.get('map');
  var mapDiv = map.getDiv();
  var mapHeight = mapDiv.offsetHeight;

  var latLng = this.getPosition();
  var centerPos = projection.fromLatLngToContainerPixel(map.getCenter());
  var pos = projection.fromLatLngToContainerPixel(latLng);

  // Find out how much space at the top is free
  var spaceTop = centerPos.y - height;

  // Fine out how much space at the bottom is free
  var spaceBottom = mapHeight - centerPos.y;

  var needsTop = spaceTop < 0;
  var deltaY = 0;

  if (needsTop) {
    spaceTop *= -1;
    deltaY = (spaceTop + spaceBottom) / 2;
  }

  pos.y -= deltaY;
  latLng = projection.fromContainerPixelToLatLng(pos);

  if (map.getCenter() != latLng) {
    map.panTo(latLng);
  }
};
InfoBubble.prototype['panToView'] = InfoBubble.prototype.panToView;


/**
 * Converts a HTML string to a document fragment.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {Node} A HTML document fragment.
 * @private
 */
InfoBubble.prototype.htmlToDocumentFragment_ = function(htmlString) {
  htmlString = htmlString.replace(/^\s*([\S\s]*)\b\s*$/, '$1');
  var tempDiv = document.createElement('DIV');
  tempDiv.innerHTML = htmlString;
  if (tempDiv.childNodes.length == 1) {
    return /** @type {!Node} */ (tempDiv.removeChild(tempDiv.firstChild));
  } else {
    var fragment = document.createDocumentFragment();
    while (tempDiv.firstChild) {
      fragment.appendChild(tempDiv.firstChild);
    }
    return fragment;
  }
};


/**
 * Removes all children from the node.
 *
 * @param {Node} node The node to remove all children from.
 * @private
 */
InfoBubble.prototype.removeChildren_ = function(node) {
  if (!node) {
    return;
  }

  var child;
  while (child = node.firstChild) {
    node.removeChild(child);
  }
};


/**
 * Sets the content of the infobubble.
 *
 * @param {string|Node} content The content to set.
 */
InfoBubble.prototype.setContent = function(content) {
  this.set('content', content);
};
InfoBubble.prototype['setContent'] = InfoBubble.prototype.setContent;


/**
 * Get the content of the infobubble.
 *
 * @return {string|Node} The marker content.
 */
InfoBubble.prototype.getContent = function() {
  return /** @type {Node|string} */ (this.get('content'));
};
InfoBubble.prototype['getContent'] = InfoBubble.prototype.getContent;


/**
 * Sets the marker content and adds loading events to images
 */
InfoBubble.prototype.updateContent_ = function() {
  if (!this.content_) {
    // The Content area doesnt exist.
    return;
  }

  this.removeChildren_(this.content_);
  var content = this.getContent();
  if (content) {
    if (typeof content == 'string') {
      content = this.htmlToDocumentFragment_(content);
    }
    this.content_.appendChild(content);

    var that = this;
    var images = this.content_.getElementsByTagName('IMG');
    for (var i = 0, image; image = images[i]; i++) {
      // Because we don't know the size of an image till it loads, add a
      // listener to the image load so the marker can resize and reposition
      // itself to be the correct height.
      google.maps.event.addDomListener(image, 'load', function() {
        that.imageLoaded_();
      });
    }
  }
  this.redraw_();
};


/**
 * Image loaded
 * @private
 */
InfoBubble.prototype.imageLoaded_ = function() {
  var pan = !this.get('disableAutoPan');
  this.redraw_();
  if (pan && (this.tabs_.length == 0 || this.activeTab_.index == 0)) {
    this.panToView();
  }
};


/**
 * Updates the styles of the tabs
 * @private
 */
InfoBubble.prototype.updateTabStyles_ = function() {
  if (this.tabs_ && this.tabs_.length) {
    for (var i = 0, tab; tab = this.tabs_[i]; i++) {
      this.setTabStyle_(tab.tab);
    }
    this.activeTab_.style['zIndex'] = this.baseZIndex_;
    var borderWidth = this.getBorderWidth_();
    var padding = this.getPadding_() / 2;
    this.activeTab_.style['borderBottomWidth'] = 0;
    this.activeTab_.style['paddingBottom'] = this.px(padding + borderWidth);
  }
};


/**
 * Sets the style of a tab
 * @private
 * @param {Element} tab The tab to style.
 */
InfoBubble.prototype.setTabStyle_ = function(tab) {
  var backgroundColor = this.get('backgroundColor');
  var borderColor = this.get('borderColor');
  var borderRadius = this.getBorderRadius_();
  var borderWidth = this.getBorderWidth_();
  var padding = this.getPadding_();

  var marginRight = this.px(-(Math.max(padding, borderRadius)));
  var borderRadiusPx = this.px(borderRadius);

  var index = this.baseZIndex_;
  if (tab.index) {
    index -= tab.index;
  }

  // The styles for the tab
  var styles = {
    'cssFloat': 'left',
    'position': 'relative',
    'cursor': 'pointer',
    'backgroundColor': backgroundColor,
    'border': this.px(borderWidth) + ' solid ' + borderColor,
    'padding': this.px(padding / 2) + ' ' + this.px(padding),
    'marginRight': marginRight,
    'whiteSpace': 'nowrap',
    'borderRadiusTopLeft': borderRadiusPx,
    'MozBorderRadiusTopleft': borderRadiusPx,
    'webkitBorderTopLeftRadius': borderRadiusPx,
    'borderRadiusTopRight': borderRadiusPx,
    'MozBorderRadiusTopright': borderRadiusPx,
    'webkitBorderTopRightRadius': borderRadiusPx,
    'zIndex': index,
    'display': 'inline'
  };

  for (var style in styles) {
    tab.style[style] = styles[style];
  }

  var className = this.get('tabClassName');
  if (className != undefined) {
    tab.className += ' ' + className;
  }
};


/**
 * Add user actions to a tab
 * @private
 * @param {Object} tab The tab to add the actions to.
 */
InfoBubble.prototype.addTabActions_ = function(tab) {
  var that = this;
  tab.listener_ = google.maps.event.addDomListener(tab, 'click', function() {
    that.setTabActive_(this);
  });
};


/**
 * Set a tab at a index to be active
 *
 * @param {number} index The index of the tab.
 */
InfoBubble.prototype.setTabActive = function(index) {
  var tab = this.tabs_[index - 1];

  if (tab) {
    this.setTabActive_(tab.tab);
  }
};
InfoBubble.prototype['setTabActive'] = InfoBubble.prototype.setTabActive;


/**
 * Set a tab to be active
 * @private
 * @param {Object} tab The tab to set active.
 */
InfoBubble.prototype.setTabActive_ = function(tab) {
  if (!tab) {
    this.setContent('');
    this.updateContent_();
    return;
  }

  var padding = this.getPadding_() / 2;
  var borderWidth = this.getBorderWidth_();

  if (this.activeTab_) {
    var activeTab = this.activeTab_;
    activeTab.style['zIndex'] = this.baseZIndex_ - activeTab.index;
    activeTab.style['paddingBottom'] = this.px(padding);
    activeTab.style['borderBottomWidth'] = this.px(borderWidth);
  }

  tab.style['zIndex'] = this.baseZIndex_;
  tab.style['borderBottomWidth'] = 0;
  tab.style['marginBottomWidth'] = '-10px';
  tab.style['paddingBottom'] = this.px(padding + borderWidth);

  this.setContent(this.tabs_[tab.index].content);
  this.updateContent_();

  this.activeTab_ = tab;

  this.redraw_();
};


/**
 * Set the max width of the InfoBubble
 *
 * @param {number} width The max width.
 */
InfoBubble.prototype.setMaxWidth = function(width) {
  this.set('maxWidth', width);
};
InfoBubble.prototype['setMaxWidth'] = InfoBubble.prototype.setMaxWidth;


/**
 * maxWidth changed MVC callback
 */
InfoBubble.prototype.maxWidth_changed = function() {
  this.redraw_();
};
InfoBubble.prototype['maxWidth_changed'] = InfoBubble.prototype.maxWidth_changed;


/**
 * Set the max height of the InfoBubble
 *
 * @param {number} height The max height.
 */
InfoBubble.prototype.setMaxHeight = function(height) {
  this.set('maxHeight', height);
};
InfoBubble.prototype['setMaxHeight'] = InfoBubble.prototype.setMaxHeight;


/**
 * maxHeight changed MVC callback
 */
InfoBubble.prototype.maxHeight_changed = function() {
  this.redraw_();
};
InfoBubble.prototype['maxHeight_changed'] = InfoBubble.prototype.maxHeight_changed;


/**
 * Set the min width of the InfoBubble
 *
 * @param {number} width The min width.
 */
InfoBubble.prototype.setMinWidth = function(width) {
  this.set('minWidth', width);
};
InfoBubble.prototype['setMinWidth'] = InfoBubble.prototype.setMinWidth;


/**
 * minWidth changed MVC callback
 */
InfoBubble.prototype.minWidth_changed = function() {
  this.redraw_();
};
InfoBubble.prototype['minWidth_changed'] = InfoBubble.prototype.minWidth_changed;


/**
 * Set the min height of the InfoBubble
 *
 * @param {number} height The min height.
 */
InfoBubble.prototype.setMinHeight = function(height) {
  this.set('minHeight', height);
};
InfoBubble.prototype['setMinHeight'] = InfoBubble.prototype.setMinHeight;


/**
 * minHeight changed MVC callback
 */
InfoBubble.prototype.minHeight_changed = function() {
  this.redraw_();
};
InfoBubble.prototype['minHeight_changed'] = InfoBubble.prototype.minHeight_changed;


/**
 * Add a tab
 *
 * @param {string} label The label of the tab.
 * @param {string|Element} content The content of the tab.
 */
InfoBubble.prototype.addTab = function(label, content) {
  var tab = document.createElement('DIV');
  tab.innerHTML = label;

  this.setTabStyle_(tab);
  this.addTabActions_(tab);

  this.tabsContainer_.appendChild(tab);

  this.tabs_.push({
    label: label,
    content: content,
    tab: tab
  });

  tab.index = this.tabs_.length - 1;
  tab.style['zIndex'] = this.baseZIndex_ - tab.index;

  if (!this.activeTab_) {
    this.setTabActive_(tab);
  }

  tab.className = tab.className + ' ' + this.animationName_;

  this.redraw_();
};
InfoBubble.prototype['addTab'] = InfoBubble.prototype.addTab;


/**
 * Update a tab at a speicifc index
 *
 * @param {number} index The index of the tab.
 * @param {?string} opt_label The label to change to.
 * @param {?string} opt_content The content to update to.
 */
InfoBubble.prototype.updateTab = function(index, opt_label, opt_content) {
  if (!this.tabs_.length || index < 0 || index >= this.tabs_.length) {
    return;
  }

  var tab = this.tabs_[index];
  if (opt_label != undefined) {
    tab.tab.innerHTML = tab.label = opt_label;
  }

  if (opt_content != undefined) {
    tab.content = opt_content;
  }

  if (this.activeTab_ == tab.tab) {
    this.setContent(tab.content);
    this.updateContent_();
  }
  this.redraw_();
};
InfoBubble.prototype['updateTab'] = InfoBubble.prototype.updateTab;


/**
 * Remove a tab at a specific index
 *
 * @param {number} index The index of the tab to remove.
 */
InfoBubble.prototype.removeTab = function(index) {
  if (!this.tabs_.length || index < 0 || index >= this.tabs_.length) {
    return;
  }

  var tab = this.tabs_[index];
  tab.tab.parentNode.removeChild(tab.tab);

  google.maps.event.removeListener(tab.tab.listener_);

  this.tabs_.splice(index, 1);

  delete tab;

  for (var i = 0, t; t = this.tabs_[i]; i++) {
    t.tab.index = i;
  }

  if (tab.tab == this.activeTab_) {
    // Removing the current active tab
    if (this.tabs_[index]) {
      // Show the tab to the right
      this.activeTab_ = this.tabs_[index].tab;
    } else if (this.tabs_[index - 1]) {
      // Show a tab to the left
      this.activeTab_ = this.tabs_[index - 1].tab;
    } else {
      // No tabs left to sho
      this.activeTab_ = undefined;
    }

    this.setTabActive_(this.activeTab_);
  }

  this.redraw_();
};
InfoBubble.prototype['removeTab'] = InfoBubble.prototype.removeTab;


/**
 * Get the size of an element
 * @private
 * @param {Node|string} element The element to size.
 * @param {number=} opt_maxWidth Optional max width of the element.
 * @param {number=} opt_maxHeight Optional max height of the element.
 * @return {google.maps.Size} The size of the element.
 */
InfoBubble.prototype.getElementSize_ = function(element, opt_maxWidth,
                                                opt_maxHeight) {
  var sizer = document.createElement('DIV');
  sizer.style['display'] = 'inline';
  sizer.style['position'] = 'absolute';
  sizer.style['visibility'] = 'hidden';

  if (typeof element == 'string') {
    sizer.innerHTML = element;
  } else {
    sizer.appendChild(element.cloneNode(true));
  }

  document.body.appendChild(sizer);
  var size = new google.maps.Size(sizer.offsetWidth, sizer.offsetHeight);

  // If the width is bigger than the max width then set the width and size again
  if (opt_maxWidth && size.width > opt_maxWidth) {
    sizer.style['width'] = this.px(opt_maxWidth);
    size = new google.maps.Size(sizer.offsetWidth, sizer.offsetHeight);
  }

  // If the height is bigger than the max height then set the height and size
  // again
  if (opt_maxHeight && size.height > opt_maxHeight) {
    sizer.style['height'] = this.px(opt_maxHeight);
    size = new google.maps.Size(sizer.offsetWidth, sizer.offsetHeight);
  }

  document.body.removeChild(sizer);
  delete sizer;
  return size;
};


/**
 * Redraw the InfoBubble
 * @private
 */
InfoBubble.prototype.redraw_ = function() {
  this.figureOutSize_();
  this.positionCloseButton_();
  this.draw();
};


/**
 * Figure out the optimum size of the InfoBubble
 * @private
 */
InfoBubble.prototype.figureOutSize_ = function() {
  var map = this.get('map');

  if (!map) {
    return;
  }

  var padding = this.getPadding_();
  var borderWidth = this.getBorderWidth_();
  var borderRadius = this.getBorderRadius_();
  var arrowSize = this.getArrowSize_();

  var mapDiv = map.getDiv();
  var gutter = arrowSize * 2;
  var mapWidth = mapDiv.offsetWidth - gutter;
  var mapHeight = mapDiv.offsetHeight - gutter - this.getAnchorHeight_();
  var tabHeight = 0;
  var width = /** @type {number} */ (this.get('minWidth') || 0);
  var height = /** @type {number} */ (this.get('minHeight') || 0);
  var maxWidth = /** @type {number} */ (this.get('maxWidth') || 0);
  var maxHeight = /** @type {number} */ (this.get('maxHeight') || 0);

  maxWidth = Math.min(mapWidth, maxWidth);
  maxHeight = Math.min(mapHeight, maxHeight);

  var tabWidth = 0;
  if (this.tabs_.length) {
    // If there are tabs then you need to check the size of each tab's content
    for (var i = 0, tab; tab = this.tabs_[i]; i++) {
      var tabSize = this.getElementSize_(tab.tab, maxWidth, maxHeight);
      var contentSize = this.getElementSize_(tab.content, maxWidth, maxHeight);

      if (width < tabSize.width) {
        width = tabSize.width;
      }

      // Add up all the tab widths because they might end up being wider than
      // the content
      tabWidth += tabSize.width;

      if (height < tabSize.height) {
        height = tabSize.height;
      }

      if (tabSize.height > tabHeight) {
        tabHeight = tabSize.height;
      }

      if (width < contentSize.width) {
        width = contentSize.width;
      }

      if (height < contentSize.height) {
        height = contentSize.height;
      }
    }
  } else {
    var content = /** @type {string|Node} */ (this.get('content'));
    if (typeof content == 'string') {
      content = this.htmlToDocumentFragment_(content);
    }
    if (content) {
      var contentSize = this.getElementSize_(content, maxWidth, maxHeight);

      if (width < contentSize.width) {
        width = contentSize.width;
      }

      if (height < contentSize.height) {
        height = contentSize.height;
      }
    }
  }

  if (maxWidth) {
    width = Math.min(width, maxWidth);
  }

  if (maxHeight) {
    height = Math.min(height, maxHeight);
  }

  width = Math.max(width, tabWidth);

  if (width == tabWidth) {
    width = width + 2 * padding;
  }

  arrowSize = arrowSize * 2;
  width = Math.max(width, arrowSize);

  // Maybe add this as a option so they can go bigger than the map if the user
  // wants
  if (width > mapWidth) {
    width = mapWidth;
  }

  if (height > mapHeight) {
    height = mapHeight - tabHeight;
  }

  if (this.tabsContainer_) {
    this.tabHeight_ = tabHeight;
    this.tabsContainer_.style['width'] = this.px(tabWidth);
  }

  this.contentContainer_.style['width'] = this.px(width);
  this.contentContainer_.style['height'] = this.px(height);
};


/**
 *  Get the height of the anchor
 *
 *  This function is a hack for now and doesn't really work that good, need to
 *  wait for pixelBounds to be correctly exposed.
 *  @private
 *  @return {number} The height of the anchor.
 */
InfoBubble.prototype.getAnchorHeight_ = function() {
  var anchor = this.get('anchor');
  if (anchor) {
    var anchorPoint = /** @type google.maps.Point */(this.get('anchorPoint'));

    if (anchorPoint) {
      return -1 * anchorPoint.y;
    }
  }
  return 0;
};

InfoBubble.prototype.anchorPoint_changed = function() {
  this.draw();
};
InfoBubble.prototype['anchorPoint_changed'] = InfoBubble.prototype.anchorPoint_changed;


/**
 * Position the close button in the right spot.
 * @private
 */
InfoBubble.prototype.positionCloseButton_ = function() {
  var br = this.getBorderRadius_();
  var bw = this.getBorderWidth_();

  var right = 10;
  var top = 10

  if (this.tabs_.length && this.tabHeight_) {
    top += this.tabHeight_;
  }

  top += bw;
  right += bw;

  var c = this.contentContainer_;
  if (c && c.clientHeight < c.scrollHeight) {
    // If there are scrollbars then move the cross in so it is not over
    // scrollbar
    right += 15;
  }

  this.close_.style['right'] = this.px(right);
  this.close_.style['top'] = this.px(top);
};
;/*global define:false require:false */
(function (name, context, definition) {
	if (typeof module != 'undefined' && module.exports) module.exports = definition();
	else if (typeof define == 'function' && define.amd) define(definition);
	else context[name] = definition();
})('jquery-scrollto', this, function(){
	// Prepare
	var jQuery, $, ScrollTo;
	jQuery = $ = window.jQuery || require('jquery');

	// Fix scrolling animations on html/body on safari
	$.propHooks.scrollTop = $.propHooks.scrollLeft = {
		get: function(elem,prop) {
			var result = null;
			if ( elem.tagName === 'HTML' || elem.tagName === 'BODY' ) {
				if ( prop === 'scrollLeft' ) {
					result = window.scrollX;
				} else if ( prop === 'scrollTop' ) {
					result = window.scrollY;
				}
			}
			if ( result == null ) {
				result = elem[prop];
			}
			return result;
		}
	};
	$.Tween.propHooks.scrollTop = $.Tween.propHooks.scrollLeft = {
		get: function(tween) {
			return $.propHooks.scrollTop.get(tween.elem, tween.prop);
		},
		set: function(tween) {
			// Our safari fix
			if ( tween.elem.tagName === 'HTML' || tween.elem.tagName === 'BODY' ) {
				// Defaults
				tween.options.bodyScrollLeft = (tween.options.bodyScrollLeft || window.scrollX);
				tween.options.bodyScrollTop = (tween.options.bodyScrollTop || window.scrollY);

				// Apply
				if ( tween.prop === 'scrollLeft' ) {
					tween.options.bodyScrollLeft = Math.round(tween.now);
				}
				else if ( tween.prop === 'scrollTop' ) {
					tween.options.bodyScrollTop = Math.round(tween.now);
				}

				// Apply
				window.scrollTo(tween.options.bodyScrollLeft, tween.options.bodyScrollTop);
			}
			// jQuery's IE8 Fix
			else if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	// jQuery ScrollTo
	ScrollTo = {
		// Configuration
		config: {
			duration: 400,
			easing: 'swing',
			callback: undefined,
			durationMode: 'each',
			offsetTop: 0,
			offsetLeft: 0
		},

		// Set Configuration
		configure: function(options){
			// Apply Options to Config
			$.extend(ScrollTo.config, options||{});

			// Chain
			return this;
		},

		// Perform the Scroll Animation for the Collections
		// We use $inline here, so we can determine the actual offset start for each overflow:scroll item
		// Each collection is for each overflow:scroll item
		scroll: function(collections, config){
			// Prepare
			var collection, $container, container, $target, $inline, position, containerTagName,
				containerScrollTop, containerScrollLeft,
				containerScrollTopEnd, containerScrollLeftEnd,
				startOffsetTop, targetOffsetTop, targetOffsetTopAdjusted,
				startOffsetLeft, targetOffsetLeft, targetOffsetLeftAdjusted,
				scrollOptions,
				callback;

			// Determine the Scroll
			collection = collections.pop();
			$container = collection.$container;
			$target = collection.$target;
			containerTagName = $container.prop('tagName');

			// Prepare the Inline Element of the Container
			$inline = $('<span/>').css({
				'position': 'absolute',
				'top': '0px',
				'left': '0px'
			});
			position = $container.css('position');

			// Insert the Inline Element of the Container
			$container.css({position:'relative'});
			$inline.appendTo($container);

			// Determine the top offset
			startOffsetTop = $inline.offset().top;
			targetOffsetTop = $target.offset().top;
			targetOffsetTopAdjusted = targetOffsetTop - startOffsetTop - parseInt(config.offsetTop,10);

			// Determine the left offset
			startOffsetLeft = $inline.offset().left;
			targetOffsetLeft = $target.offset().left;
			targetOffsetLeftAdjusted = targetOffsetLeft - startOffsetLeft - parseInt(config.offsetLeft,10);

			// Determine current scroll positions
			containerScrollTop = $container.prop('scrollTop');
			containerScrollLeft = $container.prop('scrollLeft');

			// Reset the Inline Element of the Container
			$inline.remove();
			$container.css({position:position});

			// Prepare the scroll options
			scrollOptions = {};

			// Prepare the callback
			callback = function(event){
				// Check
				if ( collections.length === 0 ) {
					// Callback
					if ( typeof config.callback === 'function' ) {
						config.callback();
					}
				}
				else {
					// Recurse
					ScrollTo.scroll(collections,config);
				}
				// Return true
				return true;
			};

			// Handle if we only want to scroll if we are outside the viewport
			if ( config.onlyIfOutside ) {
				// Determine current scroll positions
				containerScrollTopEnd = containerScrollTop + $container.height();
				containerScrollLeftEnd = containerScrollLeft + $container.width();

				// Check if we are in the range of the visible area of the container
				if ( containerScrollTop < targetOffsetTopAdjusted && targetOffsetTopAdjusted < containerScrollTopEnd ) {
					targetOffsetTopAdjusted = containerScrollTop;
				}
				if ( containerScrollLeft < targetOffsetLeftAdjusted && targetOffsetLeftAdjusted < containerScrollLeftEnd ) {
					targetOffsetLeftAdjusted = containerScrollLeft;
				}
			}

			// Determine the scroll options
			if ( targetOffsetTopAdjusted !== containerScrollTop ) {
				scrollOptions.scrollTop = targetOffsetTopAdjusted;
			}
			if ( targetOffsetLeftAdjusted !== containerScrollLeft ) {
				scrollOptions.scrollLeft = targetOffsetLeftAdjusted;
			}

			// Check to see if the scroll is necessary
			if ( $container.prop('scrollHeight') === $container.width() ) {
				delete scrollOptions.scrollTop;
			}
			if ( $container.prop('scrollWidth') === $container.width() ) {
				delete scrollOptions.scrollLeft;
			}

			// Perform the scroll
			if ( scrollOptions.scrollTop != null || scrollOptions.scrollLeft != null ) {
				$container.animate(scrollOptions, {
					duration: config.duration,
					easing: config.easing,
					complete: callback
				});
			}
			else {
				callback();
			}

			// Return true
			return true;
		},

		// ScrollTo the Element using the Options
		fn: function(options){
			// Prepare
			var collections, config, $container, container;
			collections = [];

			// Prepare
			var	$target = $(this);
			if ( $target.length === 0 ) {
				// Chain
				return this;
			}

			// Handle Options
			config = $.extend({},ScrollTo.config,options);

			// Fetch
			$container = $target.parent();
			container = $container.get(0);

			// Cycle through the containers
			while ( ($container.length === 1) && (container !== document.body) && (container !== document) ) {
				// Check Container for scroll differences
				var containerScrollTop, containerScrollLeft;
				containerScrollTop = $container.css('overflow-y') !== 'visible' && container.scrollHeight !== container.clientHeight;
				containerScrollLeft =  $container.css('overflow-x') !== 'visible' && container.scrollWidth !== container.clientWidth;
				if ( containerScrollTop || containerScrollLeft ) {
					// Push the Collection
					collections.push({
						'$container': $container,
						'$target': $target
					});
					// Update the Target
					$target = $container;
				}
				// Update the Container
				$container = $container.parent();
				container = $container.get(0);
			}

			// Add the final collection
			collections.push({
				'$container': $('html'),
				// document.body doesn't work in firefox, html works for all
				// internet explorer starts at the beggining
				'$target': $target
			});

			// Adjust the Config
			if ( config.durationMode === 'all' ) {
				config.duration /= collections.length;
			}

			// Handle
			ScrollTo.scroll(collections,config);

			// Chain
			return this;
		}
	};

	// Apply our extensions to jQuery
	$.ScrollTo = $.ScrollTo || ScrollTo;
	$.fn.ScrollTo = $.fn.ScrollTo || ScrollTo.fn;

	// Export
	return ScrollTo;
});;/*! jQuery UI - v1.10.4 - 2014-06-05
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.position.js, jquery.ui.autocomplete.js, jquery.ui.menu.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

(function(e,t){function i(t,i){var s,a,o,r=t.nodeName.toLowerCase();return"area"===r?(s=t.parentNode,a=s.name,t.href&&a&&"map"===s.nodeName.toLowerCase()?(o=e("img[usemap=#"+a+"]")[0],!!o&&n(o)):!1):(/input|select|textarea|button|object/.test(r)?!t.disabled:"a"===r?t.href||i:i)&&n(t)}function n(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var s=0,a=/^ui-id-\d+$/;e.ui=e.ui||{},e.extend(e.ui,{version:"1.10.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({focus:function(t){return function(i,n){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),n&&n.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var n,s,a=e(this[0]);a.length&&a[0]!==document;){if(n=a.css("position"),("absolute"===n||"relative"===n||"fixed"===n)&&(s=parseInt(a.css("zIndex"),10),!isNaN(s)&&0!==s))return s;a=a.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++s)})},removeUniqueId:function(){return this.each(function(){a.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,n){return!!e.data(t,n[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var n=e.attr(t,"tabindex"),s=isNaN(n);return(s||n>=0)&&i(t,!s)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,n){function s(t,i,n,s){return e.each(a,function(){i-=parseFloat(e.css(t,"padding"+this))||0,n&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),s&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var a="Width"===n?["Left","Right"]:["Top","Bottom"],o=n.toLowerCase(),r={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+n]=function(i){return i===t?r["inner"+n].call(this):this.each(function(){e(this).css(o,s(this,i)+"px")})},e.fn["outer"+n]=function(t,i){return"number"!=typeof t?r["outer"+n].call(this,t):this.each(function(){e(this).css(o,s(this,t,!0,i)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.support.selectstart="onselectstart"in document.createElement("div"),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,n){var s,a=e.ui[t].prototype;for(s in n)a.plugins[s]=a.plugins[s]||[],a.plugins[s].push([i,n[s]])},call:function(e,t,i){var n,s=e.plugins[t];if(s&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(n=0;s.length>n;n++)e.options[s[n][0]]&&s[n][1].apply(e.element,i)}},hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var n=i&&"left"===i?"scrollLeft":"scrollTop",s=!1;return t[n]>0?!0:(t[n]=1,s=t[n]>0,t[n]=0,s)}})})(jQuery);(function(t,e){var i=0,s=Array.prototype.slice,n=t.cleanData;t.cleanData=function(e){for(var i,s=0;null!=(i=e[s]);s++)try{t(i).triggerHandler("remove")}catch(o){}n(e)},t.widget=function(i,s,n){var o,a,r,h,l={},c=i.split(".")[0];i=i.split(".")[1],o=c+"-"+i,n||(n=s,s=t.Widget),t.expr[":"][o.toLowerCase()]=function(e){return!!t.data(e,o)},t[c]=t[c]||{},a=t[c][i],r=t[c][i]=function(t,i){return this._createWidget?(arguments.length&&this._createWidget(t,i),e):new r(t,i)},t.extend(r,a,{version:n.version,_proto:t.extend({},n),_childConstructors:[]}),h=new s,h.options=t.widget.extend({},h.options),t.each(n,function(i,n){return t.isFunction(n)?(l[i]=function(){var t=function(){return s.prototype[i].apply(this,arguments)},e=function(t){return s.prototype[i].apply(this,t)};return function(){var i,s=this._super,o=this._superApply;return this._super=t,this._superApply=e,i=n.apply(this,arguments),this._super=s,this._superApply=o,i}}(),e):(l[i]=n,e)}),r.prototype=t.widget.extend(h,{widgetEventPrefix:a?h.widgetEventPrefix||i:i},l,{constructor:r,namespace:c,widgetName:i,widgetFullName:o}),a?(t.each(a._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,r,i._proto)}),delete a._childConstructors):s._childConstructors.push(r),t.widget.bridge(i,r)},t.widget.extend=function(i){for(var n,o,a=s.call(arguments,1),r=0,h=a.length;h>r;r++)for(n in a[r])o=a[r][n],a[r].hasOwnProperty(n)&&o!==e&&(i[n]=t.isPlainObject(o)?t.isPlainObject(i[n])?t.widget.extend({},i[n],o):t.widget.extend({},o):o);return i},t.widget.bridge=function(i,n){var o=n.prototype.widgetFullName||i;t.fn[i]=function(a){var r="string"==typeof a,h=s.call(arguments,1),l=this;return a=!r&&h.length?t.widget.extend.apply(null,[a].concat(h)):a,r?this.each(function(){var s,n=t.data(this,o);return n?t.isFunction(n[a])&&"_"!==a.charAt(0)?(s=n[a].apply(n,h),s!==n&&s!==e?(l=s&&s.jquery?l.pushStack(s.get()):s,!1):e):t.error("no such method '"+a+"' for "+i+" widget instance"):t.error("cannot call methods on "+i+" prior to initialization; "+"attempted to call method '"+a+"'")}):this.each(function(){var e=t.data(this,o);e?e.option(a||{})._init():t.data(this,o,new n(a,this))}),l}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(e,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this.bindings=t(),this.hoverable=t(),this.focusable=t(),s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:t.noop,_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(t.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:t.noop,widget:function(){return this.element},option:function(i,s){var n,o,a,r=i;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof i)if(r={},n=i.split("."),i=n.shift(),n.length){for(o=r[i]=t.widget.extend({},this.options[i]),a=0;n.length-1>a;a++)o[n[a]]=o[n[a]]||{},o=o[n[a]];if(i=n.pop(),1===arguments.length)return o[i]===e?null:o[i];o[i]=s}else{if(1===arguments.length)return this.options[i]===e?null:this.options[i];r[i]=s}return this._setOptions(r),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return this.options[t]=e,"disabled"===t&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!e).attr("aria-disabled",e),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(i,s,n){var o,a=this;"boolean"!=typeof i&&(n=s,s=i,i=!1),n?(s=o=t(s),this.bindings=this.bindings.add(s)):(n=s,s=this.element,o=this.widget()),t.each(n,function(n,r){function h(){return i||a.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof r?a[r]:r).apply(a,arguments):e}"string"!=typeof r&&(h.guid=r.guid=r.guid||h.guid||t.guid++);var l=n.match(/^(\w+)\s*(.*)$/),c=l[1]+a.eventNamespace,u=l[2];u?o.delegate(u,c,h):s.bind(c,h)})},_off:function(t,e){e=(e||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(e).undelegate(e)},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){t(e.currentTarget).addClass("ui-state-hover")},mouseleave:function(e){t(e.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){t(e.currentTarget).addClass("ui-state-focus")},focusout:function(e){t(e.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}})})(jQuery);(function(t,e){function i(t,e,i){return[parseFloat(t[0])*(p.test(t[0])?e/100:1),parseFloat(t[1])*(p.test(t[1])?i/100:1)]}function s(e,i){return parseInt(t.css(e,i),10)||0}function n(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}t.ui=t.ui||{};var a,o=Math.max,r=Math.abs,l=Math.round,h=/left|center|right/,c=/top|center|bottom/,u=/[\+\-]\d+(\.[\d]+)?%?/,d=/^\w+/,p=/%$/,f=t.fn.position;t.position={scrollbarWidth:function(){if(a!==e)return a;var i,s,n=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=n.children()[0];return t("body").append(n),i=o.offsetWidth,n.css("overflow","scroll"),s=o.offsetWidth,i===s&&(s=n[0].clientWidth),n.remove(),a=i-s},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,a="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:a?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:n,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s?i.width():i.outerWidth(),height:s?i.height():i.outerHeight()}}},t.fn.position=function(e){if(!e||!e.of)return f.apply(this,arguments);e=t.extend({},e);var a,p,g,m,v,_,b=t(e.of),y=t.position.getWithinInfo(e.within),k=t.position.getScrollInfo(y),w=(e.collision||"flip").split(" "),D={};return _=n(b),b[0].preventDefault&&(e.at="left top"),p=_.width,g=_.height,m=_.offset,v=t.extend({},m),t.each(["my","at"],function(){var t,i,s=(e[this]||"").split(" ");1===s.length&&(s=h.test(s[0])?s.concat(["center"]):c.test(s[0])?["center"].concat(s):["center","center"]),s[0]=h.test(s[0])?s[0]:"center",s[1]=c.test(s[1])?s[1]:"center",t=u.exec(s[0]),i=u.exec(s[1]),D[this]=[t?t[0]:0,i?i[0]:0],e[this]=[d.exec(s[0])[0],d.exec(s[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===e.at[0]?v.left+=p:"center"===e.at[0]&&(v.left+=p/2),"bottom"===e.at[1]?v.top+=g:"center"===e.at[1]&&(v.top+=g/2),a=i(D.at,p,g),v.left+=a[0],v.top+=a[1],this.each(function(){var n,h,c=t(this),u=c.outerWidth(),d=c.outerHeight(),f=s(this,"marginLeft"),_=s(this,"marginTop"),x=u+f+s(this,"marginRight")+k.width,C=d+_+s(this,"marginBottom")+k.height,M=t.extend({},v),T=i(D.my,c.outerWidth(),c.outerHeight());"right"===e.my[0]?M.left-=u:"center"===e.my[0]&&(M.left-=u/2),"bottom"===e.my[1]?M.top-=d:"center"===e.my[1]&&(M.top-=d/2),M.left+=T[0],M.top+=T[1],t.support.offsetFractions||(M.left=l(M.left),M.top=l(M.top)),n={marginLeft:f,marginTop:_},t.each(["left","top"],function(i,s){t.ui.position[w[i]]&&t.ui.position[w[i]][s](M,{targetWidth:p,targetHeight:g,elemWidth:u,elemHeight:d,collisionPosition:n,collisionWidth:x,collisionHeight:C,offset:[a[0]+T[0],a[1]+T[1]],my:e.my,at:e.at,within:y,elem:c})}),e.using&&(h=function(t){var i=m.left-M.left,s=i+p-u,n=m.top-M.top,a=n+g-d,l={target:{element:b,left:m.left,top:m.top,width:p,height:g},element:{element:c,left:M.left,top:M.top,width:u,height:d},horizontal:0>s?"left":i>0?"right":"center",vertical:0>a?"top":n>0?"bottom":"middle"};u>p&&p>r(i+s)&&(l.horizontal="center"),d>g&&g>r(n+a)&&(l.vertical="middle"),l.important=o(r(i),r(s))>o(r(n),r(a))?"horizontal":"vertical",e.using.call(this,t,l)}),c.offset(t.extend(M,{using:h}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,l=n-r,h=r+e.collisionWidth-a-n;e.collisionWidth>a?l>0&&0>=h?(i=t.left+l+e.collisionWidth-a-n,t.left+=l-i):t.left=h>0&&0>=l?n:l>h?n+a-e.collisionWidth:n:l>0?t.left+=l:h>0?t.left-=h:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,l=n-r,h=r+e.collisionHeight-a-n;e.collisionHeight>a?l>0&&0>=h?(i=t.top+l+e.collisionHeight-a-n,t.top+=l-i):t.top=h>0&&0>=l?n:l>h?n+a-e.collisionHeight:n:l>0?t.top+=l:h>0?t.top-=h:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,a=n.offset.left+n.scrollLeft,o=n.width,l=n.isWindow?n.scrollLeft:n.offset.left,h=t.left-e.collisionPosition.marginLeft,c=h-l,u=h+e.collisionWidth-o-l,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-o-a,(0>i||r(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-l,(s>0||u>r(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,a=n.offset.top+n.scrollTop,o=n.height,l=n.isWindow?n.scrollTop:n.offset.top,h=t.top-e.collisionPosition.marginTop,c=h-l,u=h+e.collisionHeight-o-l,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-o-a,t.top+p+f+g>c&&(0>s||r(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-l,t.top+p+f+g>u&&(i>0||u>r(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}},function(){var e,i,s,n,a,o=document.getElementsByTagName("body")[0],r=document.createElement("div");e=document.createElement(o?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},o&&t.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(a in s)e.style[a]=s[a];e.appendChild(r),i=o||document.documentElement,i.insertBefore(e,i.firstChild),r.style.cssText="position: absolute; left: 10.7432222px;",n=t(r).offset().left,t.support.offsetFractions=n>10&&11>n,e.innerHTML="",i.removeChild(e)}()})(jQuery);(function(e){e.widget("ui.autocomplete",{version:"1.10.4",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var t,i,s,n=this.element[0].nodeName.toLowerCase(),a="textarea"===n,o="input"===n;this.isMultiLine=a?!0:o?!1:this.element.prop("isContentEditable"),this.valueMethod=this.element[a||o?"val":"text"],this.isNewMenu=!0,this.element.addClass("ui-autocomplete-input").attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return t=!0,s=!0,i=!0,undefined;t=!1,s=!1,i=!1;var a=e.ui.keyCode;switch(n.keyCode){case a.PAGE_UP:t=!0,this._move("previousPage",n);break;case a.PAGE_DOWN:t=!0,this._move("nextPage",n);break;case a.UP:t=!0,this._keyEvent("previous",n);break;case a.DOWN:t=!0,this._keyEvent("next",n);break;case a.ENTER:case a.NUMPAD_ENTER:this.menu.active&&(t=!0,n.preventDefault(),this.menu.select(n));break;case a.TAB:this.menu.active&&this.menu.select(n);break;case a.ESCAPE:this.menu.element.is(":visible")&&(this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(t)return t=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),undefined;if(!i){var n=e.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(e){return s?(s=!1,e.preventDefault(),undefined):(this._searchTimeout(e),undefined)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,undefined):(clearTimeout(this.searching),this.close(e),this._change(e),undefined)}}),this._initSource(),this.menu=e("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role:null}).hide().data("ui-menu"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur});var i=this.menu.element[0];e(t.target).closest(".ui-menu-item").length||this._delay(function(){var t=this;this.document.one("mousedown",function(s){s.target===t.element[0]||s.target===i||e.contains(i,s.target)||t.close()})})},menufocus:function(t,i){if(this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type)))return this.menu.blur(),this.document.one("mousemove",function(){e(t.target).trigger(t.originalEvent)}),undefined;var s=i.item.data("ui-autocomplete-item");!1!==this._trigger("focus",t,{item:s})?t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(s.value):this.liveRegion.text(s.value)},menuselect:function(e,t){var i=t.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!==this.document[0].activeElement&&(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger("select",e,{item:i})&&this._value(i.value),this.term=this._value(),this.close(e),this.selectedItem=i}}),this.liveRegion=e("<span>",{role:"status","aria-live":"polite"}).addClass("ui-helper-hidden-accessible").insertBefore(this.element),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(e,t){this._super(e,t),"source"===e&&this._initSource(),"appendTo"===e&&this.menu.element.appendTo(this._appendTo()),"disabled"===e&&t&&this.xhr&&this.xhr.abort()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_initSource:function(){var t,i,s=this;e.isArray(this.options.source)?(t=this.options.source,this.source=function(i,s){s(e.ui.autocomplete.filter(t,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(t,n){s.xhr&&s.xhr.abort(),s.xhr=e.ajax({url:i,data:t,dataType:"json",success:function(e){n(e)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(e){clearTimeout(this.searching),this.searching=this._delay(function(){this.term!==this._value()&&(this.selectedItem=null,this.search(null,e))},this.options.delay)},search:function(e,t){return e=null!=e?e:this._value(),this.term=this._value(),e.length<this.options.minLength?this.close(t):this._trigger("search",t)!==!1?this._search(e):undefined},_search:function(e){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:e},this._response())},_response:function(){var t=++this.requestIndex;return e.proxy(function(e){t===this.requestIndex&&this.__response(e),this.pending--,this.pending||this.element.removeClass("ui-autocomplete-loading")},this)},__response:function(e){e&&(e=this._normalize(e)),this._trigger("response",null,{content:e}),!this.options.disabled&&e&&e.length&&!this.cancelSearch?(this._suggest(e),this._trigger("open")):this._close()},close:function(e){this.cancelSearch=!0,this._close(e)},_close:function(e){this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",e))},_change:function(e){this.previous!==this._value()&&this._trigger("change",e,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:e.map(t,function(t){return"string"==typeof t?{label:t,value:t}:e.extend({label:t.label||t.value,value:t.value||t.label},t)})},_suggest:function(t){var i=this.menu.element.empty();this._renderMenu(i,t),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(e.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next()},_resizeMenu:function(){var e=this.menu.element;e.outerWidth(Math.max(e.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(t,i){var s=this;e.each(i,function(e,i){s._renderItemData(t,i)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-autocomplete-item",t)},_renderItem:function(t,i){return e("<li>").append(e("<a>").text(i.label)).appendTo(t)},_move:function(e,t){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(e)||this.menu.isLastItem()&&/^next/.test(e)?(this._value(this.term),this.menu.blur(),undefined):(this.menu[e](t),undefined):(this.search(null,t),undefined)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(e,t){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(e,t),t.preventDefault())}}),e.extend(e.ui.autocomplete,{escapeRegex:function(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,i){var s=RegExp(e.ui.autocomplete.escapeRegex(i),"i");return e.grep(t,function(e){return s.test(e.label||e.value||e)})}}),e.widget("ui.autocomplete",e.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(e){return e+(e>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var t;this._superApply(arguments),this.options.disabled||this.cancelSearch||(t=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.text(t))}})})(jQuery);(function(t){t.widget("ui.menu",{version:"1.10.4",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-carat-1-e"},menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length).attr({role:this.options.role,tabIndex:0}).bind("click"+this.eventNamespace,t.proxy(function(t){this.options.disabled&&t.preventDefault()},this)),this.options.disabled&&this.element.addClass("ui-state-disabled").attr("aria-disabled","true"),this._on({"mousedown .ui-menu-item > a":function(t){t.preventDefault()},"click .ui-state-disabled > a":function(t){t.preventDefault()},"click .ui-menu-item:has(a)":function(e){var i=t(e.target).closest(".ui-menu-item");!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&t(this.document[0].activeElement).closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){var i=t(e.currentTarget);i.siblings().children(".ui-state-active").removeClass("ui-state-active"),this.focus(e,i)},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.children(".ui-menu-item").eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){t.contains(this.element[0],this.document[0].activeElement)||this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(e){t(e.target).closest(".ui-menu").length||this.collapseAll(e),this.mouseHandled=!1}})},_destroy:function(){this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(),this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function(){var e=t(this);e.data("ui-menu-submenu-carat")&&e.remove()}),this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")},_keydown:function(e){function i(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}var s,n,a,o,r,l=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:l=!1,n=this.previousFilter||"",a=String.fromCharCode(e.keyCode),o=!1,clearTimeout(this.filterTimer),a===n?o=!0:a=n+a,r=RegExp("^"+i(a),"i"),s=this.activeMenu.children(".ui-menu-item").filter(function(){return r.test(t(this).children("a").text())}),s=o&&-1!==s.index(this.active.next())?this.active.nextAll(".ui-menu-item"):s,s.length||(a=String.fromCharCode(e.keyCode),r=RegExp("^"+i(a),"i"),s=this.activeMenu.children(".ui-menu-item").filter(function(){return r.test(t(this).children("a").text())})),s.length?(this.focus(e,s),s.length>1?(this.previousFilter=a,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter):delete this.previousFilter}l&&e.preventDefault()},_activate:function(t){this.active.is(".ui-state-disabled")||(this.active.children("a[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i=this.options.icons.submenu,s=this.element.find(this.options.menus);this.element.toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length),s.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),s=e.prev("a"),n=t("<span>").addClass("ui-menu-icon ui-icon "+i).data("ui-menu-submenu-carat",!0);s.attr("aria-haspopup","true").prepend(n),e.attr("aria-labelledby",s.attr("id"))}),e=s.add(this.element),e.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","presentation").children("a").uniqueId().addClass("ui-corner-all").attr({tabIndex:-1,role:this._itemRole()}),e.children(":not(.ui-menu-item)").each(function(){var e=t(this);/[^\-\u2014\u2013\s]/.test(e.text())||e.addClass("ui-widget-content ui-menu-divider")}),e.children(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){"icons"===t&&this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(e.submenu),this._super(t,e)},focus:function(t,e){var i,s;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children("a").addClass("ui-state-focus"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,a,o,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,a=this.activeMenu.scrollTop(),o=this.activeMenu.height(),r=e.height(),0>n?this.activeMenu.scrollTop(a+n):n+r>o&&this.activeMenu.scrollTop(a+n-o+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this.active.children("a").removeClass("ui-state-focus"),this.active=null,this._trigger("blur",t,{item:this.active}))},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false").end().find("a.ui-state-active").removeClass("ui-state-active")},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").children(".ui-menu-item").first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.children(".ui-menu-item")[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.children(".ui-menu-item")[this.active?"last":"first"]())),undefined):(this.next(e),undefined)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.children(".ui-menu-item").first())),undefined):(this.next(e),undefined)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)}})})(jQuery);;/*
 * Backstretch
 * http://srobbin.com/jquery-plugins/backstretch/
 *
 * Copyright (c) 2013 Scott Robbin
 * Licensed under the MIT license.
 */

;(function ($, window, undefined) {
  'use strict';

  /* PLUGIN DEFINITION
   * ========================= */

  $.fn.backstretch = function (images, options) {
    // We need at least one image or method name
    if (images === undefined || images.length === 0) {
      $.error("No images were supplied for Backstretch");
    }

    /*
     * Scroll the page one pixel to get the right window height on iOS
     * Pretty harmless for everyone else
    */
    if ($(window).scrollTop() === 0 ) {
      window.scrollTo(0, 0);
    }

    return this.each(function () {
      var $this = $(this)
        , obj = $this.data('backstretch');

      // Do we already have an instance attached to this element?
      if (obj) {

        // Is this a method they're trying to execute?
        if (typeof images == 'string' && typeof obj[images] == 'function') {
          // Call the method
          obj[images](options);

          // No need to do anything further
          return;
        }

        // Merge the old options with the new
        options = $.extend(obj.options, options);

        // Remove the old instance
        obj.destroy(true);
      }

      obj = new Backstretch(this, images, options);
      $this.data('backstretch', obj);
    });
  };

  // If no element is supplied, we'll attach to body
  $.backstretch = function (images, options) {
    // Return the instance
    return $('body')
            .backstretch(images, options)
            .data('backstretch');
  };

  // Custom selector
  $.expr[':'].backstretch = function(elem) {
    return $(elem).data('backstretch') !== undefined;
  };

  /* DEFAULTS
   * ========================= */

  $.fn.backstretch.defaults = {
      centeredX: true   // Should we center the image on the X axis?
    , centeredY: true   // Should we center the image on the Y axis?
    , duration: 5000    // Amount of time in between slides (if slideshow)
    , fade: 0           // Speed of fade transition between slides
  };

  /* STYLES
   *
   * Baked-in styles that we'll apply to our elements.
   * In an effort to keep the plugin simple, these are not exposed as options.
   * That said, anyone can override these in their own stylesheet.
   * ========================= */
  var styles = {
      wrap: {
          left: 0
        , top: 0
        , overflow: 'hidden'
        , margin: 0
        , padding: 0
        , height: '100%'
        , width: '100%'
        , zIndex: -999999
      }
    , img: {
          position: 'absolute'
        , display: 'none'
        , margin: 0
        , padding: 0
        , border: 'none'
        , width: 'auto'
        , height: 'auto'
        , maxHeight: 'none'
        , maxWidth: 'none'
        , zIndex: -999999
      }
  };

  /* CLASS DEFINITION
   * ========================= */
  var Backstretch = function (container, images, options) {
    this.options = $.extend({}, $.fn.backstretch.defaults, options || {});

    /* In its simplest form, we allow Backstretch to be called on an image path.
     * e.g. $.backstretch('/path/to/image.jpg')
     * So, we need to turn this back into an array.
     */
    this.images = $.isArray(images) ? images : [images];

    // Preload images
    $.each(this.images, function () {
      $('<img />')[0].src = this;
    });

    // Convenience reference to know if the container is body.
    this.isBody = container === document.body;

    /* We're keeping track of a few different elements
     *
     * Container: the element that Backstretch was called on.
     * Wrap: a DIV that we place the image into, so we can hide the overflow.
     * Root: Convenience reference to help calculate the correct height.
     */
    this.$container = $(container);
    this.$root = this.isBody ? supportsFixedPosition ? $(window) : $(document) : this.$container;

    // Don't create a new wrap if one already exists (from a previous instance of Backstretch)
    var $existing = this.$container.children(".backstretch").first();
    this.$wrap = $existing.length ? $existing : $('<div class="backstretch"></div>').css(styles.wrap).appendTo(this.$container);

    // Non-body elements need some style adjustments
    if (!this.isBody) {
      // If the container is statically positioned, we need to make it relative,
      // and if no zIndex is defined, we should set it to zero.
      var position = this.$container.css('position')
        , zIndex = this.$container.css('zIndex');

      this.$container.css({
          position: position === 'static' ? 'relative' : position
        , zIndex: zIndex === 'auto' ? 0 : zIndex
        , background: 'none'
      });

      // Needs a higher z-index
      this.$wrap.css({zIndex: -999998});
    }

    // Fixed or absolute positioning?
    this.$wrap.css({
      position: this.isBody && supportsFixedPosition ? 'fixed' : 'absolute'
    });

    // Set the first image
    this.index = 0;
    this.show(this.index);

    // Listen for resize
    $(window).on('resize.backstretch', $.proxy(this.resize, this))
             .on('orientationchange.backstretch', $.proxy(function () {
                // Need to do this in order to get the right window height
                if (this.isBody && window.pageYOffset === 0) {
                  window.scrollTo(0, 1);
                  this.resize();
                }
             }, this));
  };

  /* PUBLIC METHODS
   * ========================= */
  Backstretch.prototype = {
      resize: function () {
        try {
          var bgCSS = {left: 0, top: 0}
            , rootWidth = this.isBody ? this.$root.width() : this.$root.innerWidth()
            , bgWidth = rootWidth
            , rootHeight = this.isBody ? ( window.innerHeight ? window.innerHeight : this.$root.height() ) : this.$root.innerHeight()
            , bgHeight = bgWidth / this.$img.data('ratio')
            , bgOffset;

            // Make adjustments based on image ratio
            if (bgHeight >= rootHeight) {
                bgOffset = (bgHeight - rootHeight) / 2;
                if(this.options.centeredY) {
                  bgCSS.top = '-' + bgOffset + 'px';
                }
            } else {
                bgHeight = rootHeight;
                bgWidth = bgHeight * this.$img.data('ratio');
                bgOffset = (bgWidth - rootWidth) / 2;
                if(this.options.centeredX) {
                  bgCSS.left = '-' + bgOffset + 'px';
                }
            }

            this.$wrap.css({width: rootWidth, height: rootHeight})
                      .find('img:not(.deleteable)').css({width: bgWidth, height: bgHeight}).css(bgCSS);
        } catch(err) {
            // IE7 seems to trigger resize before the image is loaded.
            // This try/catch block is a hack to let it fail gracefully.
        }

        return this;
      }

      // Show the slide at a certain position
    , show: function (newIndex) {

        // Validate index
        if (Math.abs(newIndex) > this.images.length - 1) {
          return;
        }

        // Vars
        var self = this
          , oldImage = self.$wrap.find('img').addClass('deleteable')
          , evtOptions = { relatedTarget: self.$container[0] };

        // Trigger the "before" event
        self.$container.trigger($.Event('backstretch.before', evtOptions), [self, newIndex]);

        // Set the new index
        this.index = newIndex;

        // Pause the slideshow
        clearInterval(self.interval);

        // New image
        self.$img = $('<img />')
                      .css(styles.img)
                      .bind('load', function (e) {
                        var imgWidth = this.width || $(e.target).width()
                          , imgHeight = this.height || $(e.target).height();

                        // Save the ratio
                        $(this).data('ratio', imgWidth / imgHeight);

                        // Show the image, then delete the old one
                        // "speed" option has been deprecated, but we want backwards compatibilty
                        $(this).fadeIn(self.options.speed || self.options.fade, function () {
                          oldImage.remove();

                          // Resume the slideshow
                          if (!self.paused) {
                            self.cycle();
                          }

                          // Trigger the "after" and "show" events
                          // "show" is being deprecated
                          $(['after', 'show']).each(function () {
                            self.$container.trigger($.Event('backstretch.' + this, evtOptions), [self, newIndex]);
                          });
                        });

                        // Resize
                        self.resize();
                      })
                      .appendTo(self.$wrap);

        // Hack for IE img onload event
        self.$img.attr('src', self.images[newIndex]);
        return self;
      }

    , next: function () {
        // Next slide
        return this.show(this.index < this.images.length - 1 ? this.index + 1 : 0);
      }

    , prev: function () {
        // Previous slide
        return this.show(this.index === 0 ? this.images.length - 1 : this.index - 1);
      }

    , pause: function () {
        // Pause the slideshow
        this.paused = true;
        return this;
      }

    , resume: function () {
        // Resume the slideshow
        this.paused = false;
        this.next();
        return this;
      }

    , cycle: function () {
        // Start/resume the slideshow
        if(this.images.length > 1) {
          // Clear the interval, just in case
          clearInterval(this.interval);

          this.interval = setInterval($.proxy(function () {
            // Check for paused slideshow
            if (!this.paused) {
              this.next();
            }
          }, this), this.options.duration);
        }
        return this;
      }

    , destroy: function (preserveBackground) {
        // Stop the resize events
        $(window).off('resize.backstretch orientationchange.backstretch');

        // Clear the interval
        clearInterval(this.interval);

        // Remove Backstretch
        if(!preserveBackground) {
          this.$wrap.remove();
        }
        this.$container.removeData('backstretch');
      }
  };

  /* SUPPORTS FIXED POSITION?
   *
   * Based on code from jQuery Mobile 1.1.0
   * http://jquerymobile.com/
   *
   * In a nutshell, we need to figure out if fixed positioning is supported.
   * Unfortunately, this is very difficult to do on iOS, and usually involves
   * injecting content, scrolling the page, etc.. It's ugly.
   * jQuery Mobile uses this workaround. It's not ideal, but works.
   *
   * Modified to detect IE6
   * ========================= */

  var supportsFixedPosition = (function () {
    var ua = navigator.userAgent
      , platform = navigator.platform
        // Rendering engine is Webkit, and capture major version
      , wkmatch = ua.match( /AppleWebKit\/([0-9]+)/ )
      , wkversion = !!wkmatch && wkmatch[ 1 ]
      , ffmatch = ua.match( /Fennec\/([0-9]+)/ )
      , ffversion = !!ffmatch && ffmatch[ 1 ]
      , operammobilematch = ua.match( /Opera Mobi\/([0-9]+)/ )
      , omversion = !!operammobilematch && operammobilematch[ 1 ]
      , iematch = ua.match( /MSIE ([0-9]+)/ )
      , ieversion = !!iematch && iematch[ 1 ];

    return !(
      // iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)
      ((platform.indexOf( "iPhone" ) > -1 || platform.indexOf( "iPad" ) > -1  || platform.indexOf( "iPod" ) > -1 ) && wkversion && wkversion < 534) ||

      // Opera Mini
      (window.operamini && ({}).toString.call( window.operamini ) === "[object OperaMini]") ||
      (operammobilematch && omversion < 7458) ||

      //Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)
      (ua.indexOf( "Android" ) > -1 && wkversion && wkversion < 533) ||

      // Firefox Mobile before 6.0 -
      (ffversion && ffversion < 6) ||

      // WebOS less than 3
      ("palmGetResource" in window && wkversion && wkversion < 534) ||

      // MeeGo
      (ua.indexOf( "MeeGo" ) > -1 && ua.indexOf( "NokiaBrowser/8.5.0" ) > -1) ||

      // IE6
      (ieversion && ieversion <= 6)
    );
  }());

}(jQuery, window));;/*! fancyBox v2.1.5 fancyapps.com | fancyapps.com/fancybox/#license */
(function(r,G,f,v){var J=f("html"),n=f(r),p=f(G),b=f.fancybox=function(){b.open.apply(this,arguments)},I=navigator.userAgent.match(/msie/i),B=null,s=G.createTouch!==v,t=function(a){return a&&a.hasOwnProperty&&a instanceof f},q=function(a){return a&&"string"===f.type(a)},E=function(a){return q(a)&&0<a.indexOf("%")},l=function(a,d){var e=parseInt(a,10)||0;d&&E(a)&&(e*=b.getViewport()[d]/100);return Math.ceil(e)},w=function(a,b){return l(a,b)+"px"};f.extend(b,{version:"2.1.5",defaults:{padding:15,margin:20,
width:800,height:600,minWidth:100,minHeight:100,maxWidth:9999,maxHeight:9999,pixelRatio:1,autoSize:!0,autoHeight:!1,autoWidth:!1,autoResize:!0,autoCenter:!s,fitToView:!0,aspectRatio:!1,topRatio:0.5,leftRatio:0.5,scrolling:"auto",wrapCSS:"",arrows:!0,closeBtn:!0,closeClick:!1,nextClick:!1,mouseWheel:!0,autoPlay:!1,playSpeed:3E3,preload:3,modal:!1,loop:!0,ajax:{dataType:"html",headers:{"X-fancyBox":!0}},iframe:{scrolling:"auto",preload:!0},swf:{wmode:"transparent",allowfullscreen:"true",allowscriptaccess:"always"},
keys:{next:{13:"left",34:"up",39:"left",40:"up"},prev:{8:"right",33:"down",37:"right",38:"down"},close:[27],play:[32],toggle:[70]},direction:{next:"left",prev:"right"},scrollOutside:!0,index:0,type:null,href:null,content:null,title:null,tpl:{wrap:'<div class="fancybox-wrap" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',image:'<img class="fancybox-image" src="{href}" alt="" />',iframe:'<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen'+
(I?' allowtransparency="true"':"")+"></iframe>",error:'<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',closeBtn:'<a title="Close" class="fancybox-item fancybox-close" href="javascript:;"></a>',next:'<a title="Next" class="fancybox-nav fancybox-next" href="javascript:;"><span></span></a>',prev:'<a title="Previous" class="fancybox-nav fancybox-prev" href="javascript:;"><span></span></a>'},openEffect:"fade",openSpeed:250,openEasing:"swing",openOpacity:!0,
openMethod:"zoomIn",closeEffect:"fade",closeSpeed:250,closeEasing:"swing",closeOpacity:!0,closeMethod:"zoomOut",nextEffect:"elastic",nextSpeed:250,nextEasing:"swing",nextMethod:"changeIn",prevEffect:"elastic",prevSpeed:250,prevEasing:"swing",prevMethod:"changeOut",helpers:{overlay:!0,title:!0},onCancel:f.noop,beforeLoad:f.noop,afterLoad:f.noop,beforeShow:f.noop,afterShow:f.noop,beforeChange:f.noop,beforeClose:f.noop,afterClose:f.noop},group:{},opts:{},previous:null,coming:null,current:null,isActive:!1,
isOpen:!1,isOpened:!1,wrap:null,skin:null,outer:null,inner:null,player:{timer:null,isActive:!1},ajaxLoad:null,imgPreload:null,transitions:{},helpers:{},open:function(a,d){if(a&&(f.isPlainObject(d)||(d={}),!1!==b.close(!0)))return f.isArray(a)||(a=t(a)?f(a).get():[a]),f.each(a,function(e,c){var k={},g,h,j,m,l;"object"===f.type(c)&&(c.nodeType&&(c=f(c)),t(c)?(k={href:c.data("fancybox-href")||c.attr("href"),title:c.data("fancybox-title")||c.attr("title"),isDom:!0,element:c},f.metadata&&f.extend(!0,k,
c.metadata())):k=c);g=d.href||k.href||(q(c)?c:null);h=d.title!==v?d.title:k.title||"";m=(j=d.content||k.content)?"html":d.type||k.type;!m&&k.isDom&&(m=c.data("fancybox-type"),m||(m=(m=c.prop("class").match(/fancybox\.(\w+)/))?m[1]:null));q(g)&&(m||(b.isImage(g)?m="image":b.isSWF(g)?m="swf":"#"===g.charAt(0)?m="inline":q(c)&&(m="html",j=c)),"ajax"===m&&(l=g.split(/\s+/,2),g=l.shift(),l=l.shift()));j||("inline"===m?g?j=f(q(g)?g.replace(/.*(?=#[^\s]+$)/,""):g):k.isDom&&(j=c):"html"===m?j=g:!m&&(!g&&
k.isDom)&&(m="inline",j=c));f.extend(k,{href:g,type:m,content:j,title:h,selector:l});a[e]=k}),b.opts=f.extend(!0,{},b.defaults,d),d.keys!==v&&(b.opts.keys=d.keys?f.extend({},b.defaults.keys,d.keys):!1),b.group=a,b._start(b.opts.index)},cancel:function(){var a=b.coming;a&&!1!==b.trigger("onCancel")&&(b.hideLoading(),b.ajaxLoad&&b.ajaxLoad.abort(),b.ajaxLoad=null,b.imgPreload&&(b.imgPreload.onload=b.imgPreload.onerror=null),a.wrap&&a.wrap.stop(!0,!0).trigger("onReset").remove(),b.coming=null,b.current||
b._afterZoomOut(a))},close:function(a){b.cancel();!1!==b.trigger("beforeClose")&&(b.unbindEvents(),b.isActive&&(!b.isOpen||!0===a?(f(".fancybox-wrap").stop(!0).trigger("onReset").remove(),b._afterZoomOut()):(b.isOpen=b.isOpened=!1,b.isClosing=!0,f(".fancybox-item, .fancybox-nav").remove(),b.wrap.stop(!0,!0).removeClass("fancybox-opened"),b.transitions[b.current.closeMethod]())))},play:function(a){var d=function(){clearTimeout(b.player.timer)},e=function(){d();b.current&&b.player.isActive&&(b.player.timer=
setTimeout(b.next,b.current.playSpeed))},c=function(){d();p.unbind(".player");b.player.isActive=!1;b.trigger("onPlayEnd")};if(!0===a||!b.player.isActive&&!1!==a){if(b.current&&(b.current.loop||b.current.index<b.group.length-1))b.player.isActive=!0,p.bind({"onCancel.player beforeClose.player":c,"onUpdate.player":e,"beforeLoad.player":d}),e(),b.trigger("onPlayStart")}else c()},next:function(a){var d=b.current;d&&(q(a)||(a=d.direction.next),b.jumpto(d.index+1,a,"next"))},prev:function(a){var d=b.current;
d&&(q(a)||(a=d.direction.prev),b.jumpto(d.index-1,a,"prev"))},jumpto:function(a,d,e){var c=b.current;c&&(a=l(a),b.direction=d||c.direction[a>=c.index?"next":"prev"],b.router=e||"jumpto",c.loop&&(0>a&&(a=c.group.length+a%c.group.length),a%=c.group.length),c.group[a]!==v&&(b.cancel(),b._start(a)))},reposition:function(a,d){var e=b.current,c=e?e.wrap:null,k;c&&(k=b._getPosition(d),a&&"scroll"===a.type?(delete k.position,c.stop(!0,!0).animate(k,200)):(c.css(k),e.pos=f.extend({},e.dim,k)))},update:function(a){var d=
a&&a.type,e=!d||"orientationchange"===d;e&&(clearTimeout(B),B=null);b.isOpen&&!B&&(B=setTimeout(function(){var c=b.current;c&&!b.isClosing&&(b.wrap.removeClass("fancybox-tmp"),(e||"load"===d||"resize"===d&&c.autoResize)&&b._setDimension(),"scroll"===d&&c.canShrink||b.reposition(a),b.trigger("onUpdate"),B=null)},e&&!s?0:300))},toggle:function(a){b.isOpen&&(b.current.fitToView="boolean"===f.type(a)?a:!b.current.fitToView,s&&(b.wrap.removeAttr("style").addClass("fancybox-tmp"),b.trigger("onUpdate")),
b.update())},hideLoading:function(){p.unbind(".loading");f("#fancybox-loading").remove()},showLoading:function(){var a,d;b.hideLoading();a=f('<div id="fancybox-loading"><div></div></div>').click(b.cancel).appendTo("body");p.bind("keydown.loading",function(a){if(27===(a.which||a.keyCode))a.preventDefault(),b.cancel()});b.defaults.fixed||(d=b.getViewport(),a.css({position:"absolute",top:0.5*d.h+d.y,left:0.5*d.w+d.x}))},getViewport:function(){var a=b.current&&b.current.locked||!1,d={x:n.scrollLeft(),
y:n.scrollTop()};a?(d.w=a[0].clientWidth,d.h=a[0].clientHeight):(d.w=s&&r.innerWidth?r.innerWidth:n.width(),d.h=s&&r.innerHeight?r.innerHeight:n.height());return d},unbindEvents:function(){b.wrap&&t(b.wrap)&&b.wrap.unbind(".fb");p.unbind(".fb");n.unbind(".fb")},bindEvents:function(){var a=b.current,d;a&&(n.bind("orientationchange.fb"+(s?"":" resize.fb")+(a.autoCenter&&!a.locked?" scroll.fb":""),b.update),(d=a.keys)&&p.bind("keydown.fb",function(e){var c=e.which||e.keyCode,k=e.target||e.srcElement;
if(27===c&&b.coming)return!1;!e.ctrlKey&&(!e.altKey&&!e.shiftKey&&!e.metaKey&&(!k||!k.type&&!f(k).is("[contenteditable]")))&&f.each(d,function(d,k){if(1<a.group.length&&k[c]!==v)return b[d](k[c]),e.preventDefault(),!1;if(-1<f.inArray(c,k))return b[d](),e.preventDefault(),!1})}),f.fn.mousewheel&&a.mouseWheel&&b.wrap.bind("mousewheel.fb",function(d,c,k,g){for(var h=f(d.target||null),j=!1;h.length&&!j&&!h.is(".fancybox-skin")&&!h.is(".fancybox-wrap");)j=h[0]&&!(h[0].style.overflow&&"hidden"===h[0].style.overflow)&&
(h[0].clientWidth&&h[0].scrollWidth>h[0].clientWidth||h[0].clientHeight&&h[0].scrollHeight>h[0].clientHeight),h=f(h).parent();if(0!==c&&!j&&1<b.group.length&&!a.canShrink){if(0<g||0<k)b.prev(0<g?"down":"left");else if(0>g||0>k)b.next(0>g?"up":"right");d.preventDefault()}}))},trigger:function(a,d){var e,c=d||b.coming||b.current;if(c){f.isFunction(c[a])&&(e=c[a].apply(c,Array.prototype.slice.call(arguments,1)));if(!1===e)return!1;c.helpers&&f.each(c.helpers,function(d,e){if(e&&b.helpers[d]&&f.isFunction(b.helpers[d][a]))b.helpers[d][a](f.extend(!0,
{},b.helpers[d].defaults,e),c)});p.trigger(a)}},isImage:function(a){return q(a)&&a.match(/(^data:image\/.*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\?|#).*)?$)/i)},isSWF:function(a){return q(a)&&a.match(/\.(swf)((\?|#).*)?$/i)},_start:function(a){var d={},e,c;a=l(a);e=b.group[a]||null;if(!e)return!1;d=f.extend(!0,{},b.opts,e);e=d.margin;c=d.padding;"number"===f.type(e)&&(d.margin=[e,e,e,e]);"number"===f.type(c)&&(d.padding=[c,c,c,c]);d.modal&&f.extend(!0,d,{closeBtn:!1,closeClick:!1,nextClick:!1,arrows:!1,
mouseWheel:!1,keys:null,helpers:{overlay:{closeClick:!1}}});d.autoSize&&(d.autoWidth=d.autoHeight=!0);"auto"===d.width&&(d.autoWidth=!0);"auto"===d.height&&(d.autoHeight=!0);d.group=b.group;d.index=a;b.coming=d;if(!1===b.trigger("beforeLoad"))b.coming=null;else{c=d.type;e=d.href;if(!c)return b.coming=null,b.current&&b.router&&"jumpto"!==b.router?(b.current.index=a,b[b.router](b.direction)):!1;b.isActive=!0;if("image"===c||"swf"===c)d.autoHeight=d.autoWidth=!1,d.scrolling="visible";"image"===c&&(d.aspectRatio=
!0);"iframe"===c&&s&&(d.scrolling="scroll");d.wrap=f(d.tpl.wrap).addClass("fancybox-"+(s?"mobile":"desktop")+" fancybox-type-"+c+" fancybox-tmp "+d.wrapCSS).appendTo(d.parent||"body");f.extend(d,{skin:f(".fancybox-skin",d.wrap),outer:f(".fancybox-outer",d.wrap),inner:f(".fancybox-inner",d.wrap)});f.each(["Top","Right","Bottom","Left"],function(a,b){d.skin.css("padding"+b,w(d.padding[a]))});b.trigger("onReady");if("inline"===c||"html"===c){if(!d.content||!d.content.length)return b._error("content")}else if(!e)return b._error("href");
"image"===c?b._loadImage():"ajax"===c?b._loadAjax():"iframe"===c?b._loadIframe():b._afterLoad()}},_error:function(a){f.extend(b.coming,{type:"html",autoWidth:!0,autoHeight:!0,minWidth:0,minHeight:0,scrolling:"no",hasError:a,content:b.coming.tpl.error});b._afterLoad()},_loadImage:function(){var a=b.imgPreload=new Image;a.onload=function(){this.onload=this.onerror=null;b.coming.width=this.width/b.opts.pixelRatio;b.coming.height=this.height/b.opts.pixelRatio;b._afterLoad()};a.onerror=function(){this.onload=
this.onerror=null;b._error("image")};a.src=b.coming.href;!0!==a.complete&&b.showLoading()},_loadAjax:function(){var a=b.coming;b.showLoading();b.ajaxLoad=f.ajax(f.extend({},a.ajax,{url:a.href,error:function(a,e){b.coming&&"abort"!==e?b._error("ajax",a):b.hideLoading()},success:function(d,e){"success"===e&&(a.content=d,b._afterLoad())}}))},_loadIframe:function(){var a=b.coming,d=f(a.tpl.iframe.replace(/\{rnd\}/g,(new Date).getTime())).attr("scrolling",s?"auto":a.iframe.scrolling).attr("src",a.href);
f(a.wrap).bind("onReset",function(){try{f(this).find("iframe").hide().attr("src","//about:blank").end().empty()}catch(a){}});a.iframe.preload&&(b.showLoading(),d.one("load",function(){f(this).data("ready",1);s||f(this).bind("load.fb",b.update);f(this).parents(".fancybox-wrap").width("100%").removeClass("fancybox-tmp").show();b._afterLoad()}));a.content=d.appendTo(a.inner);a.iframe.preload||b._afterLoad()},_preloadImages:function(){var a=b.group,d=b.current,e=a.length,c=d.preload?Math.min(d.preload,
e-1):0,f,g;for(g=1;g<=c;g+=1)f=a[(d.index+g)%e],"image"===f.type&&f.href&&((new Image).src=f.href)},_afterLoad:function(){var a=b.coming,d=b.current,e,c,k,g,h;b.hideLoading();if(a&&!1!==b.isActive)if(!1===b.trigger("afterLoad",a,d))a.wrap.stop(!0).trigger("onReset").remove(),b.coming=null;else{d&&(b.trigger("beforeChange",d),d.wrap.stop(!0).removeClass("fancybox-opened").find(".fancybox-item, .fancybox-nav").remove());b.unbindEvents();e=a.content;c=a.type;k=a.scrolling;f.extend(b,{wrap:a.wrap,skin:a.skin,
outer:a.outer,inner:a.inner,current:a,previous:d});g=a.href;switch(c){case "inline":case "ajax":case "html":a.selector?e=f("<div>").html(e).find(a.selector):t(e)&&(e.data("fancybox-placeholder")||e.data("fancybox-placeholder",f('<div class="fancybox-placeholder"></div>').insertAfter(e).hide()),e=e.show().detach(),a.wrap.bind("onReset",function(){f(this).find(e).length&&e.hide().replaceAll(e.data("fancybox-placeholder")).data("fancybox-placeholder",!1)}));break;case "image":e=a.tpl.image.replace("{href}",
g);break;case "swf":e='<object id="fancybox-swf" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="movie" value="'+g+'"></param>',h="",f.each(a.swf,function(a,b){e+='<param name="'+a+'" value="'+b+'"></param>';h+=" "+a+'="'+b+'"'}),e+='<embed src="'+g+'" type="application/x-shockwave-flash" width="100%" height="100%"'+h+"></embed></object>"}(!t(e)||!e.parent().is(a.inner))&&a.inner.append(e);b.trigger("beforeShow");a.inner.css("overflow","yes"===k?"scroll":
"no"===k?"hidden":k);b._setDimension();b.reposition();b.isOpen=!1;b.coming=null;b.bindEvents();if(b.isOpened){if(d.prevMethod)b.transitions[d.prevMethod]()}else f(".fancybox-wrap").not(a.wrap).stop(!0).trigger("onReset").remove();b.transitions[b.isOpened?a.nextMethod:a.openMethod]();b._preloadImages()}},_setDimension:function(){var a=b.getViewport(),d=0,e=!1,c=!1,e=b.wrap,k=b.skin,g=b.inner,h=b.current,c=h.width,j=h.height,m=h.minWidth,u=h.minHeight,n=h.maxWidth,p=h.maxHeight,s=h.scrolling,q=h.scrollOutside?
h.scrollbarWidth:0,x=h.margin,y=l(x[1]+x[3]),r=l(x[0]+x[2]),v,z,t,C,A,F,B,D,H;e.add(k).add(g).width("auto").height("auto").removeClass("fancybox-tmp");x=l(k.outerWidth(!0)-k.width());v=l(k.outerHeight(!0)-k.height());z=y+x;t=r+v;C=E(c)?(a.w-z)*l(c)/100:c;A=E(j)?(a.h-t)*l(j)/100:j;if("iframe"===h.type){if(H=h.content,h.autoHeight&&1===H.data("ready"))try{H[0].contentWindow.document.location&&(g.width(C).height(9999),F=H.contents().find("body"),q&&F.css("overflow-x","hidden"),A=F.outerHeight(!0))}catch(G){}}else if(h.autoWidth||
h.autoHeight)g.addClass("fancybox-tmp"),h.autoWidth||g.width(C),h.autoHeight||g.height(A),h.autoWidth&&(C=g.width()),h.autoHeight&&(A=g.height()),g.removeClass("fancybox-tmp");c=l(C);j=l(A);D=C/A;m=l(E(m)?l(m,"w")-z:m);n=l(E(n)?l(n,"w")-z:n);u=l(E(u)?l(u,"h")-t:u);p=l(E(p)?l(p,"h")-t:p);F=n;B=p;h.fitToView&&(n=Math.min(a.w-z,n),p=Math.min(a.h-t,p));z=a.w-y;r=a.h-r;h.aspectRatio?(c>n&&(c=n,j=l(c/D)),j>p&&(j=p,c=l(j*D)),c<m&&(c=m,j=l(c/D)),j<u&&(j=u,c=l(j*D))):(c=Math.max(m,Math.min(c,n)),h.autoHeight&&
"iframe"!==h.type&&(g.width(c),j=g.height()),j=Math.max(u,Math.min(j,p)));if(h.fitToView)if(g.width(c).height(j),e.width(c+x),a=e.width(),y=e.height(),h.aspectRatio)for(;(a>z||y>r)&&(c>m&&j>u)&&!(19<d++);)j=Math.max(u,Math.min(p,j-10)),c=l(j*D),c<m&&(c=m,j=l(c/D)),c>n&&(c=n,j=l(c/D)),g.width(c).height(j),e.width(c+x),a=e.width(),y=e.height();else c=Math.max(m,Math.min(c,c-(a-z))),j=Math.max(u,Math.min(j,j-(y-r)));q&&("auto"===s&&j<A&&c+x+q<z)&&(c+=q);g.width(c).height(j);e.width(c+x);a=e.width();
y=e.height();e=(a>z||y>r)&&c>m&&j>u;c=h.aspectRatio?c<F&&j<B&&c<C&&j<A:(c<F||j<B)&&(c<C||j<A);f.extend(h,{dim:{width:w(a),height:w(y)},origWidth:C,origHeight:A,canShrink:e,canExpand:c,wPadding:x,hPadding:v,wrapSpace:y-k.outerHeight(!0),skinSpace:k.height()-j});!H&&(h.autoHeight&&j>u&&j<p&&!c)&&g.height("auto")},_getPosition:function(a){var d=b.current,e=b.getViewport(),c=d.margin,f=b.wrap.width()+c[1]+c[3],g=b.wrap.height()+c[0]+c[2],c={position:"absolute",top:c[0],left:c[3]};d.autoCenter&&d.fixed&&
!a&&g<=e.h&&f<=e.w?c.position="fixed":d.locked||(c.top+=e.y,c.left+=e.x);c.top=w(Math.max(c.top,c.top+(e.h-g)*d.topRatio));c.left=w(Math.max(c.left,c.left+(e.w-f)*d.leftRatio));return c},_afterZoomIn:function(){var a=b.current;a&&(b.isOpen=b.isOpened=!0,b.wrap.css("overflow","visible").addClass("fancybox-opened"),b.update(),(a.closeClick||a.nextClick&&1<b.group.length)&&b.inner.css("cursor","pointer").bind("click.fb",function(d){!f(d.target).is("a")&&!f(d.target).parent().is("a")&&(d.preventDefault(),
b[a.closeClick?"close":"next"]())}),a.closeBtn&&f(a.tpl.closeBtn).appendTo(b.skin).bind("click.fb",function(a){a.preventDefault();b.close()}),a.arrows&&1<b.group.length&&((a.loop||0<a.index)&&f(a.tpl.prev).appendTo(b.outer).bind("click.fb",b.prev),(a.loop||a.index<b.group.length-1)&&f(a.tpl.next).appendTo(b.outer).bind("click.fb",b.next)),b.trigger("afterShow"),!a.loop&&a.index===a.group.length-1?b.play(!1):b.opts.autoPlay&&!b.player.isActive&&(b.opts.autoPlay=!1,b.play()))},_afterZoomOut:function(a){a=
a||b.current;f(".fancybox-wrap").trigger("onReset").remove();f.extend(b,{group:{},opts:{},router:!1,current:null,isActive:!1,isOpened:!1,isOpen:!1,isClosing:!1,wrap:null,skin:null,outer:null,inner:null});b.trigger("afterClose",a)}});b.transitions={getOrigPosition:function(){var a=b.current,d=a.element,e=a.orig,c={},f=50,g=50,h=a.hPadding,j=a.wPadding,m=b.getViewport();!e&&(a.isDom&&d.is(":visible"))&&(e=d.find("img:first"),e.length||(e=d));t(e)?(c=e.offset(),e.is("img")&&(f=e.outerWidth(),g=e.outerHeight())):
(c.top=m.y+(m.h-g)*a.topRatio,c.left=m.x+(m.w-f)*a.leftRatio);if("fixed"===b.wrap.css("position")||a.locked)c.top-=m.y,c.left-=m.x;return c={top:w(c.top-h*a.topRatio),left:w(c.left-j*a.leftRatio),width:w(f+j),height:w(g+h)}},step:function(a,d){var e,c,f=d.prop;c=b.current;var g=c.wrapSpace,h=c.skinSpace;if("width"===f||"height"===f)e=d.end===d.start?1:(a-d.start)/(d.end-d.start),b.isClosing&&(e=1-e),c="width"===f?c.wPadding:c.hPadding,c=a-c,b.skin[f](l("width"===f?c:c-g*e)),b.inner[f](l("width"===
f?c:c-g*e-h*e))},zoomIn:function(){var a=b.current,d=a.pos,e=a.openEffect,c="elastic"===e,k=f.extend({opacity:1},d);delete k.position;c?(d=this.getOrigPosition(),a.openOpacity&&(d.opacity=0.1)):"fade"===e&&(d.opacity=0.1);b.wrap.css(d).animate(k,{duration:"none"===e?0:a.openSpeed,easing:a.openEasing,step:c?this.step:null,complete:b._afterZoomIn})},zoomOut:function(){var a=b.current,d=a.closeEffect,e="elastic"===d,c={opacity:0.1};e&&(c=this.getOrigPosition(),a.closeOpacity&&(c.opacity=0.1));b.wrap.animate(c,
{duration:"none"===d?0:a.closeSpeed,easing:a.closeEasing,step:e?this.step:null,complete:b._afterZoomOut})},changeIn:function(){var a=b.current,d=a.nextEffect,e=a.pos,c={opacity:1},f=b.direction,g;e.opacity=0.1;"elastic"===d&&(g="down"===f||"up"===f?"top":"left","down"===f||"right"===f?(e[g]=w(l(e[g])-200),c[g]="+=200px"):(e[g]=w(l(e[g])+200),c[g]="-=200px"));"none"===d?b._afterZoomIn():b.wrap.css(e).animate(c,{duration:a.nextSpeed,easing:a.nextEasing,complete:b._afterZoomIn})},changeOut:function(){var a=
b.previous,d=a.prevEffect,e={opacity:0.1},c=b.direction;"elastic"===d&&(e["down"===c||"up"===c?"top":"left"]=("up"===c||"left"===c?"-":"+")+"=200px");a.wrap.animate(e,{duration:"none"===d?0:a.prevSpeed,easing:a.prevEasing,complete:function(){f(this).trigger("onReset").remove()}})}};b.helpers.overlay={defaults:{closeClick:!0,speedOut:200,showEarly:!0,css:{},locked:!s,fixed:!0},overlay:null,fixed:!1,el:f("html"),create:function(a){a=f.extend({},this.defaults,a);this.overlay&&this.close();this.overlay=
f('<div class="fancybox-overlay"></div>').appendTo(b.coming?b.coming.parent:a.parent);this.fixed=!1;a.fixed&&b.defaults.fixed&&(this.overlay.addClass("fancybox-overlay-fixed"),this.fixed=!0)},open:function(a){var d=this;a=f.extend({},this.defaults,a);this.overlay?this.overlay.unbind(".overlay").width("auto").height("auto"):this.create(a);this.fixed||(n.bind("resize.overlay",f.proxy(this.update,this)),this.update());a.closeClick&&this.overlay.bind("click.overlay",function(a){if(f(a.target).hasClass("fancybox-overlay"))return b.isActive?
b.close():d.close(),!1});this.overlay.css(a.css).show()},close:function(){var a,b;n.unbind("resize.overlay");this.el.hasClass("fancybox-lock")&&(f(".fancybox-margin").removeClass("fancybox-margin"),a=n.scrollTop(),b=n.scrollLeft(),this.el.removeClass("fancybox-lock"),n.scrollTop(a).scrollLeft(b));f(".fancybox-overlay").remove().hide();f.extend(this,{overlay:null,fixed:!1})},update:function(){var a="100%",b;this.overlay.width(a).height("100%");I?(b=Math.max(G.documentElement.offsetWidth,G.body.offsetWidth),
p.width()>b&&(a=p.width())):p.width()>n.width()&&(a=p.width());this.overlay.width(a).height(p.height())},onReady:function(a,b){var e=this.overlay;f(".fancybox-overlay").stop(!0,!0);e||this.create(a);a.locked&&(this.fixed&&b.fixed)&&(e||(this.margin=p.height()>n.height()?f("html").css("margin-right").replace("px",""):!1),b.locked=this.overlay.append(b.wrap),b.fixed=!1);!0===a.showEarly&&this.beforeShow.apply(this,arguments)},beforeShow:function(a,b){var e,c;b.locked&&(!1!==this.margin&&(f("*").filter(function(){return"fixed"===
f(this).css("position")&&!f(this).hasClass("fancybox-overlay")&&!f(this).hasClass("fancybox-wrap")}).addClass("fancybox-margin"),this.el.addClass("fancybox-margin")),e=n.scrollTop(),c=n.scrollLeft(),this.el.addClass("fancybox-lock"),n.scrollTop(e).scrollLeft(c));this.open(a)},onUpdate:function(){this.fixed||this.update()},afterClose:function(a){this.overlay&&!b.coming&&this.overlay.fadeOut(a.speedOut,f.proxy(this.close,this))}};b.helpers.title={defaults:{type:"float",position:"bottom"},beforeShow:function(a){var d=
b.current,e=d.title,c=a.type;f.isFunction(e)&&(e=e.call(d.element,d));if(q(e)&&""!==f.trim(e)){d=f('<div class="fancybox-title fancybox-title-'+c+'-wrap">'+e+"</div>");switch(c){case "inside":c=b.skin;break;case "outside":c=b.wrap;break;case "over":c=b.inner;break;default:c=b.skin,d.appendTo("body"),I&&d.width(d.width()),d.wrapInner('<span class="child"></span>'),b.current.margin[2]+=Math.abs(l(d.css("margin-bottom")))}d["top"===a.position?"prependTo":"appendTo"](c)}}};f.fn.fancybox=function(a){var d,
e=f(this),c=this.selector||"",k=function(g){var h=f(this).blur(),j=d,k,l;!g.ctrlKey&&(!g.altKey&&!g.shiftKey&&!g.metaKey)&&!h.is(".fancybox-wrap")&&(k=a.groupAttr||"data-fancybox-group",l=h.attr(k),l||(k="rel",l=h.get(0)[k]),l&&(""!==l&&"nofollow"!==l)&&(h=c.length?f(c):e,h=h.filter("["+k+'="'+l+'"]'),j=h.index(this)),a.index=j,!1!==b.open(h,a)&&g.preventDefault())};a=a||{};d=a.index||0;!c||!1===a.live?e.unbind("click.fb-start").bind("click.fb-start",k):p.undelegate(c,"click.fb-start").delegate(c+
":not('.fancybox-item, .fancybox-nav')","click.fb-start",k);this.filter("[data-fancybox-start=1]").trigger("click");return this};p.ready(function(){var a,d;f.scrollbarWidth===v&&(f.scrollbarWidth=function(){var a=f('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo("body"),b=a.children(),b=b.innerWidth()-b.height(99).innerWidth();a.remove();return b});if(f.support.fixedPosition===v){a=f.support;d=f('<div style="position:fixed;top:20px;"></div>').appendTo("body");var e=20===
d[0].offsetTop||15===d[0].offsetTop;d.remove();a.fixedPosition=e}f.extend(b.defaults,{scrollbarWidth:f.scrollbarWidth(),fixed:f.support.fixedPosition,parent:f("body")});a=f(r).width();J.addClass("fancybox-lock-test");d=f(r).width();J.removeClass("fancybox-lock-test");f("<style type='text/css'>.fancybox-margin{margin-right:"+(d-a)+"px;}</style>").appendTo("head")})})(window,document,jQuery);;// jQuery.isInView, v1.0.4
// Copyright (c) 2014-2016 Michael Heim, Zeilenwechsel.de
// Distributed under MIT license
// http://github.com/hashchange/jquery.isinview

;( function( $ ) {
    "use strict";

    var _useGetComputedStyle = !! window.getComputedStyle,          // IE8, my dear, this is for you
        _isIOS,
        root = window,
        $root = $( window );


    /**
     * API
     */

    /**
     * @param   {string} [axis="both"]  values "horizontal", "vertical", "both"
     * @returns {boolean|Object|undefined}
     */
    $.fn.hasScrollbar = function ( axis ) {
        return hasScrollbar( this, axis );
    };

    /**
     * @param   {string} [axis="both"]  values "horizontal", "vertical", "both"
     * @returns {number|Object|undefined}
     */
    $.fn.scrollbarWidth = function ( axis ) {
        return effectiveScrollbarWith( this, axis );
    };

    /**
     * @returns {Window|undefined}
     */
    $.fn.ownerWindow = function () {
        return ownerWindow( this );
    };

    /**
     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]
     * @param {Object}                                    [opts]
     * @param {boolean}                                   [opts.partially=false]
     * @param {boolean}                                   [opts.excludeHidden=false]
     * @param {string}                                    [opts.direction="both"]
     * @param {string}                                    [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {jQuery}
     */
    $.fn.inView = function ( container, opts ) {
        return inView( this, container, opts );
    };

    /**
     * @param {Object}        [opts]
     * @param {boolean}       [opts.partially=false]
     * @param {boolean}       [opts.excludeHidden=false]
     * @param {string}        [opts.direction="both"]
     * @param {string}        [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string} [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {jQuery}
     */
    $.fn.inViewport = function ( opts ) {
        return inView( this, ownerWindow( this ), opts );
    };

    /**
     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]
     * @param {Object}                                    [opts]
     * @param {boolean}                                   [opts.partially=false]
     * @param {boolean}                                   [opts.excludeHidden=false]
     * @param {string}                                    [opts.direction="both"]
     * @param {string}                                    [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {boolean}
     */
    $.fn.isInView = function ( container, opts ) {
        return isInView( this, container, opts );
    };

    /**
     * @param {Object}        [opts]
     * @param {boolean}       [opts.partially=false]
     * @param {boolean}       [opts.excludeHidden=false]
     * @param {string}        [opts.direction="both"]
     * @param {string}        [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string} [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {boolean}
     */
    $.fn.isInViewport = function ( opts ) {
        return isInView( this, ownerWindow( this ), opts );
    };

    $.expr.match.inviewport = /^(?:inVieport)$/i;

    $.expr.setFilters.inviewport = $.expr.createPseudo( function () {
        return $.expr.createPseudo( function ( elems, matches ) {
            var i, config,
                length =  elems.length;

            if ( length ) {

                config = _prepareConfig( $( elems ) );
                checkHierarchy( elems[0], config.container );

                for ( i = 0; i < length; i++ ) {
                    matches[i] = _isInView( elems[i], config ) ? elems[i] : undefined;
                }
            }

        } );
    } );


    /**
     * Internals
     */

    /**
     * Does the actual work of $.fn.hasScrollbar. Protected from external modification. See $.fn.hasScrollbar for
     * details.
     *
     * @param   {jQuery} $elem
     * @param   {string} [axis="both"]  values "horizontal", "vertical", "both"
     * @returns {boolean|Object|undefined}
     */
    function hasScrollbar ( $elem, axis ) {

        var $body, elemProps, bodyProps, innerWidth, innerHeight, scrollWidth, scrollHeight,
            query = { target: {} }, result = {}, context = {},
            elem = $elem[0];

        $elem = $elem.eq( 0 );
        axis || ( axis = "both" );

        query.getBoth = axis === "both";
        query.getHorizontal = axis === "horizontal" || query.getBoth;
        query.getVertical = axis === "vertical" || query.getBoth;

        if ( axis !== "horizontal" && axis !== "vertical" && axis !== "both" ) throw new Error( "Invalid parameter value: axis = " + axis );
        if ( ! $elem.length ) return;

        // Transformations:
        // - If called on a window, we need window, document, documentElement and body, and discard the element
        // - If called on the document or document element, we treat it like a call on window (above)
        // - If called on the body, we need document, documentElement and the body itself (again, we discard the element
        //   to avoid ambiguity)
        // - If called on an iframe element, we treat it like a window call, using the iframe content window
        query.target.isWindow = $.isWindow( elem );
        if ( query.target.isWindow ) {
            context.document = elem.document;
        } else if ( elem.nodeType === 9 ) {
            context.document = elem;
            query.target.isWindow = true;
        } else if ( elem === elem.ownerDocument.documentElement ) {
            context.document = elem.ownerDocument;
            query.target.isWindow = true;
        } else if ( elem.nodeType === 1 && elem.tagName.toLowerCase() === "iframe" ) {
            context.document = elem.contentDocument || elem.contentWindow.document;
            query.target.isWindow = true;
        } else if ( elem === elem.ownerDocument.body ) {
            context.document = elem.ownerDocument;
            query.target.isBody = true;
        }

        if ( query.target.isWindow || query.target.isBody ) {
            context.window = context.document.defaultView || context.document.parentWindow;
            context.$document = $( context.document );
            context.documentElement = context.document.documentElement;
            context.body = context.document.body;

            elem = $elem = undefined;       // won't be needed; discard, to avoid ambiguity in the code below
        }

        if ( query.target.isWindow ) {

            result = _windowHasScrollbar( query, context );

        } else if ( query.target.isBody ) {

            // Checking for body scroll bars.
            //
            // body.clientWidth returns the width of the body, minus the scroll bars. We can simply compare it to the
            // full width, provided that the browser displays scroll bars which take up space.
            //
            // By implication, this check DOES NOT work for an effective body overflow of "auto" in browsers which
            // display scroll bars of width 0. (Affects iOS, other mobile browsers, and Safari on OS X when used without
            // an attached mouse.) There simply is no reliable, bullet-proof way to determine the width of the body
            // content, ie the true body scroll width, in those browsers.
            bodyProps = _getViewportOverflows( query, context ).body;

            $body = $( context.body );
            if ( query.getHorizontal ) result.horizontal = bodyProps.overflowScrollX || bodyProps.overflowAutoX && context.body.clientHeight < $body.height();
            if ( query.getVertical ) result.vertical = bodyProps.overflowScrollY || bodyProps.overflowAutoY && context.body.clientWidth < $body.width();

        } else {

            // Scroll bars on an ordinary HTML element
            //
            // If we deal with an ordinary element, we always need the overflow settings for both axes because the axes
            // interact (one scroll bar can cause another).
            elemProps = getCss( elem, ["overflow", "overflowX", "overflowY"], { toLowerCase: true } );
            elemProps = getAppliedOverflows( elemProps, true );

            scrollWidth = elem.scrollWidth;
            scrollHeight = elem.scrollHeight;

            result.horizontal = scrollWidth > 0 && ( elemProps.overflowScrollX || elemProps.overflowAutoX && ( innerWidth = $elem.innerWidth() ) < scrollWidth );
            result.vertical = scrollHeight > 0 && ( elemProps.overflowScrollY || elemProps.overflowAutoY && ( innerHeight = $elem.innerHeight() ) < scrollHeight );

            // Detect if the appearance of one scroll bar causes the other to appear, too.
            result.vertical = result.vertical ||
                              result.horizontal && elemProps.overflowAutoY &&
                              ( innerHeight !== undefined ? innerHeight : $elem.innerHeight() ) - $.scrollbarWidth() < scrollHeight;
            result.horizontal = result.horizontal ||
                                result.vertical && elemProps.overflowAutoX &&
                                ( innerWidth !== undefined ? innerWidth : $elem.innerWidth() ) - $.scrollbarWidth() < scrollWidth;

        }

        return query.getBoth ? result : query.getHorizontal ? result.horizontal : result.vertical;
    }

    /**
     * Does the actual work of $.fn.scrollbarWidth. Protected from external modification. See $.fn.scrollbarWidth for
     * details.
     *
     * @param   {jQuery} $elem
     * @param   {string} [axis="both"]  values "horizontal", "vertical", "both"
     * @returns {number|Object}
     */
    function effectiveScrollbarWith ( $elem, axis ) {

        var queryHorizontal, queryVertical, queryBoth, elemHasScrollbar, horizontal, vertical,
            globalWidth = $.scrollbarWidth();

        axis || ( axis = "both" );

        queryBoth = axis === "both";
        queryHorizontal = axis === "horizontal" || queryBoth;
        queryVertical = axis === "vertical" || queryBoth;

        if ( axis !== "horizontal" && axis !== "vertical" && axis !== "both" ) throw new Error( "Invalid parameter value: axis = " + axis );
        if ( ! $elem.length ) return;

        // Bail out early, without an $elem.hasScrollbar() query, if scroll bars don't take up any space.
        if ( globalWidth === 0 ) return queryBoth ? { horizontal: 0, vertical: 0 } : 0;

        elemHasScrollbar = queryBoth ? hasScrollbar( $elem ) : queryHorizontal ? { horizontal: hasScrollbar( $elem, "horizontal" ) } : { vertical: hasScrollbar( $elem, "vertical" ) };

        if ( queryHorizontal ) horizontal = elemHasScrollbar.horizontal ? globalWidth : 0;
        if ( queryVertical ) vertical = elemHasScrollbar.vertical ? globalWidth : 0;

        return queryBoth ? { horizontal: horizontal, vertical: vertical } : queryHorizontal ? horizontal : vertical;

    }

    /**
     * Does the actual work of $.fn.ownerWindow. Protected from external modification. See $.fn.ownerWindow for details.
     *
     * @param   {jQuery} $elem
     * @returns {Window|undefined}
     */
    function ownerWindow ( $elem ) {
        var elem = $elem[0],
            ownerDocument = elem && ( elem.nodeType === 9 ? elem : elem.ownerDocument );

        return ownerDocument && ( ownerDocument.defaultView || ownerDocument.parentWindow ) || $.isWindow( elem ) && elem || undefined;
    }

    /**
     * Does the actual work of $.fn.inView. Protected from external modification. See $.fn.inView for details.
     *
     * @param {jQuery}                                    $elems
     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]
     * @param {Object}                                    [opts]
     * @param {boolean}                                   [opts.partially=false]
     * @param {boolean}                                   [opts.excludeHidden=false]
     * @param {string}                                    [opts.direction="both"]
     * @param {string}                                    [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {jQuery}
     */
    function inView ( $elems, container, opts ) {

        var config,
            elemsInView = [];

        if ( ! $elems.length ) return $();

        config = _prepareConfig( $elems, container, opts );

        // Check if the elements are children of the container. For performance reasons, only the first element is
        // examined.
        checkHierarchy( $elems[0], config.container );

        $elems.each( function () {
            if ( _isInView( this, config ) ) elemsInView.push( this );
        } );

        return $( elemsInView );

    }

    /**
     * Does the actual work of $.fn.isInView. Protected from external modification. See $.fn.isInView for details.
     *
     * @param {jQuery}                                    $elem
     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]
     * @param {Object}                                    [opts]
     * @param {boolean}                                   [opts.partially=false]
     * @param {boolean}                                   [opts.excludeHidden=false]
     * @param {string}                                    [opts.direction="both"]
     * @param {string}                                    [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {boolean}
     */
    function isInView ( $elem, container, opts ) {

        var config,
            elem = $elem[0];

        if ( ! $elem.length ) return false;

        config = _prepareConfig( $elem, container, opts );
        checkHierarchy( elem, config.container );

        return _isInView( elem, config );

    }

    /**
     * Prepares the configuration for a single element query. Returns the config object which is to be consumed by
     * _isInView().
     *
     * @param {jQuery}                                    $elem                       single element, or set of elements
     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]
     * @param {Object}                                    [opts]
     * @param {boolean}                                   [opts.partially=false]
     * @param {boolean}                                   [opts.excludeHidden=false]
     * @param {string}                                    [opts.direction="both"]
     * @param {string}                                    [opts.box="border-box"]     alternatively, "content-box"
     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit ("px" or "%" only)
     *
     * @returns {Object}
     */
    function _prepareConfig ( $elem, container, opts ) {

        var $container, direction,
            config = {};

        opts || ( opts = {} );

        container || ( container = ownerWindow( $elem ) );
        config.$container = $container = wrapContainer( container );
        config.container = container = $container[0];

        checkOptions( opts );

        direction = opts.direction || 'both';
        config.useVertical = direction === 'both' || direction === 'vertical';
        config.useHorizontal = direction === 'both' || direction === 'horizontal';

        config.partially = opts.partially;
        config.excludeHidden = opts.excludeHidden;
        config.borderBox = opts.box !== 'content-box';
        config.containerIsWindow = $.isWindow( container );

        if ( opts.tolerance !== undefined ) {
            config.toleranceType = ( isNumber( opts.tolerance ) || opts.tolerance.slice( -3 ) === "px" ) ? "add" : "multiply";
            config.tolerance = config.toleranceType === "add" ? parseFloat( opts.tolerance ) : parseFloat( opts.tolerance ) / 100 + 1;
        } else {
            config.tolerance = 0;
            config.toleranceType = "add";
        }

        // Create an object to cache DOM queries with regard to the viewport, for faster repeated access.
        config.cache = {};

        return config;
    }

    /**
     * Returns if an element is in view, with regard to a given configuration.
     *
     * The configuration is built with _prepareConfig().
     *
     * @param {HTMLElement}        elem
     * @param {Object}             config
     * @param {HTMLElement|Window} config.container
     * @param {jQuery}             config.$container
     * @param {boolean}            config.containerIsWindow
     * @param {Object}             config.cache
     * @param {boolean}            config.useHorizontal
     * @param {boolean}            config.useVertical
     * @param {boolean}            config.partially
     * @param {boolean}            config.excludeHidden
     * @param {boolean}            config.borderBox
     * @param {number}             config.tolerance
     * @param {string}             config.toleranceType
     *
     * @returns {boolean}
     */
    function _isInView ( elem, config ) {

        var containerWidth, containerHeight, hTolerance, vTolerance, rect,
            container = config.container,
            $container = config.$container,
            cache = config.cache,
            elemInView = true;

        if ( elem === container ) throw new Error( "Invalid container: is the same as the element" );

        // When hidden elements are ignored, we check if an element consumes space in the document. And we bail out
        // immediately if it doesn't.
        //
        // The test employed for this works in the vast majority of cases, but there is a limitation. We use offsetWidth
        // and offsetHeight, which considers the content (incl. borders) but ignores margins. Zero-size content with a
        // margin might actually consume space sometimes, but it won't be detected (see http://jsbin.com/tiwabo/3).
        //
        // That said, the definition of visibility and the actual test are the same as in jQuery :visible.
        if ( config.excludeHidden && !( elem.offsetWidth > 0 && elem.offsetHeight > 0 ) ) return false;

        if ( config.useHorizontal ) containerWidth = getNetContainerWidth( $container, config.containerIsWindow, cache );
        if ( config.useVertical ) containerHeight = getNetContainerHeight( $container, config.containerIsWindow, cache );

        // Convert tolerance to a px value (if given as a percentage)
        hTolerance = cache.hTolerance !== undefined ? cache.hTolerance : ( cache.hTolerance = config.toleranceType === "add" ? config.tolerance : containerWidth * config.tolerance );
        vTolerance = cache.vTolerance !== undefined ? cache.vTolerance : ( cache.vTolerance = config.toleranceType === "add" ? config.tolerance : containerHeight * config.tolerance );

        // We can safely use getBoundingClientRect without a fallback. Its core properties (top, left, bottom, right)
        // are supported on the desktop for ages (IE5+). On mobile, too: supported from Blackberry 6+ (2010), iOS 4
        // (2010, iPhone 3GS+), according to the jQuery source comment in $.fn.offset.
        //
        // In oldIE (up to IE8), the coordinates were 2px off in each dimension because the "viewport" began at (2,2) of
        // the window. Can be feature-tested by creating an absolutely positioned div at (0,0) and reading the rect
        // coordinates. Won't be fixed here because the quirk is too minor to justify the overhead, just for oldIE.
        //
        // (See http://stackoverflow.com/a/10231202/508355 and Zakas, Professional Javascript (2012), p. 406)

        rect = config.borderBox ? elem.getBoundingClientRect() : getContentRect( elem );
        if ( ! config.containerIsWindow ) rect = getRelativeRect( rect, $container, cache );

        if ( config.partially ) {
            if ( config.useVertical ) elemInView = rect.top < containerHeight + vTolerance && rect.bottom > -vTolerance;
            if ( config.useHorizontal ) elemInView = elemInView && rect.left < containerWidth + hTolerance && rect.right > -hTolerance;
        } else {
            if ( config.useVertical ) elemInView = rect.top >= -vTolerance && rect.top < containerHeight + vTolerance && rect.bottom > -vTolerance && rect.bottom <= containerHeight + vTolerance;
            if ( config.useHorizontal ) elemInView = elemInView && rect.left >= -hTolerance && rect.left < containerWidth + hTolerance && rect.right > -hTolerance && rect.right <= containerWidth + hTolerance;
        }

        return elemInView;

    }

    /**
     * Gets the TextRectangle coordinates relative to a container element.
     *
     * Do not call if the container is a window (redundant) or a document. Both calls would fail.
     */
    function getRelativeRect ( rect, $container, cache ) {
        var containerPaddingRectRoot;

        if ( cache && cache.containerPaddingRectRoot ) {

            containerPaddingRectRoot = cache.containerPaddingRectRoot;

        } else {
            // gBCR coordinates enclose padding, and leave out margin. That is perfect for scrolling because
            //
            // - padding scrolls (ie,o it is part of the scrollable area, and gBCR puts it inside)
            // - margin doesn't scroll (ie, it pushes the scrollable area to another position, and gBCR records that)
            //
            // Borders, however, don't scroll, so they are not part of the scrollable area, but gBCR puts them inside.
            //
            // (See http://jsbin.com/pivata/10 for an extensive test of gBCR behaviour.)

            containerPaddingRectRoot = getPaddingRectRoot( $container[0] );

            // Cache the calculations
            if ( cache ) cache.containerPaddingRectRoot = containerPaddingRectRoot;
        }

        return {
            top: rect.top - containerPaddingRectRoot.top,
            bottom: rect.bottom - containerPaddingRectRoot.top,
            left: rect.left - containerPaddingRectRoot.left,
            right: rect.right - containerPaddingRectRoot.left
        };
    }

    /**
     * Calculates the rect of the content-box. Similar to getBoundingClientRect, but excludes padding and borders - and
     * is much slower.
     *
     * @param   {HTMLElement} elem
     * @returns {ClientRect}
     */
    function getContentRect( elem ) {

        var rect = elem.getBoundingClientRect(),
            props = getCss( elem, [
                "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth",
                "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"
            ], { toFloat: true } );

        return {
            top: rect.top + props.paddingTop + props.borderTopWidth,
            right: rect.right - ( props.paddingRight + props.borderRightWidth ),
            bottom: rect.bottom - ( props.paddingBottom + props.borderBottomWidth ),
            left: rect.left + props.paddingLeft + props.borderLeftWidth
        };
    }

    /**
     * Returns the top, left coordinates of the rect of the padding box (offset box).
     *
     * The coordinates match those of getBoundingClientRect, but exclude the borders.
     *
     * Does not care about bottom, right coordinates, in order to speed up the process.
     *
     * @param   {HTMLElement} elem
     * @returns {{ top: number, left: number }}
     */
    function getPaddingRectRoot( elem ) {

        var rect = elem.getBoundingClientRect(),
            props = getCss( elem, [
                "borderTopWidth", "borderLeftWidth"
            ], { toFloat: true } );

        return {
            top: rect.top + props.borderTopWidth,
            left: rect.left + props.borderLeftWidth
        };
    }

    /**
     * Returns the scroll bar state of the window. Helper for hasScrollbar().
     *
     * @param {Object} query
     * @param {Object} context
     *
     * @returns {{vertical: boolean, horizontal: boolean}}
     */
    function _windowHasScrollbar ( query, context ) {

        var windowInnerHeight, windowInnerWidth, windowProps,
            scrollbarWidth = $.scrollbarWidth(),
            result = {},
            doneX = ! query.getHorizontal,
            doneY = ! query.getVertical;

        // We may be able to take a shortcut. The window.innerWidth and -Height report the dimensions of the viewport
        // including scroll bars, and documentElement.clientWidth and -Height report them without scroll bars. That
        // gives the presence of a scroll bar away, as long as
        //
        // - the scroll bars actually take up space (width > 0)
        // - the browser supports window.innerWidth/Height (IE8, for instance, does not)
        // - the browser doesn't report a buggy value. FF has a bug which as only been fixed in FF25 (released 29 Oct
        //   2013). It manifests itself in a fictional return value of 10 for these properties. See
        //   * https://developer.mozilla.org/en-US/docs/Web/API/Window.innerWidth
        //   * https://developer.mozilla.org/en-US/docs/Web/API/Window.innerHeight
        //   * https://bugzilla.mozilla.org/show_bug.cgi?id=641188

        if ( query.getHorizontal && scrollbarWidth > 0 ) {
            windowInnerHeight = context.window.innerHeight;
            if ( windowInnerHeight > 10 ) {
                result.horizontal = windowInnerHeight > context.documentElement.clientHeight;
                doneX = true;
            }
        }

        if ( query.getVertical && scrollbarWidth > 0 ) {
            windowInnerWidth = context.window.innerWidth;
            if ( windowInnerWidth > 10 ) {
                result.vertical = windowInnerWidth > context.documentElement.clientWidth;
                doneY = true;
            }
        }

        if ( ! doneX || ! doneY ) {

            // Shortcut didn't work. We have to evaluate overflow settings, window and document size.

            windowProps = _getViewportOverflows( query, context ).window;

            // Handle the trivial cases first: window set to overflow: scroll or to overflow: hidden.
            if ( ! doneX && windowProps.overflowScrollX ) result.horizontal = doneX = true;
            if ( ! doneY && windowProps.overflowScrollY ) result.vertical = doneY = true;

            if ( ! doneX && windowProps.overflowHiddenX ) {
                result.horizontal = false;
                doneX = true;
            }

            if ( ! doneY && windowProps.overflowHiddenY ) {
                result.vertical = false;
                doneY = true;
            }

            // Handle the remaining overflow: auto case
            //
            // (There is no actual overflow: visible case for the viewport, see getAppliedViewportOverflows.)
            if ( ! doneX ) result.horizontal = context.documentElement.clientWidth < $.documentWidth( context.document );
            if ( ! doneY ) result.vertical = context.documentElement.clientHeight < $.documentHeight( context.document );

        }

        return result;

    }

    /**
     * Returns the applied overflow for the viewport (documentElement) and body in an aggregated `{ window: ...,
     * body: ...}` hash. Helper for hasScrollbar().
     *
     * If we deal with window or body scroll bars, we always need the settings for both body and window (documentElement)
     * because they are interdependent. See getAppliedViewportOverflows().
     *
     * @param {Object} query
     * @param {Object} context
     * @returns {{window: AppliedOverflow, body: AppliedOverflow}}
     */
    function _getViewportOverflows ( query, context ) {
        var windowProps, bodyProps,
            overflowPropNames = [ "overflow"],
            bodyOverflowPropNames = [ "overflow" ];

        if ( query.getHorizontal ) {
            overflowPropNames.push( "overflowX" );
            bodyOverflowPropNames.push( "overflowX" );
        }
        if ( query.getVertical ) {
            overflowPropNames.push( "overflowY" );
            bodyOverflowPropNames.push( "overflowY" );
        }

        windowProps = getCss( context.documentElement, overflowPropNames, { toLowerCase: true } );
        bodyProps = getCss( context.body, bodyOverflowPropNames, { toLowerCase: true } );

        return getAppliedViewportOverflows( windowProps, bodyProps );
    }

    /**
     * Determines the effective overflow setting of an element, separately for each axis, based on the `overflow`,
     * `overflowX` and `overflowY` properties of the element which must be passed in as a hash.
     *
     * Returns a hash of the computed results for overflowX, overflowY. Also adds boolean status properties to the hash
     * if the createBooleans flag is set. These are properties for mere convenience. They signal if a particular
     * overflow type applies (e.g. overflowHiddenX = true/false).
     *
     * ATTN The method does not take the special relation of body and documentElement into account. That is handled by
     * the more specific getAppliedViewportOverflows() function.
     *
     * The effective overflow setting is established as follows:
     *
     * - If a computed value for `overflow(X/Y)` exists, it gets applied to the axis.
     * - If not, the computed value of the general `overflow` setting gets applied to the axis.
     * - If there is no computed value at all, the overflow default gets applied to the axis. The default is
     *   "visible" in seemingly every browser out there. Falling back to the default should never be necessary,
     *   though, because there always is a computed value.
     *
     * @param {Object}        props            hash of element properties (computed values)
     * @param {string}        props.overflow
     * @param {string}        props.overflowX
     * @param {string}        props.overflowY
     * @param {boolean=false} createBooleans   if true, create the full set of boolean status properties, e.g.
     *                                         overflowVisibleX (true/false), overflowHiddenY (true/false) etc
     * @returns {AppliedOverflow}              hash of the computed results: overflowX, overflowY, optional boolean
     *                                         status properties
     */
    function getAppliedOverflows ( props, createBooleans ) {
        var status = {};

        // Establish the applied overflow (e.g. overflowX: "scroll")
        status.overflowX = props.overflowX || props.overflow || "visible";
        status.overflowY = props.overflowY || props.overflow || "visible";

        // Create the derived boolean status properties (e.g overflowScrollX: true)
        if ( createBooleans ) {
            $.each( [ "Visible", "Auto", "Scroll", "Hidden" ], function ( index, type ) {
                var lcType = type.toLowerCase();
                status["overflow" + type + "X"] = status.overflowX === lcType;
                status["overflow" + type + "Y"] = status.overflowY === lcType;
            } );
        }

        return status;
    }

    /**
     * Determines the effective overflow setting of the viewport and body, separately for each axis, based on the
     * `overflow`, `overflowX` and `overflowY` properties of the documentElement and body which must be passed in as a
     * hash.
     *
     * Returns the results for viewport and body in an aggregated `{ window: ..., body: ...}` hash.
     *
     * For the basic resolution mechanism, see getAppliedOverflows(). When determining the effective overflow, the
     * peculiarities of viewport and body are taken into account:
     *
     * - Viewport and body overflows are interdependent. If the nominal viewport overflow for a given axis is "visible",
     *   the viewport inherits the body overflow for that axis, and the body overflow is set to "visible". Curiously,
     *   that transfer is _not_ reflected in the computed values, it just manifests in behaviour.
     *
     * - Once that is done, if the viewport overflow is still "visible" for an axis, it is effectively turned into
     *   "auto". Scroll bars appear when the content overflows the viewport (ie, "auto" behaviour). Hence, this function
     *   will indeed report "auto". Again, the transformation is only manifest in behaviour, not in the computed values.
     *
     * - In iOS, if the effective overflow setting of the viewport is "hidden", it is ignored and treated as "auto".
     *   Content can still overflow the viewport, and scroll bars appear as needed.
     *
     *   Now, the catch. This behaviour is impossible to feature-detect. The computed values are not at all affected by
     *   it, and the results reported eg. for clientHeight, offsetHeight, scrollHeight of body and documentElement do
     *   not differ between Safari on iOS and, say, Chrome on the desktop. The numbers don't give the behaviour away.
     *
     *   So we have to resort to browser sniffing here. It sucks, but there is literally no other option.
     *
     * NB Additional status properties (see getAppliedOverflows) are always generated here.
     *
     * @param {Object} documentElementProps            hash of documentElement properties (computed values)
     * @param {string} documentElementProps.overflow
     * @param {string} documentElementProps.overflowX
     * @param {string} documentElementProps.overflowY
     *
     * @param {Object} bodyProps                       hash of body properties (computed values)
     * @param {string} bodyProps.overflow
     * @param {string} bodyProps.overflowX
     * @param {string} bodyProps.overflowY
     *
     * @returns {{window: AppliedOverflow, body: AppliedOverflow}}
     */
    function getAppliedViewportOverflows ( documentElementProps, bodyProps ) {
        var _window = getAppliedOverflows( documentElementProps, false ),
            body = getAppliedOverflows( bodyProps, false ),
            consolidated = { window: {}, body: {} };

        // Handle the interdependent relationship between body and window (documentElement) overflow
        if ( _window.overflowX === "visible" ) {
            // If the window overflow is set to "visible", body props get transferred to the window, body changes to
            // "visible". (Nothing really changes if both are set to "visible".)
            consolidated.body.overflowX = "visible";
            consolidated.window.overflowX = body.overflowX;
        } else {
            // No transfer of properties.
            // - If body overflow is "visible", it remains that way, and the window stays as it is.
            // - If body and window are set to properties other than "visible", they keep their divergent settings.
            consolidated.body.overflowX = body.overflowX;
            consolidated.window.overflowX = _window.overflowX;
        }

        // Repeat for overflowY
        if ( _window.overflowY === "visible" ) {
            consolidated.body.overflowY = "visible";
            consolidated.window.overflowY = body.overflowY;
        } else {
            consolidated.body.overflowY = body.overflowY;
            consolidated.window.overflowY = _window.overflowY;
        }

        // window.overflow(X/Y): "visible" actually means "auto" because scroll bars appear as needed; transform
        if ( consolidated.window.overflowX === "visible" ) consolidated.window.overflowX = "auto";
        if ( consolidated.window.overflowY === "visible" ) consolidated.window.overflowY = "auto";

        // In iOS, window.overflow(X/Y): "hidden" actually means "auto"; transform
        if ( isIOS() ) {
            if ( consolidated.window.overflowX === "hidden" ) consolidated.window.overflowX = "auto";
            if ( consolidated.window.overflowY === "hidden" ) consolidated.window.overflowY = "auto";
        }

        // Add the boolean status properties to the result
        consolidated.window = getAppliedOverflows( consolidated.window, true );
        consolidated.body = getAppliedOverflows( consolidated.body, true );

        return consolidated;
    }

    /**
     * Establishes the container and returns it in a jQuery wrapper.
     *
     * Resolves and normalizes the input, which may be a document, HTMLElement, window, or selector string. Corrects
     * likely mistakes, such as passing in a document or an iframe, rather than the corresponding window.
     *
     * @param {Window|Document|HTMLElement|HTMLIFrameElement|jQuery|string} container
     * @returns {jQuery}
     */
    function wrapContainer ( container ) {
        var $container,
            isJquery = container instanceof $;

        if ( ! isJquery && ! $.isWindow( container ) && ! container.nodeType && ! isString( container ) ) throw new Error( 'Invalid container: not a window, node, jQuery object or selector string' );

        $container = isJquery ? container : container === root ? $root : $( container );

        if ( !$container.length ) throw new Error( 'Invalid container: empty jQuery object' );

        container = $container[0];

        if ( container.nodeType === 9 ) {
            // Document is passed in, transform to window
            $container = wrapContainer( container.defaultView || container.parentWindow );
        } else if ( container.nodeType === 1 && container.tagName.toLowerCase() === "iframe" ) {
            // IFrame element is passed in, transform to IFrame content window
            $container = wrapContainer( container.contentWindow );
        }

        // Check if the container matches the requirements
        if ( !$.isWindow( $container[0] ) && $container.css( "overflow" ) === "visible" ) throw new Error( 'Invalid container: is set to overflow:visible. Containers must have the ability to obscure some of their content, otherwise the in-view test is pointless. Containers must be set to overflow:scroll/auto/hide, or be a window (or document, or iframe, as proxies for a window)' );

        return $container;
    }

    /**
     * Checks if the element is a descendant of the container, and throws an error otherwise. Also checks the type of
     * the element (must indeed be an element node).
     *
     * For performance reasons, this check should *not* be run on every element in a set.
     *
     * @param {HTMLElement}                 elem
     * @param {Window|Document|HTMLElement} container
     */
    function checkHierarchy ( elem, container ) {

        var elemIsContained;

        if ( elem.nodeType !== 1 ) throw new Error( "Invalid node: is not an element" );

        if ( $.isWindow( container ) ) {
            elemIsContained = elem.ownerDocument && container === ( elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow );
        } else if ( container.nodeType === 9 ) {
            // We need a DOM element for this check, so we use the documentElement as a proxy if the container is a document.
            elemIsContained = $.contains( container.documentElement, elem );
        } else {
            elemIsContained = $.contains( container, elem );
        }

        if ( !elemIsContained ) throw new Error( "Invalid container: is not an ancestor of the element" );

    }

    /**
     * Spots likely option mistakes and throws appropriate errors.
     *
     * @param {Object} opts
     */
    function checkOptions ( opts ) {
        var isNum, isNumWithUnit;

        if ( opts.direction && !( opts.direction === 'vertical' || opts.direction === 'horizontal' || opts.direction === 'both' ) ) {
            throw new Error( 'Invalid option value: direction = "' + opts.direction + '"' );
        }

        if ( opts.box && !( opts.box === 'border-box' || opts.box === 'content-box' ) ) {
            throw new Error( 'Invalid option value: box = "' + opts.box + '"' );
        }

        if ( opts.tolerance !== undefined ) {
            isNum = isNumber( opts.tolerance );
            isNumWithUnit = isString( opts.tolerance ) && ( /^[+-]?\d*\.?\d+(px|%)?$/.test( opts.tolerance ) );
            if ( ! ( isNum || isNumWithUnit ) ) throw new Error( 'Invalid option value: tolerance = "' + opts.tolerance + '"' );
        }

    }

    /**
     * Gets the width of a jQuery-wrapped container, excluding scroll bars. Also supports quirks mode for window
     * containers, unlike jQuery's $( window ).width(). Makes use of caching if a cache object is provided.
     *
     * @param   {jQuery}  $container
     * @param   {boolean} isWindow    required to speed up the process
     * @param   {Object}  [cache]
     * @returns {number}
     */
    function getNetContainerWidth ( $container, isWindow, cache ) {
        var width;

        if ( cache && cache.netContainerWidth !== undefined ) {
            width = cache.netContainerWidth;
        } else {
            width = isWindow ?
                    getWindowDimension( $container, "Width" ) :
                    $container.innerWidth() - getContainerScrollbarWidths( $container, cache ).vertical;

            if ( cache ) cache.netContainerWidth = width;
        }

        return width;
    }

    /**
     * Gets the height of a jQuery-wrapped container, excluding scroll bars. Also supports quirks mode for window
     * containers, unlike jQuery's $( window ).height(). Makes use of caching if a cache object is provided.
     *
     * @param   {jQuery}  $container
     * @param   {boolean} isWindow    required to speed up the process
     * @param   {Object}  [cache]
     * @returns {number}
     */
    function getNetContainerHeight ( $container, isWindow, cache ) {
        var height;

        if ( cache && cache.netContainerHeight !== undefined ) {
            height = cache.netContainerHeight;
        } else {
            height = isWindow ?
                     getWindowDimension( $container, "Height" ) :
                     $container.innerHeight() - getContainerScrollbarWidths( $container, cache ).horizontal;

            if ( cache ) cache.netContainerHeight = height;
        }

        return height;
    }

    /**
     * Gets the effective scroll bar widths of a given container. Makes use of caching if a cache object is provided.
     *
     * @param   {jQuery} $container
     * @param   {Object} [cache]
     * @returns {Object}
     */
    function getContainerScrollbarWidths ( $container, cache ) {
        var containerScrollbarWidths;

        if ( cache && cache.containerScrollbarWidths ) {
            containerScrollbarWidths = cache.containerScrollbarWidths;
        } else {
            containerScrollbarWidths = effectiveScrollbarWith( $container );
            if ( cache ) cache.containerScrollbarWidths = containerScrollbarWidths;
        }

        return containerScrollbarWidths;
    }

    /**
     * Gets the width or height of a jQuery-wrapped window. Use it instead of $container.width(). Supports quirks mode,
     * unlike jQuery.
     *
     * Window dimensions are calculated as in Zakas, Professional Javascript (2012), p. 404. The standards mode part of
     * it is the same as in jQuery, too.
     *
     * @param {jQuery} $window
     * @param {string} dimension  "Width" or "Height" (capitalized!)
     * @returns {number}
     */
    function getWindowDimension ( $window, dimension ) {
        var doc = $window[0].document,
            property = "client" + dimension;

        return doc.compatMode === "BackCompat" ? doc.body[property] : doc.documentElement[property];
    }

    /**
     * Returns the computed style for a property, or an array of properties, as a hash.
     *
     * Building a CSS properties hash this way can be significantly faster than the more convenient, conventional jQuery
     * approach, $( elem ).css( propertiesArray ).
     *
     * ATTN
     * ====
     *
     * We are using an internal jQuery API here: $.css(). The current signature was introduced in jQuery 1.9.0. It may
     * break without warning with any change of the minor version.
     *
     * For that reason, the $.css API is monitored by the tests in api.jquery.css.spec.js which verify that it works as
     * expected.
     *
     * @param {HTMLElement}     elem
     * @param {string|string[]} properties
     * @param {Object}          [opts]
     * @param {boolean}         [opts.toLowerCase=false]  ensures return values in lower case
     * @param {boolean}         [opts.toFloat=false]      converts return values to numbers, using parseFloat
     *
     * @returns {Object}        property names and their values
     */
    function getCss ( elem, properties, opts ) {
        var i, length, name,
            props = {},
            _window = ( elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow ),
            computedStyles = _useGetComputedStyle ? _window.getComputedStyle( elem, null ) : elem.currentStyle;

        opts || ( opts = {} );

        if ( ! $.isArray( properties ) ) properties = [ properties ];
        length = properties.length;

        for ( i = 0; i < length; i++ ) {
            name = properties[i];
            props[name] = $.css( elem, name, false, computedStyles );
            if ( opts.toLowerCase && props[name] && props[name].toLowerCase ) props[name] = props[name].toLowerCase();
            if ( opts.toFloat ) props[name] = parseFloat( props[name] );
        }

        return props;
    }

    /**
     * Returns the bounding client rect, including width and height properties. Ensures compatibility with IE8, which
     * supports getBoundingClientRect but doesn't calculate width and height.
     *
     * Use only when width and height are actually needed.
     *
     * Will be removed when IE8 support is dropped entirely.
     *
     * @param   {HTMLElement} elem
     * @returns {ClientRect}
     */
    function getBoundingClientRectCompat ( elem ) {
        var elemRect = elem.getBoundingClientRect();

        if ( elemRect.width === undefined || elemRect.height === undefined ) {
            // Fix for IE8
            elemRect = {
                top: elemRect.top,
                left: elemRect.left,
                bottom: elemRect.bottom,
                right: elemRect.right,
                width:  elemRect.right - elemRect.left,
                height: elemRect.bottom - elemRect.top
            };
        }

        return elemRect;
    }

    /**
     * Detects if the browser is on iOS. Works for Safari as well as other browsers, say, Chrome on iOS.
     *
     * Required for some iOS behaviour which can't be feature-detected in any way.
     *
     * @returns {boolean}
     */
    function isIOS () {
        if ( _isIOS === undefined ) _isIOS = (/iPad|iPhone|iPod/g).test( navigator.userAgent );
        return _isIOS;
    }

    /**
     * Calls parseFloat on each value. Useful for removing units from numeric values.
     *
     * @param   {Object} object
     * @returns {Object}
     */
    function toFloat ( object ) {
        var transformed =  {};

        $.map( object, function ( value, key ) {
            transformed[key] =  parseFloat( value );
        } );

        return transformed;
    }

    /**
     * Returns whether or not a value is of type number. Also rejects NaN as a number.
     *
     * NB This is not the same as $.isNumeric because $.isNumeric( "3" ) is true while isNumber( "3" ) is false.
     *
     * @param {*} value
     * @returns {boolean}
     */
    function isNumber ( value ) {
        // Done as in the Lodash compatibility build, but rejecting NaN as a number.
        var isNumeric = typeof value === 'number' || value && typeof value === 'object' && Object.prototype.toString.call( value ) === '[object Number]' || false;

        // Reject NaN before returning
        return isNumeric && value === +value;
    }

    function isString ( value ) {
        // Done as in the Lodash compatibility build
        return typeof value === 'string' || value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]' || false;
    }

    /**
     * Custom types.
     *
     * For easier documentation and type inference.
     */

    /**
     * @name  AppliedOverflow
     * @type  {Object}
     *
     * @property {string}  overflowX
     * @property {string}  overflowY
     * @property {boolean} overflowVisibleX
     * @property {boolean} overflowVisibleY
     * @property {boolean} overflowAutoX
     * @property {boolean} overflowAutoY
     * @property {boolean} overflowScrollX
     * @property {boolean} overflowScrollY
     * @property {boolean} overflowHiddenX
     * @property {boolean} overflowHiddenY
     */


}( typeof jQuery !== "undefined" ? jQuery : $ ));;/*! http://mths.be/placeholder v2.0.8 by @mathias */
;(function(window, document, $) {

	// Opera Mini v7 doesn’t support placeholder although its DOM seems to indicate so
	var isOperaMini = Object.prototype.toString.call(window.operamini) == '[object OperaMini]';
	var isInputSupported = 'placeholder' in document.createElement('input') && !isOperaMini;
	var isTextareaSupported = 'placeholder' in document.createElement('textarea') && !isOperaMini;
	var prototype = $.fn;
	var valHooks = $.valHooks;
	var propHooks = $.propHooks;
	var hooks;
	var placeholder;

	if (isInputSupported && isTextareaSupported) {

		placeholder = prototype.placeholder = function() {
			return this;
		};

		placeholder.input = placeholder.textarea = true;

	} else {

		placeholder = prototype.placeholder = function() {
			var $this = this;
			$this
				.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
				.not('.placeholder')
				.bind({
					'focus.placeholder': clearPlaceholder,
					'blur.placeholder': setPlaceholder
				})
				.data('placeholder-enabled', true)
				.trigger('blur.placeholder');
			return $this;
		};

		placeholder.input = isInputSupported;
		placeholder.textarea = isTextareaSupported;

		hooks = {
			'get': function(element) {
				var $element = $(element);

				var $passwordInput = $element.data('placeholder-password');
				if ($passwordInput) {
					return $passwordInput[0].value;
				}

				return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
			},
			'set': function(element, value) {
				var $element = $(element);

				var $passwordInput = $element.data('placeholder-password');
				if ($passwordInput) {
					return $passwordInput[0].value = value;
				}

				if (!$element.data('placeholder-enabled')) {
					return element.value = value;
				}
				if (value == '') {
					element.value = value;
					// Issue #56: Setting the placeholder causes problems if the element continues to have focus.
					if (element != safeActiveElement()) {
						// We can't use `triggerHandler` here because of dummy text/password inputs :(
						setPlaceholder.call(element);
					}
				} else if ($element.hasClass('placeholder')) {
					clearPlaceholder.call(element, true, value) || (element.value = value);
				} else {
					element.value = value;
				}
				// `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
				return $element;
			}
		};

		if (!isInputSupported) {
			valHooks.input = hooks;
			propHooks.value = hooks;
		}
		if (!isTextareaSupported) {
			valHooks.textarea = hooks;
			propHooks.value = hooks;
		}

		$(function() {
			// Look for forms
			$(document).delegate('form', 'submit.placeholder', function() {
				// Clear the placeholder values so they don't get submitted
				var $inputs = $('.placeholder', this).each(clearPlaceholder);
				setTimeout(function() {
					$inputs.each(setPlaceholder);
				}, 10);
			});
		});

		// Clear placeholder values upon page reload
		$(window).bind('beforeunload.placeholder', function() {
			$('.placeholder').each(function() {
				this.value = '';
			});
		});

	}

	function args(elem) {
		// Return an object of element attributes
		var newAttrs = {};
		var rinlinejQuery = /^jQuery\d+$/;
		$.each(elem.attributes, function(i, attr) {
			if (attr.specified && !rinlinejQuery.test(attr.name)) {
				newAttrs[attr.name] = attr.value;
			}
		});
		return newAttrs;
	}

	function clearPlaceholder(event, value) {
		var input = this;
		var $input = $(input);
		if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
			if ($input.data('placeholder-password')) {
				$input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
				// If `clearPlaceholder` was called from `$.valHooks.input.set`
				if (event === true) {
					return $input[0].value = value;
				}
				$input.focus();
			} else {
				input.value = '';
				$input.removeClass('placeholder');
				input == safeActiveElement() && input.select();
			}
		}
	}

	function setPlaceholder() {
		var $replacement;
		var input = this;
		var $input = $(input);
		var id = this.id;
		if (input.value == '') {
			if (input.type == 'password') {
				if (!$input.data('placeholder-textinput')) {
					try {
						$replacement = $input.clone().attr({ 'type': 'text' });
					} catch(e) {
						$replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
					}
					$replacement
						.removeAttr('name')
						.data({
							'placeholder-password': $input,
							'placeholder-id': id
						})
						.bind('focus.placeholder', clearPlaceholder);
					$input
						.data({
							'placeholder-textinput': $replacement,
							'placeholder-id': id
						})
						.before($replacement);
				}
				$input = $input.removeAttr('id').hide().prev().attr('id', id).show();
				// Note: `$input[0] != input` now!
			}
			$input.addClass('placeholder');
			$input[0].value = $input.attr('placeholder');
		} else {
			$input.removeClass('placeholder');
		}
	}

	function safeActiveElement() {
		// Avoid IE9 `document.activeElement` of death
		// https://github.com/mathiasbynens/jquery-placeholder/pull/99
		try {
			return document.activeElement;
		} catch (exception) {}
	}

}(this, document, jQuery));
;/*!
 *         ,/
 *       ,'/
 *     ,' /
 *   ,'  /_____,
 * .'____    ,'
 *      /  ,'
 *     / ,'
 *    /,'
 *   /'
 *
 * Selectric Ϟ v1.6.7 - http://lcdsantos.github.io/jQuery-Selectric/
 *
 * Copyright (c) 2014 Leonardo Santos; Dual licensed: MIT/GPL
 *
 */

;(function ($) {
  var pluginName = 'selectric',
      // Replace diacritics
      _replaceDiacritics = function(s) {
        // /[\340-\346]/g, // a
        // /[\350-\353]/g, // e
        // /[\354-\357]/g, // i
        // /[\362-\370]/g, // o
        // /[\371-\374]/g, // u
        // /[\361]/g, // n
        // /[\347]/g, // c
        // /[\377]/g // y
        var k, d = '40-46 50-53 54-57 62-70 71-74 61 47 77'.replace(/\d+/g, '\\3$&').split(' ');

        for (k in d) {
          if (!d.hasOwnProperty(k))
            return;
          s = s.toLowerCase().replace(RegExp('[' + d[k] + ']', 'g'), 'aeiouncy'.charAt(k));
        }

        return s;
      },
      // https://gist.github.com/atesgoral/984375
      format = function(f){var a=arguments;return(""+f).replace(/{(\d+|(\w+))}/g,function(s,i,p){return p&&a[1]?a[1][p]:a[i]})},
      init = function(element, options) {
        options = $.extend(true, {
              onOpen: $.noop,
              onClose: $.noop,
              onChange: $.noop,
              maxHeight: 300,
              keySearchTimeout: 500,
              arrowButtonMarkup: '<b class="button">&nbsp;</b>',
              disableOnMobile: true,
              openOnHover: false,
              expandToItemText: false,
              responsive: false,
              customClass: {
                prefix: 'selectric',
                postfixes: 'Input Items Open Disabled TempShow HideSelect Wrapper Hover Responsive',
                camelCase: true
              },
              optionsItemBuilder: '{text}' // function(itemData, element, index)
            }, options);
        var
            customClass = options.customClass,
            postfixes = customClass.postfixes.split(' '),
            arrClasses = [],
            currPostfix;

        if (options.disableOnMobile && /android|ip(hone|od|ad)/i.test(navigator.userAgent)) return;

        // generate classNames for elements
        while ((currPostfix = postfixes.shift())){
          var c = customClass.prefix + currPostfix;
          arrClasses.push(customClass.camelCase ? c : c.replace(/([A-Z])/g, "-$&").toLowerCase());
        }

        var $original = $(element),
            _input = $('<input type="text" class="' + arrClasses[0] + '"/>'),
            $wrapper = $('<div class="' + customClass.prefix + '"><p class="label"/>' + options.arrowButtonMarkup + '</div>'),
            $items = $('<div class="' + arrClasses[1] + '" tabindex="-1"></div>'),
            $outerWrapper = $original.data(pluginName, true).wrap('<div>').parent().append($wrapper.add($items).add(_input)),
            selectItems = [],
            isOpen,
            $label = $('.label', $wrapper),
            $li,
            bindSufix = '.sl',
            $doc = $(document),
            $win = $(window),
            clickBind = 'click' + bindSufix,
            resetStr,
            classOpen = arrClasses[2],
            classDisabled = arrClasses[3],
            tempClass = arrClasses[4],
            selectStr = 'selected',
            selected,
            currValue,
            itemsHeight,
            closeTimer,
            finalWidth,
            optionsLength,
            inputEvt = 'oninput' in _input[0] ? 'input' : 'keyup';

        $original.wrap('<div class="' + arrClasses[5] + '">');

        function _populate() {
          var $options = $original.children(),
              _$li = '<ul>',
              selectedIndex = $options.filter(':' + selectStr).index();

          currValue = (selected = ~selectedIndex ? selectedIndex : 0);

          if ( optionsLength = $options.length ) {
            // Build options markup
            $options.each(function(i){
              var $elm = $(this),
                  optionText = $elm.html(),
                  selectDisabled = $elm.prop('disabled'),
                  itemBuilder = options.optionsItemBuilder;

              selectItems[i] = {
                value: $elm.val(),
                text: optionText,
                slug: _replaceDiacritics(optionText),
                disabled: selectDisabled
              };

              _$li += format('<li class="{1}">{2}</li>',
                        $.trim([i == currValue ? selectStr : '', i == optionsLength - 1 ? 'last' : '', selectDisabled ? 'disabled' : ''].join(' ')),
                        $.isFunction(itemBuilder) ? itemBuilder(selectItems[i], $elm, i) : format(itemBuilder, selectItems[i])
                      );
            });

            $items.html(_$li + '</ul>');

            $label.html(selectItems[currValue].text);
          }

          $wrapper.add($original).off(bindSufix);
          $outerWrapper.data(pluginName, true).prop('class', [arrClasses[6], $original.prop('class'), classDisabled, options.responsive ? arrClasses[8] : ''].join(' '));

          if ( !$original.prop('disabled') ){
            // Not disabled, so... Removing disabled class and bind hover
            $outerWrapper.removeClass(classDisabled).hover(function(){
              $(this).toggleClass(arrClasses[7]);
            });

            // Click on label and :focus on original select will open the options box
            options.openOnHover && $wrapper.on('mouseenter' + bindSufix, _open);

            // Toggle open/close
            $wrapper.on(clickBind, function(e){
              isOpen ? _close() : _open(e);
            });

            function _handleSystemKeys(e){
              // Tab / Enter / ESC
              if ( /^(9|13|27)$/.test(e.keyCode || e.which) ) {
                e.stopPropagation();
                _select(selected, true);
              }
            }

            _input.prop('disabled', false).off().on({
              keypress: _handleSystemKeys,
              keydown: function(e){
                _handleSystemKeys(e);

                // Clear search
                clearTimeout(resetStr);
                resetStr = setTimeout(function(){
                  _input.val('');
                }, options.keySearchTimeout);

                var key = e.keyCode || e.which;

                // If it's a directional key
                // 37 => Left
                // 38 => Up
                // 39 => Right
                // 40 => Down
                if ( key > 36 && key < 41 )
                  _select( key < 39 ? previousEnabledItem() : nextEnabledItem() );
              },
              focusin: function(e){
                // Stupid, but necessary... Prevent the flicker when
                // focusing out and back again in the browser window
                _input.one('blur', function(){
                  _input.blur();
                });

                isOpen || _open(e);
              }
            }).on(inputEvt, function(){
              if ( _input.val().length ){
                // Search in select options
                $.each(selectItems, function(i, elm){
                  if ( RegExp('^' + _input.val(), 'i').test(elm.slug) && !elm.disabled ){
                    _select(i);
                    return false;
                  }
                });
              }
            });

            // Remove styles from items box
            // Fix incorrect height when refreshed is triggered with fewer options
            $li = $('li', $items.removeAttr('style')).click(function(){
              // The second parameter is to close the box after click
              _select($(this).index(), true);

              // Chrome doesn't close options box if select is wrapped with a label
              // We need to 'return false' to avoid that
              return false;
            });
          } else
            _input.prop('disabled', true);
        }

        _populate();

        function _calculateOptionsDimensions(){
          var visibleParent = $items.closest(':visible').children(':hidden'),
              maxHeight = options.maxHeight;

          // Calculate options box height
          // Set a temporary class on the hidden parent of the element
          visibleParent.addClass(tempClass);

          var itemsWidth = $items.outerWidth(),
              wrapperWidth = $wrapper.outerWidth() - (itemsWidth - $items.width());

          // Set the dimensions, minimum is wrapper width, expand for long items if option is true
          if ( !options.expandToItemText || wrapperWidth > itemsWidth )
            finalWidth = wrapperWidth;
          else {
            // Make sure the scrollbar width is included
            $items.css('overflow', 'scroll');

            // Set a really long width for $outerWrapper
            $outerWrapper.width(9e4);
            finalWidth = $items.width();
            // Set scroll bar to auto
            $items.css('overflow', '');
            $outerWrapper.width('');
          }

          $items.width(finalWidth).height() > maxHeight && $items.height(maxHeight);

          // Remove the temporary class
          visibleParent.removeClass(tempClass);
        }

        // Open the select options box
        function _open(e) {
          e.preventDefault();
          e.stopPropagation();

          _calculateOptionsDimensions();

          // Find any other opened instances of select and close it
          $('.' + classOpen).removeClass(classOpen);

          isOpen = true;
          itemsHeight = $items.outerHeight();

          // Give dummy input focus
          _input.val('').is(':focus') || _input.focus();

          $doc.on(clickBind, _close).on('scroll' + bindSufix, _isInViewport);
          _isInViewport();

          // Delay close effect when openOnHover is true
          if (options.openOnHover){
            clearTimeout(closeTimer);
            $outerWrapper.one('mouseleave' + bindSufix, function(){
              closeTimer = setTimeout(_close, 500);
            });
          }

          // Toggle options box visibility
          $outerWrapper.addClass(classOpen);
          _detectItemVisibility(selected);

          options.onOpen(element);
        }

        // Detect is the options box is inside the window
        function _isInViewport() {
            _calculateOptionsDimensions();
            $items.css('top', ($outerWrapper.offset().top + $outerWrapper.outerHeight() + itemsHeight > $win.scrollTop() + $win.height()) ? -itemsHeight : '');
        }

        // Close the select options box
        function _close(e) {
          if ( !e && currValue != selected ){
            var text = selectItems[selected].text;

            // Apply changed value to original select
            $original
              .prop('selectedIndex', currValue = selected)
              .data('value', text)
              .trigger('change', [text, currValue]);

            options.onChange(element);

            // Change label text
            $label.html(text);
          }

          // Remove click on document
          $doc.off(bindSufix);

          // Remove visible class to hide options box
          $outerWrapper.removeClass(classOpen);

          isOpen = false;

          options.onClose(element);
        }

        // Select option
        function _select(index, close) {
          // If element is disabled, can't select it
          if ( !selectItems[selected = index].disabled ){
            // If 'close' is false (default), the options box won't close after
            // each selected item, this is necessary for keyboard navigation
            $li.removeClass(selectStr).eq(index).addClass(selectStr);
            _detectItemVisibility(index);
            close && _close();
          }
        }

        // Detect if currently selected option is visible and scroll the options box to show it
        function _detectItemVisibility(index) {
          var liHeight = $li.eq(index).outerHeight(),
              liTop = $li[index].offsetTop,
              itemsScrollTop = $items.scrollTop(),
              scrollT = liTop + liHeight * 2;

          $items.scrollTop(
            scrollT > itemsScrollTop + itemsHeight ? scrollT - itemsHeight :
              liTop - liHeight < itemsScrollTop ? liTop - liHeight :
                itemsScrollTop
          );
        }

        function nextEnabledItem(next) {
          if ( selectItems[ next = (selected + 1) % optionsLength ].disabled )
            while ( selectItems[ next = (next + 1) % optionsLength ].disabled ){}

          return next;
        }

        function previousEnabledItem(previous) {
          if ( selectItems[ previous = (selected > 0 ? selected : optionsLength) - 1 ].disabled )
            while ( selectItems[ previous = (previous > 0 ? previous : optionsLength) - 1 ].disabled ){}

          return previous;
        }

        $original.on({
          refresh: _populate,
          destroy: function() {
            // Unbind and remove
            $items.add($wrapper).add(_input).remove();
            $original.removeData(pluginName).removeData('value').off(bindSufix + ' refresh destroy open close').unwrap().unwrap();
          },
          open: _open,
          close: _close
        });
      };

  // A really lightweight plugin wrapper around the constructor,
  // preventing against multiple instantiations
  $.fn[pluginName] = function(args, options) {
    return this.each(function() {
      if ( !$(this).data(pluginName ))
        init(this, args || options);
      else if ( ''+args === args )
        $(this).trigger(args);
    });
  };
}(jQuery));
;// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url https://raw.githubusercontent.com/google/closure-compiler/master/contrib/externs/maps/google_maps_api_v3.js
// ==/ClosureCompiler==

/**
 * @name MarkerClusterer for Google Maps v3
 * @version version 1.0
 * @author Luke Mahe
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of
 * markers.
 * <br/>
 * This is a v3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >v2 MarkerClusterer</a>.
 */

/**
 * @license
 * Copyright 2010 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A Marker Clusterer that clusters markers.
 *
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
 *   the cluster.
 * @param {Object=} opt_options support the following options:
 *     'gridSize': (number) The grid size of a cluster in pixels.
 *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
 *                cluster.
 *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
 *                    cluster is to zoom into it.
 *     'averageCenter': (boolean) Whether the center of each cluster should be
 *                      the average of all markers in the cluster.
 *     'minimumClusterSize': (number) The minimum number of markers to be in a
 *                           cluster before the markers are hidden and a count
 *                           is shown.
 *     'styles': (object) An object that has style properties:
 *       'url': (string) The image url.
 *       'height': (number) The image height.
 *       'width': (number) The image width.
 *       'anchor': (Array) The anchor position of the label text.
 *       'textColor': (string) The text color.
 *       'textSize': (number) The text size.
 *       'backgroundPosition': (string) The position of the backgound x, y.
 *       'iconAnchor': (Array) The anchor position of the icon x, y.
 * @constructor
 * @extends google.maps.OverlayView
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);
  this.map_ = map;

  /**
   * @type {Array.<google.maps.Marker>}
   * @private
   */
  this.markers_ = [];

  /**
   *  @type {Array.<Cluster>}
   */
  this.clusters_ = [];

  this.sizes = [53, 56, 66, 78, 90];

  /**
   * @private
   */
  this.styles_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.ready_ = false;

  var options = opt_options || {};

  /**
   * @type {number}
   * @private
   */
  this.gridSize_ = options['gridSize'] || 60;

  /**
   * @private
   */
  this.minClusterSize_ = options['minimumClusterSize'] || 2;


  /**
   * @type {?number}
   * @private
   */
  this.maxZoom_ = options['maxZoom'] || null;

  this.styles_ = options['styles'] || [];

  /**
   * @type {string}
   * @private
   */
  this.imagePath_ = options['imagePath'] ||
      this.MARKER_CLUSTER_IMAGE_PATH_;

  /**
   * @type {string}
   * @private
   */
  this.imageExtension_ = options['imageExtension'] ||
      this.MARKER_CLUSTER_IMAGE_EXTENSION_;

  /**
   * @type {boolean}
   * @private
   */
  this.zoomOnClick_ = true;

  if (options['zoomOnClick'] != undefined) {
    this.zoomOnClick_ = options['zoomOnClick'];
  }

  /**
   * @type {boolean}
   * @private
   */
  this.averageCenter_ = false;

  if (options['averageCenter'] != undefined) {
    this.averageCenter_ = options['averageCenter'];
  }

  this.setupStyles_();

  this.setMap(map);

  /**
   * @type {number}
   * @private
   */
  this.prevZoom_ = this.map_.getZoom();

  // Add the map event listeners
  var that = this;
  google.maps.event.addListener(this.map_, 'zoom_changed', function() {
    var zoom = that.map_.getZoom();

    if (that.prevZoom_ != zoom) {
      that.prevZoom_ = zoom;
      that.resetViewport();
    }
  });

  google.maps.event.addListener(this.map_, 'idle', function() {
    that.redraw();
  });

  // Finally, add the markers
  if (opt_markers && opt_markers.length) {
    this.addMarkers(opt_markers, false);
  }
}


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';


/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function(obj1, obj2) {
  return (function(object) {
    for (var property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function() {
  this.setReady_(true);
};

/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function() {};

/**
 * Sets up the styles object.
 *
 * @private
 */
MarkerClusterer.prototype.setupStyles_ = function() {
  if (this.styles_.length) {
    return;
  }

  for (var i = 0, size; size = this.sizes[i]; i++) {
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
      height: size,
      width: size
    });
  }
};

/**
 *  Fit the map to the bounds of the markers in the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function() {
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }

  this.map_.fitBounds(bounds);
};


/**
 *  Sets the styles.
 *
 *  @param {Object} styles The style to set.
 */
MarkerClusterer.prototype.setStyles = function(styles) {
  this.styles_ = styles;
};


/**
 *  Gets the styles.
 *
 *  @return {Object} The styles object.
 */
MarkerClusterer.prototype.getStyles = function() {
  return this.styles_;
};


/**
 * Whether zoom on click is set.
 *
 * @return {boolean} True if zoomOnClick_ is set.
 */
MarkerClusterer.prototype.isZoomOnClick = function() {
  return this.zoomOnClick_;
};

/**
 * Whether average center is set.
 *
 * @return {boolean} True if averageCenter_ is set.
 */
MarkerClusterer.prototype.isAverageCenter = function() {
  return this.averageCenter_;
};


/**
 *  Returns the array of markers in the clusterer.
 *
 *  @return {Array.<google.maps.Marker>} The markers.
 */
MarkerClusterer.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 *  Returns the number of markers in the clusterer
 *
 *  @return {Number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function() {
  return this.markers_.length;
};


/**
 *  Sets the max zoom for the clusterer.
 *
 *  @param {number} maxZoom The max zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Gets the max zoom for the clusterer.
 *
 *  @return {number} The max zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function() {
  return this.maxZoom_;
};


/**
 *  The function for calculating the cluster icon image.
 *
 *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
 *  @param {number} numStyles The number of styles available.
 *  @return {Object} A object properties: 'text' (string) and 'index' (number).
 *  @private
 */
MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
  var index = 0;
  var count = markers.length;
  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index
  };
};


/**
 * Set the calculator function.
 *
 * @param {function(Array, number)} calculator The function to set as the
 *     calculator. The function should return a object properties:
 *     'text' (string) and 'index' (number).
 *
 */
MarkerClusterer.prototype.setCalculator = function(calculator) {
  this.calculator_ = calculator;
};


/**
 * Get the calculator function.
 *
 * @return {function(Array, number)} the calculator function.
 */
MarkerClusterer.prototype.getCalculator = function() {
  return this.calculator_;
};


/**
 * Add an array of markers to the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
  for (var i = 0, marker; marker = markers[i]; i++) {
    this.pushMarkerTo_(marker);
  }
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
  marker.isAdded = false;
  if (marker['draggable']) {
    // If the marker is draggable add a listener so we update the clusters on
    // the drag end.
    var that = this;
    google.maps.event.addListener(marker, 'dragend', function() {
      marker.isAdded = false;
      that.repaint();
    });
  }
  this.markers_.push(marker);
};


/**
 * Adds a marker to the clusterer and redraws if needed.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Removes a marker and returns true if removed, false if not
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 * @private
 */
MarkerClusterer.prototype.removeMarker_ = function(marker) {
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        index = i;
        break;
      }
    }
  }

  if (index == -1) {
    // Marker is not in our list of markers.
    return false;
  }

  marker.setMap(null);

  this.markers_.splice(index, 1);

  return true;
};


/**
 * Remove a marker from the cluster.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 * @return {boolean} True if the marker was removed.
 */
MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  } else {
   return false;
  }
};


/**
 * Removes an array of markers from the cluster.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 */
MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
  var removed = false;

  for (var i = 0, marker; marker = markers[i]; i++) {
    var r = this.removeMarker_(marker);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  }
};


/**
 * Sets the clusterer's ready state.
 *
 * @param {boolean} ready The state.
 * @private
 */
MarkerClusterer.prototype.setReady_ = function(ready) {
  if (!this.ready_) {
    this.ready_ = ready;
    this.createClusters_();
  }
};


/**
 * Returns the number of clusters in the clusterer.
 *
 * @return {number} The number of clusters.
 */
MarkerClusterer.prototype.getTotalClusters = function() {
  return this.clusters_.length;
};


/**
 * Returns the google map that the clusterer is associated with.
 *
 * @return {google.maps.Map} The map.
 */
MarkerClusterer.prototype.getMap = function() {
  return this.map_;
};


/**
 * Sets the google map that the clusterer is associated with.
 *
 * @param {google.maps.Map} map The map.
 */
MarkerClusterer.prototype.setMap = function(map) {
  this.map_ = map;
};


/**
 * Returns the size of the grid.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function() {
  return this.gridSize_;
};


/**
 * Sets the size of the grid.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setGridSize = function(size) {
  this.gridSize_ = size;
};


/**
 * Returns the min cluster size.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getMinClusterSize = function() {
  return this.minClusterSize_;
};

/**
 * Sets the min cluster size.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setMinClusterSize = function(size) {
  this.minClusterSize_ = size;
};


/**
 * Extends a bounds object by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 */
MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Determins if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 * @private
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Clears all clusters and markers from the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function() {
  this.resetViewport(true);

  // Set the markers a empty array.
  this.markers_ = [];
};


/**
 * Clears all existing clusters and recreates them.
 * @param {boolean} opt_hide To also hide the marker.
 */
MarkerClusterer.prototype.resetViewport = function(opt_hide) {
  // Remove all the clusters
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    cluster.remove();
  }

  // Reset the markers to not be added and to be invisible.
  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }

  this.clusters_ = [];
};

/**
 *
 */
MarkerClusterer.prototype.repaint = function() {
  var oldClusters = this.clusters_.slice();
  this.clusters_.length = 0;
  this.resetViewport();
  this.redraw();

  // Remove the old clusters.
  // Do it in a timeout so the other clusters have been drawn first.
  window.setTimeout(function() {
    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
      cluster.remove();
    }
  }, 0);
};


/**
 * Redraws the clusters.
 */
MarkerClusterer.prototype.redraw = function() {
  this.createClusters_();
};


/**
 * Calculates the distance between two latlng locations in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @private
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
  if (!p1 || !p2) {
    return 0;
  }

  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Add a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  var pos = marker.getPosition();
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    var center = cluster.getCenter();
    if (center) {
      var d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    var cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters.
 *
 * @private
 */
MarkerClusterer.prototype.createClusters_ = function() {
  if (!this.ready_) {
    return;
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
      this.map_.getBounds().getNorthEast());
  var bounds = this.getExtendedBounds(mapBounds);

  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      this.addToClosestCluster_(marker);
    }
  }
};


/**
 * A cluster that contains markers.
 *
 * @param {MarkerClusterer} markerClusterer The markerclusterer that this
 *     cluster is associated with.
 * @constructor
 * @ignore
 */
function Cluster(markerClusterer) {
  this.markerClusterer_ = markerClusterer;
  this.map_ = markerClusterer.getMap();
  this.gridSize_ = markerClusterer.getGridSize();
  this.minClusterSize_ = markerClusterer.getMinClusterSize();
  this.averageCenter_ = markerClusterer.isAverageCenter();
  this.center_ = null;
  this.markers_ = [];
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
      markerClusterer.getGridSize());
}

/**
 * Determins if a marker is already added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker is already added.
 */
Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) != -1;
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        return true;
      }
    }
  }
  return false;
};


/**
 * Add a marker the cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @return {boolean} True if the marker was added.
 */
Cluster.prototype.addMarker = function(marker) {
  if (this.isMarkerAlreadyAdded(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  var len = this.markers_.length;
  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {
    // Min cluster size not reached so show the marker.
    marker.setMap(this.map_);
  }

  if (len == this.minClusterSize_) {
    // Hide the markers that were showing.
    for (var i = 0; i < len; i++) {
      this.markers_[i].setMap(null);
    }
  }

  if (len >= this.minClusterSize_) {
    marker.setMap(null);
  }

  this.updateIcon();
  return true;
};


/**
 * Returns the marker clusterer that the cluster is associated with.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 */
Cluster.prototype.getMarkerClusterer = function() {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 */
Cluster.prototype.getBounds = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster
 */
Cluster.prototype.remove = function() {
  this.clusterIcon_.remove();
  this.markers_.length = 0;
  delete this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {number} The cluster center.
 */
Cluster.prototype.getSize = function() {
  return this.markers_.length;
};


/**
 * Returns the center of the cluster.
 *
 * @return {Array.<google.maps.Marker>} The cluster center.
 */
Cluster.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {google.maps.LatLng} The cluster center.
 */
Cluster.prototype.getCenter = function() {
  return this.center_;
};


/**
 * Calculated the extended bounds of the cluster with the grid.
 *
 * @private
 */
Cluster.prototype.calculateBounds_ = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Determines if a marker lies in the clusters bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 */
Cluster.prototype.isMarkerInClusterBounds = function(marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Returns the map that the cluster is associated with.
 *
 * @return {google.maps.Map} The map.
 */
Cluster.prototype.getMap = function() {
  return this.map_;
};


/**
 * Updates the cluster icon
 */
Cluster.prototype.updateIcon = function() {
  var zoom = this.map_.getZoom();
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz && zoom > mz) {
    // The zoom is greater than our max zoom so show all the markers in cluster.
    for (var i = 0, marker; marker = this.markers_[i]; i++) {
      marker.setMap(this.map_);
    }
    return;
  }

  if (this.markers_.length < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.setSums(sums);
  this.clusterIcon_.show();
};


/**
 * A cluster icon
 *
 * @param {Cluster} cluster The cluster to be associated with.
 * @param {Object} styles An object that has style properties:
 *     'url': (string) The image url.
 *     'height': (number) The image height.
 *     'width': (number) The image width.
 *     'anchor': (Array) The anchor position of the label text.
 *     'textColor': (string) The text color.
 *     'textSize': (number) The text size.
 *     'backgroundPosition: (string) The background postition x, y.
 * @param {number=} opt_padding Optional padding to apply to the cluster icon.
 * @constructor
 * @extends google.maps.OverlayView
 * @ignore
 */
function ClusterIcon(cluster, styles, opt_padding) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.styles_ = styles;
  this.padding_ = opt_padding || 0;
  this.cluster_ = cluster;
  this.center_ = null;
  this.map_ = cluster.getMap();
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(this.map_);
}


/**
 * Triggers the clusterclick event and zoom's if the option is set.
 *
 * @param {google.maps.MouseEvent} event The event to propagate
 */
ClusterIcon.prototype.triggerClusterClick = function(event) {
  var markerClusterer = this.cluster_.getMarkerClusterer();

  // Trigger the clusterclick event.
  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_, event);

  if (markerClusterer.isZoomOnClick()) {
    // Zoom into the cluster.
    this.map_.fitBounds(this.cluster_.getBounds());
  }
};


/**
 * Adding the cluster icon to the dom.
 * @ignore
 */
ClusterIcon.prototype.onAdd = function() {
  this.div_ = document.createElement('DIV');
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.innerHTML = this.sums_.text;
  }

  var panes = this.getPanes();
  panes.overlayMouseTarget.appendChild(this.div_);

  var that = this;
  var isDragging = false;
  google.maps.event.addDomListener(this.div_, 'click', function(event) {
    // Only perform click when not preceded by a drag
    if (!isDragging) {
      that.triggerClusterClick(event);
    }
  });
  google.maps.event.addDomListener(this.div_, 'mousedown', function() {
    isDragging = false;
  });
  google.maps.event.addDomListener(this.div_, 'mousemove', function() {
    isDragging = true;
  });
};


/**
 * Returns the position to place the div dending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 * @private
 */
ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);

  if (typeof this.iconAnchor_ === 'object' && this.iconAnchor_.length === 2) {
    pos.x -= this.iconAnchor_[0];
    pos.y -= this.iconAnchor_[1];
  } else {
    pos.x -= parseInt(this.width_ / 2, 10);
    pos.y -= parseInt(this.height_ / 2, 10);
  }
  return pos;
};


/**
 * Draw the icon.
 * @ignore
 */
ClusterIcon.prototype.draw = function() {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + 'px';
    this.div_.style.left = pos.x + 'px';
  }
};


/**
 * Hide the icon.
 */
ClusterIcon.prototype.hide = function() {
  if (this.div_) {
    this.div_.style.display = 'none';
  }
  this.visible_ = false;
};


/**
 * Position and show the icon.
 */
ClusterIcon.prototype.show = function() {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.style.display = '';
  }
  this.visible_ = true;
};


/**
 * Remove the icon from the map
 */
ClusterIcon.prototype.remove = function() {
  this.setMap(null);
};


/**
 * Implementation of the onRemove interface.
 * @ignore
 */
ClusterIcon.prototype.onRemove = function() {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Set the sums of the icon.
 *
 * @param {Object} sums The sums containing:
 *   'text': (string) The text to display in the icon.
 *   'index': (number) The style index of the icon.
 */
ClusterIcon.prototype.setSums = function(sums) {
  this.sums_ = sums;
  this.text_ = sums.text;
  this.index_ = sums.index;
  if (this.div_) {
    this.div_.innerHTML = sums.text;
  }

  this.useStyle();
};


/**
 * Sets the icon to the the styles.
 */
ClusterIcon.prototype.useStyle = function() {
  var index = Math.max(0, this.sums_.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style['url'];
  this.height_ = style['height'];
  this.width_ = style['width'];
  this.textColor_ = style['textColor'];
  this.anchor_ = style['anchor'];
  this.textSize_ = style['textSize'];
  this.backgroundPosition_ = style['backgroundPosition'];
  this.iconAnchor_ = style['iconAnchor'];
};


/**
 * Sets the center of the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function(center) {
  this.center_ = center;
};


/**
 * Create the css text based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position.
 * @return {string} The css style text.
 */
ClusterIcon.prototype.createCss = function(pos) {
  var style = [];
  style.push('background-image:url(' + this.url_ + ');');
  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
  style.push('background-position:' + backgroundPosition + ';');

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
        this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
          'px; padding-top:' + this.anchor_[0] + 'px;');
    } else if (typeof this.anchor_[0] === 'number' && this.anchor_[0] < 0 &&
        -this.anchor_[0] < this.height_) {
      style.push('height:' + this.height_ + 'px; line-height:' + (this.height_ + this.anchor_[0]) +
          'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
          'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
        this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
          'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  var txtColor = this.textColor_ ? this.textColor_ : 'black';
  var txtSize = this.textSize_ ? this.textSize_ : 11;

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
      txtSize + 'px; font-family:"Open Sans",Arial,sans-serif; font-weight:bold');
  return style.join('');
};


// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
window['MarkerClusterer'] = MarkerClusterer;
MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;
MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;
MarkerClusterer.prototype['clearMarkers'] =
    MarkerClusterer.prototype.clearMarkers;
MarkerClusterer.prototype['fitMapToMarkers'] =
    MarkerClusterer.prototype.fitMapToMarkers;
MarkerClusterer.prototype['getCalculator'] =
    MarkerClusterer.prototype.getCalculator;
MarkerClusterer.prototype['getGridSize'] =
    MarkerClusterer.prototype.getGridSize;
MarkerClusterer.prototype['getExtendedBounds'] =
    MarkerClusterer.prototype.getExtendedBounds;
MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;
MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;
MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;
MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;
MarkerClusterer.prototype['getTotalClusters'] =
    MarkerClusterer.prototype.getTotalClusters;
MarkerClusterer.prototype['getTotalMarkers'] =
    MarkerClusterer.prototype.getTotalMarkers;
MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;
MarkerClusterer.prototype['removeMarker'] =
    MarkerClusterer.prototype.removeMarker;
MarkerClusterer.prototype['removeMarkers'] =
    MarkerClusterer.prototype.removeMarkers;
MarkerClusterer.prototype['resetViewport'] =
    MarkerClusterer.prototype.resetViewport;
MarkerClusterer.prototype['repaint'] =
    MarkerClusterer.prototype.repaint;
MarkerClusterer.prototype['setCalculator'] =
    MarkerClusterer.prototype.setCalculator;
MarkerClusterer.prototype['setGridSize'] =
    MarkerClusterer.prototype.setGridSize;
MarkerClusterer.prototype['setMaxZoom'] =
    MarkerClusterer.prototype.setMaxZoom;
MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;
MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;

Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;
Cluster.prototype['getSize'] = Cluster.prototype.getSize;
Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;

ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;
ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;
ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;
;/* Respond.js: min/max-width media query polyfill. (c) Scott Jehl. MIT Lic. j.mp/respondjs  */
(function( w ){

	"use strict";

	//exposed namespace
	var respond = {};
	w.respond = respond;

	//define update even in native-mq-supporting browsers, to avoid errors
	respond.update = function(){};

	//define ajax obj
	var requestQueue = [],
		xmlHttp = (function() {
			var xmlhttpmethod = false;
			try {
				xmlhttpmethod = new w.XMLHttpRequest();
			}
			catch( e ){
				xmlhttpmethod = new w.ActiveXObject( "Microsoft.XMLHTTP" );
			}
			return function(){
				return xmlhttpmethod;
			};
		})(),

		//tweaked Ajax functions from Quirksmode
		ajax = function( url, callback ) {
			var req = xmlHttp();
			if (!req){
				return;
			}
			req.open( "GET", url, true );
			req.onreadystatechange = function () {
				if ( req.readyState !== 4 || req.status !== 200 && req.status !== 304 ){
					return;
				}
				callback( req.responseText );
			};
			if ( req.readyState === 4 ){
				return;
			}
			req.send( null );
		},
		isUnsupportedMediaQuery = function( query ) {
			return query.replace( respond.regex.minmaxwh, '' ).match( respond.regex.other );
		};

	//expose for testing
	respond.ajax = ajax;
	respond.queue = requestQueue;
	respond.unsupportedmq = isUnsupportedMediaQuery;
	respond.regex = {
		media: /@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi,
		keyframes: /@(?:\-(?:o|moz|webkit)\-)?keyframes[^\{]+\{(?:[^\{\}]*\{[^\}\{]*\})+[^\}]*\}/gi,
		comments: /\/\*[^*]*\*+([^/][^*]*\*+)*\//gi,
		urls: /(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,
		findStyles: /@media *([^\{]+)\{([\S\s]+?)$/,
		only: /(only\s+)?([a-zA-Z]+)\s?/,
		minw: /\(\s*min\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
		maxw: /\(\s*max\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
		minmaxwh: /\(\s*m(in|ax)\-(height|width)\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/gi,
		other: /\([^\)]*\)/g
	};

	//expose media query support flag for external use
	respond.mediaQueriesSupported = w.matchMedia && w.matchMedia( "only all" ) !== null && w.matchMedia( "only all" ).matches;

	//if media queries are supported, exit here
	if( respond.mediaQueriesSupported ){
		return;
	}

	//define vars
	var doc = w.document,
		docElem = doc.documentElement,
		mediastyles = [],
		rules = [],
		appendedEls = [],
		parsedSheets = {},
		resizeThrottle = 30,
		head = doc.getElementsByTagName( "head" )[0] || docElem,
		base = doc.getElementsByTagName( "base" )[0],
		links = head.getElementsByTagName( "link" ),

		lastCall,
		resizeDefer,

		//cached container for 1em value, populated the first time it's needed
		eminpx,

		// returns the value of 1em in pixels
		getEmValue = function() {
			var ret,
				div = doc.createElement('div'),
				body = doc.body,
				originalHTMLFontSize = docElem.style.fontSize,
				originalBodyFontSize = body && body.style.fontSize,
				fakeUsed = false;

			div.style.cssText = "position:absolute;font-size:1em;width:1em";

			if( !body ){
				body = fakeUsed = doc.createElement( "body" );
				body.style.background = "none";
			}

			// 1em in a media query is the value of the default font size of the browser
			// reset docElem and body to ensure the correct value is returned
			docElem.style.fontSize = "100%";
			body.style.fontSize = "100%";

			body.appendChild( div );

			if( fakeUsed ){
				docElem.insertBefore( body, docElem.firstChild );
			}

			ret = div.offsetWidth;

			if( fakeUsed ){
				docElem.removeChild( body );
			}
			else {
				body.removeChild( div );
			}

			// restore the original values
			docElem.style.fontSize = originalHTMLFontSize;
			if( originalBodyFontSize ) {
				body.style.fontSize = originalBodyFontSize;
			}


			//also update eminpx before returning
			ret = eminpx = parseFloat(ret);

			return ret;
		},

		//enable/disable styles
		applyMedia = function( fromResize ){
			var name = "clientWidth",
				docElemProp = docElem[ name ],
				currWidth = doc.compatMode === "CSS1Compat" && docElemProp || doc.body[ name ] || docElemProp,
				styleBlocks	= {},
				lastLink = links[ links.length-1 ],
				now = (new Date()).getTime();

			//throttle resize calls
			if( fromResize && lastCall && now - lastCall < resizeThrottle ){
				w.clearTimeout( resizeDefer );
				resizeDefer = w.setTimeout( applyMedia, resizeThrottle );
				return;
			}
			else {
				lastCall = now;
			}

			for( var i in mediastyles ){
				if( mediastyles.hasOwnProperty( i ) ){
					var thisstyle = mediastyles[ i ],
						min = thisstyle.minw,
						max = thisstyle.maxw,
						minnull = min === null,
						maxnull = max === null,
						em = "em";

					if( !!min ){
						min = parseFloat( min ) * ( min.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 );
					}
					if( !!max ){
						max = parseFloat( max ) * ( max.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 );
					}

					// if there's no media query at all (the () part), or min or max is not null, and if either is present, they're true
					if( !thisstyle.hasquery || ( !minnull || !maxnull ) && ( minnull || currWidth >= min ) && ( maxnull || currWidth <= max ) ){
						if( !styleBlocks[ thisstyle.media ] ){
							styleBlocks[ thisstyle.media ] = [];
						}
						styleBlocks[ thisstyle.media ].push( rules[ thisstyle.rules ] );
					}
				}
			}

			//remove any existing respond style element(s)
			for( var j in appendedEls ){
				if( appendedEls.hasOwnProperty( j ) ){
					if( appendedEls[ j ] && appendedEls[ j ].parentNode === head ){
						head.removeChild( appendedEls[ j ] );
					}
				}
			}
			appendedEls.length = 0;

			//inject active styles, grouped by media type
			for( var k in styleBlocks ){
				if( styleBlocks.hasOwnProperty( k ) ){
					var ss = doc.createElement( "style" ),
						css = styleBlocks[ k ].join( "\n" );

					ss.type = "text/css";
					ss.media = k;

					//originally, ss was appended to a documentFragment and sheets were appended in bulk.
					//this caused crashes in IE in a number of circumstances, such as when the HTML element had a bg image set, so appending beforehand seems best. Thanks to @dvelyk for the initial research on this one!
					head.insertBefore( ss, lastLink.nextSibling );

					if ( ss.styleSheet ){
						ss.styleSheet.cssText = css;
					}
					else {
						ss.appendChild( doc.createTextNode( css ) );
					}

					//push to appendedEls to track for later removal
					appendedEls.push( ss );
				}
			}
		},
		//find media blocks in css text, convert to style blocks
		translate = function( styles, href, media ){
			var qs = styles.replace( respond.regex.comments, '' )
					.replace( respond.regex.keyframes, '' )
					.match( respond.regex.media ),
				ql = qs && qs.length || 0;

			//try to get CSS path
			href = href.substring( 0, href.lastIndexOf( "/" ) );

			var repUrls = function( css ){
					return css.replace( respond.regex.urls, "$1" + href + "$2$3" );
				},
				useMedia = !ql && media;

			//if path exists, tack on trailing slash
			if( href.length ){ href += "/"; }

			//if no internal queries exist, but media attr does, use that
			//note: this currently lacks support for situations where a media attr is specified on a link AND
				//its associated stylesheet has internal CSS media queries.
				//In those cases, the media attribute will currently be ignored.
			if( useMedia ){
				ql = 1;
			}

			for( var i = 0; i < ql; i++ ){
				var fullq, thisq, eachq, eql;

				//media attr
				if( useMedia ){
					fullq = media;
					rules.push( repUrls( styles ) );
				}
				//parse for styles
				else{
					fullq = qs[ i ].match( respond.regex.findStyles ) && RegExp.$1;
					rules.push( RegExp.$2 && repUrls( RegExp.$2 ) );
				}

				eachq = fullq.split( "," );
				eql = eachq.length;

				for( var j = 0; j < eql; j++ ){
					thisq = eachq[ j ];

					if( isUnsupportedMediaQuery( thisq ) ) {
						continue;
					}

					mediastyles.push( {
						media : thisq.split( "(" )[ 0 ].match( respond.regex.only ) && RegExp.$2 || "all",
						rules : rules.length - 1,
						hasquery : thisq.indexOf("(") > -1,
						minw : thisq.match( respond.regex.minw ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || "" ),
						maxw : thisq.match( respond.regex.maxw ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || "" )
					} );
				}
			}

			applyMedia();
		},

		//recurse through request queue, get css text
		makeRequests = function(){
			if( requestQueue.length ){
				var thisRequest = requestQueue.shift();

				ajax( thisRequest.href, function( styles ){
					translate( styles, thisRequest.href, thisRequest.media );
					parsedSheets[ thisRequest.href ] = true;

					// by wrapping recursive function call in setTimeout
					// we prevent "Stack overflow" error in IE7
					w.setTimeout(function(){ makeRequests(); },0);
				} );
			}
		},

		//loop stylesheets, send text content to translate
		ripCSS = function(){

			for( var i = 0; i < links.length; i++ ){
				var sheet = links[ i ],
				href = sheet.href,
				media = sheet.media,
				isCSS = sheet.rel && sheet.rel.toLowerCase() === "stylesheet";

				//only links plz and prevent re-parsing
				if( !!href && isCSS && !parsedSheets[ href ] ){
					// selectivizr exposes css through the rawCssText expando
					if (sheet.styleSheet && sheet.styleSheet.rawCssText) {
						translate( sheet.styleSheet.rawCssText, href, media );
						parsedSheets[ href ] = true;
					} else {
						if( (!/^([a-zA-Z:]*\/\/)/.test( href ) && !base) ||
							href.replace( RegExp.$1, "" ).split( "/" )[0] === w.location.host ){
							// IE7 doesn't handle urls that start with '//' for ajax request
							// manually add in the protocol
							if ( href.substring(0,2) === "//" ) { href = w.location.protocol + href; }
							requestQueue.push( {
								href: href,
								media: media
							} );
						}
					}
				}
			}
			makeRequests();
		};

	//translate CSS
	ripCSS();

	//expose update for re-running respond later on
	respond.update = ripCSS;

	//expose getEmValue
	respond.getEmValue = getEmValue;

	//adjust on resize
	function callMedia(){
		applyMedia( true );
	}

	if( w.addEventListener ){
		w.addEventListener( "resize", callMedia, false );
	}
	else if( w.attachEvent ){
		w.attachEvent( "onresize", callMedia );
	}
})(this);
;/*
 * SVGeezy.js 1.0
 *
 * Copyright 2012, Ben Howdle http://twostepmedia.co.uk
 * Released under the WTFPL license
 * http://sam.zoy.org/wtfpl/
 *
 * Date: Sun Aug 26 20:38 2012 GMT
 */

/*
	//call like so, pass in a class name that you don't want it to check and a filetype to replace .svg with
	svgeezy.init('nocheck', 'png');
*/

window.svgeezy = function() {

		return {

			init: function(avoid, filetype) {
				this.avoid = avoid || false;
				this.filetype = filetype || 'png';
				this.svgSupport = this.supportsSvg();
				if(!this.svgSupport) {
					this.images = document.getElementsByTagName('img');
					this.imgL = this.images.length;
					this.fallbacks();
				}
			},

			fallbacks: function() {
				while(this.imgL--) {
					if(!this.hasClass(this.images[this.imgL], this.avoid) || !this.avoid) {
						var src = this.images[this.imgL].getAttribute('src');
						if(src === null) {
							continue;
						}
						if(this.getFileExt(src) == 'svg') {
							var newSrc = src.replace('.svg', '.' + this.filetype);
							this.images[this.imgL].setAttribute('src', newSrc);
						}
					}
				}
			},

			getFileExt: function(src) {
				var ext = src.split('.').pop();

        			if(ext.indexOf("?") !== -1) {
          				ext = ext.split('?')[0];
        			}

        			return ext;
			},

			hasClass: function(element, cls) {
				return(' ' + element.className + ' ').indexOf(' ' + cls + ' ') > -1;
			},

			supportsSvg: function() {
				return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
			}
		};

	}();
;//Async form post

function asyncPost( button ) {
    //Get the form
    var form = button.closest( 'form' );
    //Get the holder
    var holder = form.closest( '.asyncHolder' );
    // serialize the form
    var postData = form.serialize();
    // Disable the button
    button.attr( 'disabled', 'disabled' );
    button.addClass( 'is-loading' );
    //Get the action url from the form
    var action = form.attr( 'action' );

    //Post the thing
    $.ajax( {
        type: 'POST',
        url: action,
        data: postData
    } ).done( function( data, status ) {
        $( holder ).html( data );

        WhereToBuy.initMailForm(true);

        //Re-add the click event
        holder.find( '.asyncPost' ).click( function() {
            asyncPost( $( this ) );
            return false;
        } );

    } ).always( function( data, status, error ) {
        //Enable the button
        button.removeAttr( 'disabled' );
        button.removeClass( 'is-loading' );
    } );
}

$( '.asyncPost' ).each( function( index, elm ) {
    $( elm ).click( function() {
        asyncPost( $( elm ) );
        return false;
    } );
} );
;var isMobile = false;
var isTabletSize = false;
var tabletWidthSize = 930; //portrait

var isIE8 = false;
var isIE9And10 = false;
var isIE11 = false;

var languageIsAnimating = false;

var headSwiper;
var firstSlideId = 0;
var lastSlideId = 0;

var gallerySwiper;
var aboutProductsSwiper;

function isTouch() { return !!('ontouchstart' in window) || !!('msmaxtouchpoints' in navigator); }

//---iFrame---\\\

function showMessage(msg) {
	document.getElementById("messages").innerHTML += "<li>" + msg + "</li>";
}


var IframeHeight = (function() {

	// Module for setting the iframe height from another domain

	var self = {},
		$iframe = $('#crossdomain');

	self.init = function() {
		if ($iframe.length) {
		    addOriginToIframeSrc();
		    addLanguageToIframeSrc();
		    addEcatURLToIframeSrc();
			initPostMessageListener();
		}
	};

	/*
	Add this window's origin to the iframe's src so the script in the iframe can pick it up.
	Should fire asap to prevent the iframe from reloading visually (which will happen anyway, but we want to prevent flickers).
	With the correct origin the script in the iframe know where to send the postmessage.
	*/
	function addOriginToIframeSrc() {
		var src = $iframe.attr('src') + '?root=' + encodeURI(getWindowOrigin()) +"/";
		$iframe.attr('src', src);
	}

	function addLanguageToIframeSrc() {
	    var src = $iframe.attr('src') + '&lang=' + $iframe.attr('data-lang');
	    $iframe.attr('src', src);
	}

	function addEcatURLToIframeSrc() {
	    if ($iframe.attr('data-ecaturl') && $iframe.attr('data-ecaturl').length > 0) {
	        var src = $iframe.attr('src') + '&ecatURL=' + $iframe.attr('data-ecaturl');
	        $iframe.attr('src', src);
	    }
	}

	function getWindowOrigin() {
		var origin = window.location.origin;

		if (!window.location.origin) {
			origin = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
		}

		return origin;
	}

	// Listen for incoming messages from the iframe
	function initPostMessageListener() {
		if (window.addEventListener) {
			window.addEventListener('message', receiveMessage);
		} else {
			window.attachEvent('onmessage', receiveMessage);
		}
	}

	// Act on the received message
	function receiveMessage(message) {
		if (message.origin === getIframeOrigin()) { // Postmessage origin must match iframe's src origin, this is for security
			setIframeHeight(parseInt(message.data));
		}
	}

  function getIframeOrigin() {
	  var iframeSrc = $iframe.attr('src').split('//'),
			  iframeProtocol = iframeSrc[0],
			  iframeDomain = iframeSrc[1].split('/')[0];

	  return iframeProtocol + '//' + iframeDomain;
  }

	function setIframeHeight(height) {
		if (height > 0) {
			$iframe.height(height);
		}
	}

	return self;

})();



//---Other---\\\

$(document).ready(function() {

  $(".fancybox").fancybox();

  setFooterToBottom();

  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    isMobile = true;

    //event for changing orientation
    //needed for backstretch & apple
    if (window.addEventListener) {
      window.addEventListener("orientationchange", onOrientationChange);
    } else {
      window.attachEvent("orientationchange", onOrientationChange);
    }
  }

  //placeholder
  // $('input, textarea').placeholder();

  //svg image to png for older browsers
  svgeezy.init('nocheck', 'png');

  //mobile menu
  $(".mobile-menu-trigger").click(function(e) {
    e.preventDefault();

    $(".left-block .menu").toggle();

    if ($(".left-block .menu").is(":visible") && !($(".right-block").is(":visible"))) {
      $(".right-block").show();
    } else if (!($(".left-block .menu").is(":visible")) && isTabletSize) {
      $(".right-block").hide();
    }
  });

  if (window.addEventListener) {
    window.addEventListener("scroll", onScroll);
    window.addEventListener("resize", onResize);
  } else {
    window.attachEvent("scroll", onScroll);
    window.attachEvent("resize", onResize);
  }

  onScroll();
  onResize();

  fixIEStuff();

  initFindBlocks();

  initDropdownMenu();

  initGallery();

  initAboutProductsGallery();

  initHeaderImage();

  initWhatsHappeningBlocks();

  initMoreThanBlocks();

  initSearch();

  initLanguageSwitch();

  initAccordion();

  initRangeColumnPadding();

  if($("select.selectric").length>0){
    $('select.selectric').selectric({
      disableOnMobile:false
    });
  }



	var $productSearchInput = $('.products-search-input');
	if ($productSearchInput.length) {
		var productsSearchList = [];

		$('.products-search-list li').each(function() {
			productsSearchList.push({
				url: $(this).find('a').attr('href'),
				value: $(this).text()
			});
		});

    $productSearchInput.keypress(function(e) {
      if (e.which == 13) {
        var stopFromSubmitting = true;
        for(var i = 0; i<productsSearchList.length; i++){
          if(productsSearchList[i].value == $productSearchInput.val()){
            stopFromSubmitting = false;
          }
        }

        if(stopFromSubmitting){
          e.preventDefault();
        }
      }

    });

		$productSearchInput.autocomplete({
			minLength: 2,
			source: productsSearchList
		}).data('ui-autocomplete')._renderItem = function(ul, item) { // This highlights the search query - http://stackoverflow.com/questions/9887032/how-to-highlight-input-words-in-autocomplete-jquery-ui
			var newText = String(item.value).replace(
				new RegExp(this.term, 'gi'),
				'<strong>$&</strong>'
      );

      $('.products-search').attr('action', item.url);

			return $('<li></li>')
				.data('item.autocomplete', item)
				.append('<a href="' + item.url + '">' + newText + '</a>')
				.appendTo(ul);
		};
	}

	IframeHeight.init();


});

function initRangeColumnPadding(){
  if($(".range-blocks .column.push-down")){
    var paddingTop = $(".range-blocks .columns").find(".column:first-child").find("h1").height();
    if(paddingTop === null){
      paddingTop = $(".range-blocks .columns").find(".column:first-child").find("h2").height();
    }
    if(paddingTop === null){
      paddingTop = $(".range-blocks .columns").find(".column:first-child").find("h3").height();
    }
    if(paddingTop === null){
      paddingTop = $(".range-blocks .columns").find(".column:first-child").find("h4").height();
    }
    if(paddingTop === null){
      paddingTop = $(".range-blocks .columns").find(".column:first-child").find("h5").height();
    }
    if(paddingTop === null){
      paddingTop = $(".range-blocks .columns").find(".column:first-child").find("h6").height();
    }
    if(paddingTop !== null){
      paddingTop += 40;
    }

    if($(".range-blocks .column.push-down h1,.range-blocks .column.push-down h2,.range-blocks .column.push-down h3,.range-blocks .column.push-down h4,.range-blocks .column.push-down h5,.range-blocks .column.push-down h6").length !== 1){
      $(".range-blocks .column.push-down").css("padding-top", paddingTop+"px");
    }


    /*if((paddingTop===null) && ($(".range-blocks .column.push-down h1,.range-blocks .column.push-down h2,.range-blocks .column.push-down h3,.range-blocks .column.push-down h4,.range-blocks .column.push-down h5,.range-blocks .column.push-down h6").length===1)){
      paddingTop = $(".range-blocks .columns").find(".column").find("h1").height();
      if(paddingTop === null){
        paddingTop = $(".range-blocks .columns").find(".column").find("h2").height();
      }
      if(paddingTop === null){
        paddingTop = $(".range-blocks .columns").find(".column").find("h3").height();
      }
      if(paddingTop === null){
        paddingTop = $(".range-blocks .columns").find(".column").find("h4").height();
      }
      if(paddingTop === null){
        paddingTop = $(".range-blocks .columns").find(".column").find("h5").height();
      }
      if(paddingTop === null){
        paddingTop = $(".range-blocks .columns").find(".column").find("h6").height();
      }
      if(paddingTop !== null){
        paddingTop += 40;
      }
      $(".range-blocks .column:first-child").css("padding-top", paddingTop+"px");
    }*/

    if((paddingTop===null) && ($(".range-blocks .column.push-down h1,.range-blocks .column.push-down h2,.range-blocks .column.push-down h3,.range-blocks .column.push-down h4,.range-blocks .column.push-down h5,.range-blocks .column.push-down h6").length===1)){
      $(".range-blocks .column.push-down h1:first-child,.range-blocks .column.push-down h2:first-child,.range-blocks .column.push-down h3:first-child,.range-blocks .column.push-down h4:first-child,.range-blocks .column.push-down h5:first-child,.range-blocks .column.push-down h6:first-child").css("margin-top",0);
    }




  }
}

function setFooterToBottom() {
  $(".main-content").css("min-height", "0px");
  if ($("body").outerHeight() < $(window).outerHeight()) {
    $(".main-content").css("min-height", ($(window).outerHeight() - $("footer").outerHeight() - $("header").outerHeight() - 31) + "px");
  }
}

function fixIEStuff() {
  if (navigator.appVersion.indexOf("MSIE 8.") != -1) {
    isIE8 = true;
	  $('html').addClass('ie8');

    //fix search icon for ie8
    $(".search input").css("background-image", "url(/images/icons/icn_search_grey.png)");
    $(".search input").css("background-size", "17px 17px");
    $(".search input").css("background-position", "right 5px center");

    //fix language icon for ie8
    $(".language-trigger").css("background-image", "url(/images/icons/icn_arrow_grey_big.png)");
    $(".language-trigger").css("background-position", "right center");

    //fix arrow icons for happening bocks
    $(".block-content.two .content").css("background-image", "url(/images/icons/icn_arrow_white_vertical.png)");
    $(".block-content.two .content").css("background-size", "17px 17px");
    $(".block-content.two .content").css("background-position", "right bottom");

    //fix download icons
    $(".block-content.two-text span.img").css("background-image", "url(/images/icons/download-icon.png)");
  }

  if (navigator.appVersion.indexOf("MSIE 10.") != -1 || navigator.appVersion.indexOf("MSIE 9.") != -1) {
    isIE9And10 = true;

    //fix arrow icons for happening bocks
    $(".block-content.two .content").css("background-size", "31px 17px");
    $(".block-content.two .content").css("background-position", "right 5px bottom 10px");

    //fix download icons
    $(".block-content.two-text span.img").css("background-image", "url(/images/icons/download-icon.png)");
  }

  if (isIE9And10 || isIE8) {

    $("span.img.download").css("background-image", "url(/images/icons/download-icon.png)");
    $("span.img.outer-link").css("background-image", "url(/images/icons/outer-link-icon.png)");
    $("span.img.inner-link").css("background-image", "url(/images/icons/inner-link-icon.png)");
    $("span.img").css("background-size", "auto");

    $(".button.arrow").css("background-image", "url(/images/icons/icn_arrow_white_vertical.png)");
    $(".button.arrow.white").css("background-image", "url(/images/icons/icn_arrow_light_grey_vertical.png)");
    $(".button.arrow").css("background-size", "31px 31px");
    $(".button.arrow").css("background-position", "right center");

    $(".archive-content ul li").css("background-image", "url(/images/icons/icn_arrow_light_grey_vertical.png)");

    $(".accordion .trigger span").css("background-image", "url(/images/icons/plus-icon.png)");

    $(".wysiwyg-content blockquote").css("background-image", "url(/images/icons/quote.png)");

    $(".category").css("margin-right","2%");

    $("input.city").css("background-image", "url(/images/icons/icn_search_grey.png)");
    $("input.city").css("background-size", "auto");
    $("input.city").css("background-position", "right center");
    $("input.city").css("margin-left", "0px");

    $("p.maps").css("background-image", "url(/images/icons/pin-icon-blue.png)");
    $("li.phone").css("background-image", "url(/images/icons/phone-icon.png)");
    $("li.mail").css("background-image", "url(/images/icons/mail-icon.png)");
    $("li.website").css("background-image", "url(/images/icons/website-icon.png)");
  }

  if (navigator.userAgent.match(/Trident.*rv\:11\./)) {
    isIE11 = true;
  }
}

function initFindBlocks() {
  //catalogue buttons - click
  $(".find-bar .find-button .find-trigger:not(.find-trigger-href)").click(function(e) {

      if( $( this ).hasClass( 'e-cat' ) ) return;

    e.preventDefault();

    var item = this;



    if ($(item).parent().parent().parent().hasClass("fixed")) {
      $('#find-bar-handle').ScrollTo({
        duration: 500,
        offsetTop: 1
      });

      setTimeout(function() {
        $(".find-bar .find-bar-sections .block").hide();
        $($(item).attr("href")).show();
        $(".find-bar .find-button .find-trigger").removeClass("active");
        $(item).addClass("active");
      }, 500);

    } else {

      if ($(item).hasClass("active")) {
        $(item).removeClass("active");
        $(".find-bar .found-block").hide();


        if (($(".find-bar .found-block").css("position") != "static") ) {
          $(".find-bar").height("80px");
        }

      } else {
        $(".find-bar .find-button .find-trigger").removeClass("active");
        $(".find-bar .found-block").hide();

        $(item).addClass("active");
        //$(item).css("background-image", "url(/images/icons/icn_arrow_red_up.svg)");

        $($(item).attr("href")).show();

        if ($(".find-bar .found-block").css("position") != "static") {
          if($(item).hasClass("e-cat")){
            $(".find-bar").height("120px");
          } else {
            var neededHeight = $($(item).attr("href")).height() + 80;
            $(".find-bar").height(neededHeight + "px");
          }
        }

      }

    }
  });

  //catalogue buttons - hover
  $(".find-bar .find-button a").hover(
    function() {
      $(".find-bar .find-button a").css("color", "#4d4d4d");
      $(this).css("color", "#000000");
    },
    function() {
      $(".find-bar .find-button a").css("color", "#000000");
    }
  );
}

function initDropdownMenu() {
  var menuIsOpen = false;
  var dropdownItem;
  var dropdownTrigger;

  if (!isTouch()) {

    $(".menu li a").mouseover(function() {
      if ($(this).hasClass("menu-item") && menuIsOpen) {
        $(".dropdown-trigger").removeClass("dropped"); //remove from all triggers
        $(".dropdown").hide(); //hide all dropdown menus
        menuIsOpen = false;
      }
    });

    $(".dropdown-trigger").mouseover(function() {
      dropdownTrigger = $(this);
      dropdownItem = $(this).parent().find(".dropdown");

      menuIsOpen = true;

      dropdownTrigger.addClass("dropped");
      dropdownItem.show();
    });

    $(".dropdown-wrapper").mouseleave(function() {
      menuIsOpen = false;

      dropdownTrigger.removeClass("dropped");
      dropdownItem.hide();
    });

    $(".dropdown-trigger").click(function(e) {
      e.preventDefault();
      if (menuIsOpen) {
        dropdownItem.toggle();
      }
    });

  } else {
    $(".dropdown-trigger").click(function(e) {
      e.preventDefault();

      dropdownTrigger = $(this);
      dropdownItem = $(this).parent().find(".dropdown");

      dropdownItem.toggle();

      if (dropdownItem.is(":visible")) {
        menuIsOpen = true;
      } else {
        menuIsOpen = false;
      }

      if (!menuIsOpen) {
        dropdownTrigger.addClass("no-hover");
      } else {
        dropdownTrigger.removeClass("no-hover");
      }

    });
  }
}

function initWhatsHappeningBlocks() {
  //what's happening blocks
  var hoveringHappeningBlocks = true;
  $(".block-content.two .trigger").hover(function() {
    if (!isMobile && !isTabletSize) {
      hoveringHappeningBlocks = true;

      var item = this;
      $(item).find(".content").css("width", "92%");

      if (isIE9And10) {
        $(item).find(".content").css("background-size", "52px 17px");
      }

      $(item).find("img").stop(true, true).fadeOut();
      $(item).find(".title").stop(true, true).fadeOut();

      setTimeout(function() {
        if (hoveringHappeningBlocks) {
          $(item).find(".description").width($(item).find(".content").width() + "px");
          $(item).find(".description").stop(true, true).fadeIn();
        } else {
          $(item).find(".description").hide();
        }
      }, 500);
    }
  }, function() {
    if (!isMobile && !isTabletSize) {
      hoveringHappeningBlocks = false;

      var item = this;
      if (!isIE8) {
        $(item).find(".content").css("width", "calc(100% - 225px)");
      } else {
        $(item).find(".content").css("width", "40%");
      }

      if (isIE9And10) {
        $(item).find(".content").css("background-size", "31px 17px");
      }

      $(item).find(".description").stop(true, true).fadeOut("fast");
      $(item).find("img").stop(true, true).fadeIn();

      setTimeout(function() {
        if (!hoveringHappeningBlocks) {
          $(item).find(".title").stop(true, true).fadeIn();
        } else {
          $(item).find(".description").hide();
          $(item).find(".title").stop(true, true).fadeIn();
        }
      }, 500);
    }
  });
}

function initMoreThanBlocks() {
  //more than blocks
  if (!isMobile) {
    var isHovering = false;
    $(".block-content.three .trigger").hover(
      function() {
        if (!isTabletSize) {
          var item = this;
          if (isHovering) return;
          isHovering = true;

          var titleLength = $(item).find(".description h3").text().length;
          var textLength = $(item).find(".description p").text().length;

          if ((titleLength + textLength) > $(item).find(".description").width() - 130) {
            var truncateLength = $(item).find(".description").width() - 130 - titleLength;
            $(item).find(".description p").text(truncate($(item).find(".description p").text(), truncateLength));
          }


          $(item).find(".title").stop(true, true).fadeOut();
          $(item).find(".shutter").css("left", "0");

          setTimeout(function() {
            $(item).find(".description").stop(true, true).fadeIn();
          }, 100);
        }

      }, function() {
        var item = this;
        isHovering = false;
        $(item).find(".title").stop(true, true).fadeIn();
        $(item).find(".description").stop(true, true).fadeOut();

        setTimeout(function() {
          if (isHovering) {
            $(item).find(".shutter").css("left", "-100%");
            $(item).find(".title").show();
            $(item).find(".description").hide();
          } else {
            $(item).find(".shutter").css("left", "-100%");
            $(item).find(".title").stop(true, true).fadeIn();
            $(item).find(".description").stop(true, true).fadeOut();
          }

        }, 100);
      }
    );

  }
}

function initGallery() {
  var $galleries = $(".gallery-container");
  var galleryArr = [];
  var counter = 0;

  if ($galleries.length > 0) {

    $galleries.each(function(index) {

      var $gallery = $($galleries[index]);

      var gal = $gallery.swiper({
        mode: 'horizontal',
        loop: true,
        onlyExternal: false,
        //autoplay: 3000,
        simulateTouch: false,
        speed: 500,
        preventLinks: true,
        wrapperClass: "swiper-wrapper",
        slideClass: "swiper-slide",
        slideVisibleClass: "swiper-slide-active",
        prevButton: ".gallery-container .arrow-left",
        calculateHeight: true,
        roundLengths: true,
        onSlideChangeStart: function(swiper){
          setNavigationText(swiper);
        },
        onSwiperCreated: function(swiper) {
          //fix images full
          $gallery.find(".gallery-media-container").each(function(index) {
            var elem = $(this).parent();
            if (elem.hasClass("media") ){
              elem = $(elem).parent();
            }

            if($(elem).find("img.source").length>0 ){
              $(this).backstretch($(elem).find("img.source").attr("src"));
            } else if($(elem).find("div.source img").length>0){
              $(this).backstretch($(elem).find("div.source img").attr("src"));
            }

          });

          setNavigationText(swiper);

        }

      });

      $gallery.data("counter",counter);
      counter++;

      galleryArr.push(gal);
    });


    $('.gallery-container .arrow-left').click(function(e) {
      e.preventDefault();
      var galleryIndex = $(this).closest(".gallery-container" ).data("counter");
      galleryArr[galleryIndex].swipePrev();
    });

    $('.gallery-container .arrow-right').click(function(e) {
      e.preventDefault();
      var galleryIndex = $(this).closest(".gallery-container" ).data("counter");
      galleryArr[galleryIndex].swipeNext();
    });


  }
}

function setNavigationText(swiper){

  var totalSlides = 0;
  var sliderSlides = $(swiper.slides);

  sliderSlides.each(function(index) {
    if( !$(sliderSlides[index] ).hasClass("swiper-slide-duplicate") ) totalSlides++;
  });

  var slideIndex = swiper.activeLoopIndex+1;

  $(".gallery-container .navigation span.span-index").text(slideIndex);

}

function initAboutProductsGallery() {
  if ($(".about-products-container").length > 0) {

    aboutProductsSwiper = $('.about-products-container').swiper({
      mode: 'horizontal',
      loop: true,
      onlyExternal: false,
      //autoplay: 3000,
      simulateTouch: false,
      speed: 500,
      preventLinks: true,
      wrapperClass: "swiper-wrapper",
      slideClass: "swiper-slide",
      slideVisibleClass: "swiper-slide-active",
      calculateHeight: true,
      roundLengths: true,
      onSlideChangeStart: function(swiper){
        //setNavigationText(swiper);
      },
      onSwiperCreated: function(swiper) {
        //fix full backgrounds
        $(".about-products-container .swiper-slide").each(function(index) {
          if( $(this).find("img.bg-image").length>0 ){
            $(this).backstretch($(this).find("img.bg-image").attr("src"));
          }
        });


      }

    });

    $('.about-products-container .arrow-left').click(function(e) {
      e.preventDefault();
      aboutProductsSwiper.swipePrev();
    });

    $('.about-products-container .arrow-right').click(function(e) {
      e.preventDefault();
      aboutProductsSwiper.swipeNext();
    });
  }
}

function initHeaderImage() {
  if ($(".header-image").length > 0 && $(".header-image .bg-image").length > 0) {
    $(".header-image .container").backstretch($(".header-image .bg-image").attr("src"));
  }
}

function initLanguageSwitch() {
  //language switch
  var hoveringLanguage = true;
  if (!isMobile) {
    $(".language").hover(
      function() {
        languageIsAnimating = true;
        hoveringLanguage = true;

        //arrow icon
        if (isIE8 || isIE9And10 || isIE11) {
          $(".language-trigger").css("background-image", "url(/images/icons/icn_arrow_white_red_bg.png)");
        } else {
          $(".language-trigger").css("background-image", "url(/images/icons/icn_arrow_white_red_bg.svg)");
        }
        $(".language-trigger").css("background-position", "right 0px center");

        //language list
        $(".language-trigger").find("span").text($(".language-trigger").find("span").attr("data-full"));
        $(".language-trigger").css("width", "180px");
        $(".search input").css("margin-left", "0px");

        setTimeout(function() {
          if (hoveringLanguage) {
            $(".language-list").slideDown("500");
          }
        }, 500);
      },
      function() {
        hoveringLanguage = false;

        //arrow icon
        if (isIE8) {
          $(".language-trigger").css("background-image", "url(/images/icons/icn_arrow_grey_big.png)");
          $(".language-trigger").css("background-position", "right center");
        } else {
          $(".language-trigger").css("background-image", "url(/images/icons/icn_arrow_grey.svg)");
          $(".language-trigger").css("background-position", "right 10px center");
        }

        //language list
        $(".language-trigger").find("span").text($(".language-trigger").find("span").attr("data-short"));
        $(".language-list").slideUp("500");

        setTimeout(function() {
          if (!hoveringLanguage) {
            $(".language-trigger").css("width", "90px");
            $(".search input").css("margin-left", "10px");
          } else {
            (".language-list").hide();
          }
        }, 500);

        setTimeout(function() {
          languageIsAnimating = false;
        }, 1000);

      }
    );
  }

  $(".language-trigger").click(function(e) {
    e.preventDefault();

    if (isMobile) {
      $(".language-list").slideToggle("500");
    }
  });
}

function initSearch() {
  //search
  if (!isMobile) {
    $(".search input").hover(
      function() {
        if (!languageIsAnimating) {
          if (!isTabletSize) {
            $(this).css("width", "200px");
          }
          if (isIE8 || isIE9And10 || isIE11) {
            $(this).css("background-image", "url(/images/icons/icn_search_white_red_bg.png)");
          } else {
            $(this).css("background-image", "url(/images/icons/icn_search_white_red_bg.svg)");
          }
          $(this).css("background-size", "auto");
          $(this).css("background-position", "right 0px center");
          $(this).css("margin-left", "0px");
        }
      },
      function() {
        if (!languageIsAnimating) {
          if (!isTabletSize) {
            $(this).css("width", "120px");
          }
          if (isIE8) {
            $(this).css("background-image", "url(/images/icons/icn_search_grey.png)");
          } else {
            $(this).css("background-image", "url(/images/icons/icn_search_grey.svg)");
          }
          $(this).css("background-size", "17px 17px");
          $(this).css("background-position", "right 5px center");
          $(this).css("margin-left", "80px");
        }
      }
    );
  }
}

function truncate(string, truncateLength) {
  if (string.length > truncateLength) {
    return string.substring(0, truncateLength) + '...';
  } else {
    return string;
  }
}

function onScroll() {
  if (!isMobile && $(".find-bar").length) {
    stickyButtons();
  }


  //nav list
  if ($(".nav-list").length || $(".archive-filters-sticky-on-scroll" ).length ) {

    if( isTabletSize || isMobile ) return; //dont stick on tablet and mobile

    var stickBoundary = $("header").outerHeight() + $(".header-image").outerHeight();
    var crossBoundary = $("body").outerHeight() - $("footer").outerHeight() - $(".nav-list").outerHeight() - 100 - $(window).scrollTop();

    if( $(".media-related" ).length ){
      crossBoundary -= $(".media-related" ).outerHeight();
    }

    if( $(".archive-filters-sticky-on-scroll" ).length ){
      stickBoundary += 120;
      crossBoundary -= $(".archive-filters-sticky-on-scroll" ).outerHeight() + 80;
    }

    var mayStick = $(window).scrollTop() > stickBoundary;
    var crossesBottom = crossBoundary < 0;

    if (mayStick && !crossesBottom) {

      $(".nav-list").addClass("fixed");
      $(".nav-list").removeClass("absolute");

      if( $(".archive-filters-sticky-on-scroll" ).length ){
        $(".archive-filters-sticky-on-scroll" ).addClass("fixed");
        $(".archive-filters-sticky-on-scroll" ).removeClass("absolute");
      }

    } else {
      if (crossesBottom) {
        $(".nav-list").addClass("absolute");

        if( $(".archive-filters-sticky-on-scroll" ).length ){
          $(".archive-filters-sticky-on-scroll" ).addClass("absolute");
        }

      } else {
        $(".nav-list").removeClass("absolute");

        if( $(".archive-filters-sticky-on-scroll" ).length ){
          $(".archive-filters-sticky-on-scroll" ).removeClass("absolute");
        }

      }
      $(".nav-list").removeClass("fixed");

      if( $(".archive-filters-sticky-on-scroll" ).length ){
        $(".archive-filters-sticky-on-scroll" ).removeClass("fixed");
      }
    }

  }

}

function stickyButtons() {
  var activeItem;
  if ($(".find-bar .active")) {
    activeItem = $(".find-bar .active");
  }

  if ($(window).scrollTop() > $("#find-bar-handle").position().top && !isTabletSize) {
    $(".find-bar").addClass("fixed");

    if($(".coordinates").length!=2){
      $(".main-content").addClass("pushed-down");
    }


    $(".find-bar").css("height", "80px");

    $(".found-block").hide();

    if (isIE9And10) {
      $(".find-bar .find-trigger").css("background-size", "62px 17px");
    }

  } else if ($(window).scrollTop() <= 550) {
    $(".find-bar").removeClass("fixed");
    $(".main-content").removeClass("pushed-down");


    if ($(activeItem).length > 0) {
      $($(activeItem).attr("href")).show();
      var neededHeight = $($(activeItem).attr("href")).height() + 80;
      $(".find-bar").height(neededHeight + "px");
    }

    if (isIE9And10) {
      $(".find-bar .find-trigger").css("background-size", "31px 31px");
    }
  }
}

function onResize() {
  setFooterToBottom();

  if ($(window).outerWidth() <= tabletWidthSize) {
    isTabletSize = true;
  } else {
    isTabletSize = false;
  }

  if (isTabletSize && $(".right-block").is(":visible")) {
    $(".right-block").hide();
  } else if (!isTabletSize && !$(".right-block").is(":visible")) {
    $(".right-block").show();
  }

  if (isTabletSize && $(".find-bar").hasClass("fixed")) {
    $(".find-bar").removeClass("fixed");
  }

  if ($(".product-slider").length > 0) {
    onResizeProductSlider();
  }

  initHeaderImage();
}

function initAccordion() {
  if ($(".wysiwyg-content .accordion").length > 0) {
    $(".wysiwyg-content .accordion .info").hide();

    $(".wysiwyg-content .accordion .trigger").click(function(e) {
      e.preventDefault();

      if ($(this).next(".info").is(":visible")) {
        $(this).find("span").css("background-position", "0 -21px");
      } else {
        $(this).find("span").css("background-position", "0 0");
      }

      $(this).next(".info").slideToggle("fast");


    });
  }
}
;var Cookie = {
    setCookie: function(name,value,days) {
        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime()+(days*24*60*60*1000));
            expires = "; expires="+date.toGMTString();
        }
        document.cookie = name+"="+value+expires+"; path=/";
    },

    getCookie: function(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
            var c = ca[i];
            while (c.charAt(0)==' ') c = c.substring(1,c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
        }
        return null;
    },

    deleteCookie: function(name) {
        Cookie.setCookie(name,"",-1);
    }
};
;var DropdownForCheckbox = {

    $dropdownForCheckbox: null,

    init: function() {

        if ( $( ".dropdown-for-checkbox" ).length === 0 ) return;

        $( ".dropdown-for-checkbox-input" ).change( DropdownForCheckbox.checkboxChanged );
        $( ".dropdown-for-checkbox__inner-input" ).change( DropdownForCheckbox.innerCheckboxChanged );

        $( ".dropdown-for-checkbox__close" ).click( DropdownForCheckbox.triggerCloseDropdown );
        $( ".dropdown-for-checkbox-trigger" ).click( DropdownForCheckbox.triggerOpenDropdown );

    },

    checkboxChanged: function() {

        var $this = $( this );
        var $dropdown = $this.closest( ".dropdown-for-checkbox-container" ).find( ".dropdown-for-checkbox" );

        if ( $this.prop( "checked" ) ) {
            DropdownForCheckbox.openDropdown( $dropdown );
            DropdownForCheckbox.checkAllOptions( $dropdown );
            return;
        }

        DropdownForCheckbox.closeDropdown( $dropdown );
        DropdownForCheckbox.uncheckAllOptions( $dropdown );

    },

    innerCheckboxChanged: function() {

        var $this = $( this );
        var $parentCheckbox = $this.closest(".dropdown-for-checkbox-container").find(".dropdown-for-checkbox-input" );
        if ( $this.prop( "checked" ) ) {
            $parentCheckbox.prop( "checked", true );
        } else {

            //check if all inner checkboxes are unchecked
            var $innerCheckboxes = $this.closest(".dropdown-for-checkbox" ).find(".dropdown-for-checkbox__inner-input");
            var areAllTurnedOff = true;

            for(var i=0; i<$innerCheckboxes.length; i++) {

                var $innerCheckbox = $innerCheckboxes.eq( i );

                if ( $innerCheckbox.prop( "checked" ) ) areAllTurnedOff = false;

            }

            if ( areAllTurnedOff ) {

                $parentCheckbox.prop( "checked", false );

            }


        }
    },

    triggerCloseDropdown: function( e ) {

        e.preventDefault();

        var $dropdown = $( this ).closest( ".dropdown-for-checkbox-container" ).find( ".dropdown-for-checkbox" );
        DropdownForCheckbox.closeDropdown( $dropdown );

    },

    closeDropdown: function( $dropdown ) {

        $dropdown.hide();

    },

    triggerOpenDropdown: function() {
		var $allDropdowns = $( ".where-to-buy-filters__show" ).find( ".dropdown-for-checkbox" );
		DropdownForCheckbox.closeDropdown( $allDropdowns );
        var $dropdown = $( this ).closest( ".dropdown-for-checkbox-container" ).find( ".dropdown-for-checkbox" );
        DropdownForCheckbox.openDropdown( $dropdown );

    },

    openDropdown: function( $dropdown ) {

        $dropdown.show();

    },

    checkAllOptions: function( $dropdown ) {

        $dropdown.find( "input" ).prop( "checked", true );
    },

    uncheckAllOptions: function( $dropdown ) {

        $dropdown.find( "input" ).prop( "checked", false );
    }

};

$( document ).ready( function() {
    DropdownForCheckbox.init();
} );
;$(document).ready(initSwiper());

function initSwiper() {
  if ($(".header-swiper .swiper-container").length > 0) {
    //create image tags for sneaks
    var imageLeft = document.createElement("img");
    var imageRight = document.createElement("img");
    imageLeft.setAttribute("src", "");
    imageRight.setAttribute("src", "");
    $(".swiper-container .sneakpeak-left").append(imageLeft);
    $(".swiper-container .sneakpeak-right").append(imageRight);

    headSwiper = $('.header-swiper .swiper-container').swiper({
      mode: 'horizontal',
      loop: true,
      onlyExternal: false,
      simulateTouch: false,
      speed: 500,
      calculateHeight: true,
      autoplayDisableOnInteraction: false,
      roundLengths: true,
      onSwiperCreated: function(swiper) {
        //fix full backgrounds
        $(".swiper-container .swiper-slide").each(function(index) {

          if( $(this).find("img.bg-image").length>0 ){
            $(this).backstretch($(this).find("img.bg-image").attr("src"));
          }

          $(this).attr("id", "slide-" + index);

          lastSlideId = index;
        });

        lastSlideId--;

        fixSneakpeeks(0);
      },
      onSlideChangeEnd: function(swiper) {
        fixSneakpeeks(swiper.activeLoopIndex);

        $(".header-swiper .swiper-container .sneakpeak-left").css("left", "-46px");
        $(".header-swiper .swiper-container .sneakpeak-right").css("right", "-46px");
        $(".header-swiper .swiper-container .swiper-slide .content").fadeIn();
        $(".header-swiper .swiper-container .arrow-left").fadeIn();
        $(".header-swiper .swiper-container .arrow-right").fadeIn();
      }
    });

    //autoplaying
    var autoplaying = true;
    $(".header-swiper .swiper-container").hover(
      function(e){
        autoplaying = false;
      },
      function(e){
        autoplaying = true;
      }
    );
    setInterval(function(){
      if(autoplaying){
        if (isTabletSize || isMobile) {
          headSwiper.swipeNext();
        } else {
          swiperAnimateNext();
        }
      }
    }, 5000);

  }

  $('.header-swiper .swiper-container .arrow-left').click(function(e) {
    e.preventDefault();

    if (isTabletSize || isMobile) {
      headSwiper.swipePrev();
    } else {
      swiperAnimatePrev();
    }

  });

  $('.header-swiper .swiper-container .arrow-right').click(function(e) {
    e.preventDefault();

    if (isTabletSize || isMobile) {
      headSwiper.swipeNext();
    } else {
      swiperAnimateNext();
    }
  });

}

function fixSneakpeeks(activeId) {
  var leftId;
  var rightId;

  activeId++;

  leftId = activeId - 1;
  rightId = activeId + 1;

  if (leftId <= 0) {
    leftId = lastSlideId;
  }

  if (rightId > lastSlideId) {
    rightId = 1;
  }

  $(".header-swiper .swiper-container .sneakpeak-left img").attr("src", $("#slide-" + leftId).attr("data-cut-left"));
  $(".header-swiper .swiper-container .sneakpeak-right img").attr("src", $("#slide-" + rightId).attr("data-cut-right"));
}

function swiperAnimatePrev() {
  fadeSwipeContentOut();

  setTimeout(function() {
    headSwiper.swipePrev();
  }, 500);

}

function swiperAnimateNext() {
  fadeSwipeContentOut();

  setTimeout(function() {
    headSwiper.swipeNext();
  }, 500);

}

function fadeSwipeContentOut() {
  $(".header-swiper .swiper-container .sneakpeak-left").css("left", "-270px");
  $(".header-swiper .swiper-container .sneakpeak-right").css("right", "-270px");
  $(".header-swiper .swiper-container .swiper-slide .content").fadeOut();
  $(".header-swiper .swiper-container .arrow-left").fadeOut();
  $(".header-swiper .swiper-container .arrow-right").fadeOut();

}

function onOrientationChange() {
  if ($(".header-swiper .swiper-container").length > 0) {
    $(".header-swiper .swiper-container .swiper-slide").each(function(index) {
      if( $(this).find("img.bg-image").length>0 ){
        $(this).backstretch($(this).find("img.bg-image").attr("src"));
      }
    });
  }
}
;$(document).ready(function() {

	LazyLoadEcatPage.init();

});

var LazyLoadEcatPage = (function() {

	var self = {}, // Create object for public vars and methods
			$iframe = $('.main-content iframe'),
			$loading = $('.main-content .loading'),
			$url = "https://denso.elcome.co.uk/ecat/Catalogue",
      $urlVars = "";

	self.init = function() {
		if($iframe.attr("src")){
		  loadIframe();
		}
	};

  function loadIframe(){
    if($iframe.attr("src").substring(0,11)==="about:blank"){
      $urlVars = $iframe.attr("src").substring(11,$iframe.attr("src").length);
      $iframe.hide();
      $iframe.attr("src", $url+$urlVars);
      $iframe.load(function(){
        $loading.hide();
        $iframe.show();
      });
    }
  }

	return self; // Return all public vars and methods

})();;$(document).ready(function() {

	LazyLoadEcat.init();

});

var LazyLoadEcat = (function() {

	var self = {}, // Create object for public vars and methods
			$ecatButton = $('.find-trigger.e-cat'),
      $findBar = $('.find-bar'),
			$iframe = $('.found-block#ecat iframe'),
			$loading = $('.found-block#ecat .loading'),
			$url = "https://denso.elcome.co.uk/ecat/home",
      $urlVars = "";

	self.init = function() {
		// loadIframe();
	};

  function loadIframe(){
    $ecatButton.click(function(e){
      if($iframe.attr("src").substring(0,11)==="about:blank"){
        $urlVars = $iframe.attr("src").substring(11,$iframe.attr("src").length);
        $iframe.hide();
        $iframe.attr("src", $url+$urlVars);
        $findBar.height("120px");
        $iframe.load(function(){
          $loading.hide();
          $iframe.show();
          neededHeight = $iframe.outerHeight() + 80;
          $findBar.height(neededHeight + "px");
        });
      }
    });
  }

	return self; // Return all public vars and methods

})();;var productIntervalId;
var products = [];
var totalAmountOfProducts;
var activeProduct = 0;

$(document).ready(initProductSwitch());

function initProductSwitch() {
  if ($(".product-slider").length > 0) {

    var isHovering = false;
    var switchTime = 5000;

    products = $(".product-slider .product");
    totalAmountOfProducts = products.length - 1;

    //give each product an id
    products.each(function(index) {
      $(this).attr("id", index);
    });

    setActiveProduct();

    //make it switch
    if(totalAmountOfProducts>1){
      productIntervalId = setInterval(switchToProduct, switchTime);
    }

    /*-- HOVER PRODUCT --*/
    $(".product-slider").hover(
      function() {
        isHovering = true;
        clearInterval(productIntervalId);
      },
      function() {
        isHovering = false;
        productIntervalId = setInterval(switchToProduct, switchTime);
      }
    );

    /*-- CLICK PRODUCT --*/
    $(".product-trigger").click(function(e) {
      e.preventDefault();

      var addActiveClass = true;

      if( isTabletSize && $(this).parent().hasClass("active") ){
        addActiveClass=false;
      }

      $(products).removeClass("active");

      if(addActiveClass){
        $(this).parent().addClass("active");
      }
      backstretchProductImage(this);
      activeProduct = parseInt($(this).parent().attr("id"));

    });

  }
}

function switchToProduct() {
  if( !isTabletSize ) {
    activeProduct++;
    if (activeProduct > totalAmountOfProducts) {
      activeProduct = 0;
    }

    products.removeClass("active");

    setActiveProduct();
  }
}

function setActiveProduct(){
  $(products[activeProduct]).addClass("active");
  backstretchProductImage(products[activeProduct]);
}

function backstretchProductImage(elem) {
  var productImage =  $(elem).find(".product-information").find(".product-image");



  if(productImage.length){
    if(productImage.find("img")){
      productImage.backstretch(productImage.find("img").attr("src"));
      productImage.find("img").hide();
    }
  }


}

function onResizeProductSlider(){ //call to this function in script.js
  //backstrech current image
  backstretchProductImage(products[activeProduct]);

  if(!isTabletSize && !$(products).hasClass("active") ){
    activeProduct=0;
    setActiveProduct();
  }
};var SessionStorage = {

    set: function(name,value) {

        sessionStorage[name] = value;

    },

    get: function(name) {

        return sessionStorage[name];

    }

};
;var WhereToBuy = {

    //user settings
    sessionNameStoredGeolocationPermission: 'whereToBuy-storedPermission',
    sessionNameStoredCurrentPlacename: 'whereToBuy-storedCurrentPlacename',
    sessionNameStoredCurrentLat: 'whereToBuy-storedCurrentLat',
    sessionNameStoredCurrentLng: 'whereToBuy-storedCurrentLng',
    sessionNameCurrentPageNumber: 'whereToBuy-storedCurrentPageNumber',

    //filter settings
    sessionNameStoredFilterLocationUserInput: 'whereToBuy-storedFilterLocationUserInput',
    sessionNameStoredFilterLocationUserEnglish: 'whereToBuy-storedFilterLocationUserEnglish',
    sessionNameStoredFilterLocationLat: 'whereToBuy-storedFilterLocationLat',
    sessionNameStoredFilterLocationLng: 'whereToBuy-storedFilterLocationLng',
    sessionNameStoredFilterIsContry: 'whereToBuy-storedFilterIsCountry',
    sessionNameStoredFilterKeyword: 'whereToBuy-storedFilterKeyword',
    sessionNameStoredFilterAftermarketDistributor: 'whereToBuy-storedFilterAftermarketDistributor',
    sessionNameStoredFilterAftermarketSubDistributor: 'whereToBuy-storedFilterAftermarketSubDistributor',
    sessionNameStoredFilterAftermarketRetail: 'whereToBuy-storedFilterAftermarketRetail',
    sessionNameStoredFilterAftermarketOnline: 'whereToBuy-storedFilterAftermarketOnline',
    sessionNameStoredFilterAC: 'whereToBuy-storedFilterAC',
    sessionNameStoredFilterDiagnostics: 'whereToBuy-storedFilterDiagnostics',
    sessionNameStoredFilterDiesel: 'whereToBuy-storedFilterDiesel',
    sessionNameStoredFilterStation: 'whereToBuy-storedFilterStation',

    gettingNewResults: false,
    autocomplete: null,
    map: null,
    markers: [],
    infowindows: [],
    prevActiveKey: -1,
    bounds: null,
    markerClusterer: null,

    locationMarker: null,

    $loader: null,
    $form: null,
    $noResults: null,
    pageSize: null,

    $mailForm: null,

    $currentLocationLatHiddenInput: null,
    $currentLocationLngHiddenInput: null,

    $locationSearchInputUser: null,
    $locationSearchInputEnglish: null,
    $locationSearchLatHiddenInput: null,
    locationDefaultData: null,
    $locationSearchLngHiddenInput: null,
    $locationSearchIsCountryHiddenInput: null,
    $locationSearchCountryStringHiddenInput: null,
    $keywordSearchInput: null,
    $typeSelect: null,
    $aftermarketsDistributorCheckbox: null,
    $aftermarketDistributorCheckbox: null,
    $aftermarketSubDistributorCheckbox: null,
    $aftermarketRetailCheckbox: null,
    $aftermarketOnlineCheckbox: null,
    $servicesCheckbox: null,
    $acCheckbox: null,
    $stationCheckbox: null,
    $diagnosticsCheckbox: null,
    $dieselCheckbox: null,
    $hiddenPageNumberInput: null,

    $filters: null,
    $filterTrigger: null,

    $googleMaps: null,
    mapIsFinishedInitting: false,
    mapIdleTimer: null,
    maxZoom: null,
    geocoder: null,

    $totalResultsLabel: null,
    $results: null,
    $resultList: null,

    totalCount: 0,
    WhereToBuy: [],

    currentDomain: '',
    currentDomainLatLng: null,
    default_keyword_zoom_level: 2,
    init: function () {

        if ($(".where-to-buy").length === 0) return;
        WhereToBuy.getElements();

        if (sessionStorage.getItem(WhereToBuy.sessionNameCurrentPageNumber)) {
            WhereToBuy.$hiddenPageNumberInput.val(sessionStorage.getItem(WhereToBuy.sessionNameCurrentPageNumber));
        } else {
            sessionStorage.setItem(WhereToBuy.sessionNameCurrentPageNumber, 1);
            WhereToBuy.$hiddenPageNumberInput.val("1");
        }

        WhereToBuy.initFilterTrigger();

        WhereToBuy.initGoogleMaps();

        WhereToBuy.showStoredFilters();

        WhereToBuy.initAutoCompleteLocationField();
        WhereToBuy.initAutoCompleteKeywordField();

        WhereToBuy.$typeSelect.change(WhereToBuy.changeSearchType);

        WhereToBuy.$form.submit(WhereToBuy.submitForm);

        WhereToBuy.saveFilters();

        WhereToBuy.initShare();

        WhereToBuy.initAddressHover();

        WhereToBuy.initMailForm(false);

    },

    getElements: function () {

        WhereToBuy.$loader = $(".where-to-buy__loader");
        WhereToBuy.$form = $(".where-to-buy-form");
        WhereToBuy.$noResults = $(".where-to-buy__no-results");

        WhereToBuy.$mailForm = $(".mail-form");

        WhereToBuy.$currentLocationLatHiddenInput = $(".where-to-buy-search-bar__current-location-lat");
        WhereToBuy.$currentLocationLngHiddenInput = $(".where-to-buy-search-bar__current-location-lng");

        WhereToBuy.$keywordSearchList = $(".where-to-buy__keyword-list");
        WhereToBuy.$locationSearchInputUser = $(".where-to-buy-search-bar__input--location-user");
        WhereToBuy.$locationSearchInputEnglish = $(".where-to-buy-search-bar__input--location-english");
        WhereToBuy.$locationSearchLatHiddenInput = $(".where-to-buy-search-bar__search-location-lat");
        WhereToBuy.$locationSearchLngHiddenInput = $(".where-to-buy-search-bar__search-location-lng");
        WhereToBuy.$locationSearchIsCountryHiddenInput = $(".where-to-buy-search-bar__search-location-is-country");
        WhereToBuy.$locationSearchCountryStringHiddenInput = $(".where-to-buy-search-bar__search-location-country-string");
        WhereToBuy.$keywordSearchInput = $(".where-to-buy-search-bar__input--keyword");
        WhereToBuy.$typeSelect = $(".where-to-buy-search-bar__search-type select");
        WhereToBuy.$aftermarketsDistributorCheckbox = $(".where-to-buy-filters__show-aftermarket .style-checkbox input");
        WhereToBuy.$servicesCheckbox = $(".where-to-buy-filters__show-garages .style-checkbox input");

        WhereToBuy.$aftermarketDistributorCheckbox = $(".where-to-buy-filters__aftermarketdistributor input");
        WhereToBuy.$aftermarketSubDistributorCheckbox = $(".where-to-buy-filters__aftermarketsubdistributor input");
        WhereToBuy.$aftermarketRetailCheckbox = $(".where-to-buy-filters__aftermarketretail input");
        WhereToBuy.$aftermarketOnlineCheckbox = $(".where-to-buy-filters__aftermarketonline input");

        WhereToBuy.$acCheckbox = $(".where-to-buy-filters__ac input");
        WhereToBuy.$stationCheckbox = $(".where-to-buy-filters__station input");
        WhereToBuy.$diagnosticsCheckbox = $(".where-to-buy-filters__diagnostics input");
        WhereToBuy.$dieselCheckbox = $(".where-to-buy-filters__diesel input");

        WhereToBuy.$filters = $(".where-to-buy-filters");
        WhereToBuy.$filterTrigger = $(".where-to-buy-filters-trigger");

        WhereToBuy.$googleMaps = $(".where-to-buy-map__google-maps");

        WhereToBuy.$hiddenPageNumberInput = $(".where-to-buy-search-bar__page-number");

        WhereToBuy.$results = $(".where-to-buy-search-results");
        WhereToBuy.$resultList = $(".where-to-buy-search-results__list");
        WhereToBuy.$totalResultsLabel = $(".where-to-buy-search-results__total");

        WhereToBuy.pageSize = parseInt(WhereToBuy.$results.data("page-size"));

    },

    initFilterTrigger: function () {

        WhereToBuy.$filterTrigger.click(WhereToBuy.toggleFilters);
        WhereToBuy.$filters.find("input, select").change(WhereToBuy.submitForm);

    },

    toggleFilters: function (e) {

        WhereToBuy.$filters.toggle();

    },

    initShare: function () {

        $("body").on("click", ".where-to-buy-search-results__share", WhereToBuy.shareItem);

    },

    initAddressHover: function () {

        $("body").on("click", ".where-to-buy-search-results__info--address", WhereToBuy.toggleActiveLinkedMarker);
        $("body").on("mouseover", ".where-to-buy-search-results__info--address", WhereToBuy.toggleActiveLinkedMarker);
        $("body").on("mouseout", ".where-to-buy-search-results__info--address", WhereToBuy.toggleActiveLinkedMarker);

    },

    toggleActiveLinkedMarker: function (e) {

        e.preventDefault();

        if (e.type === "click") return;

        var $listItem = $(this).closest(".where-to-buy-search-results__list-item");

        var key = $listItem.data("key");
        var marker = WhereToBuy.markers[key];

        var isActive = false;
        if (e.type === "mouseover") isActive = true;

        WhereToBuy.setMarkerIcon(marker, isActive);

    },

    setMarkerIcon: function (marker, isActive) {

        var imageSize = 66;
        var active = "";

        if (isActive) {
            active = "-active";
            imageSize = 111;
        }

        var icon = {
            url: "../images/gm-icons/" + marker.type + active + ".png",
            size: new google.maps.Size(imageSize, imageSize),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point((imageSize / 2), (imageSize / 2))
        };

        marker.setZIndex(google.maps.Marker.MAX_ZINDEX + 1);
        marker.setIcon(icon);

    },

    initMailForm: function (fromAsync) {

        if (WhereToBuy.$mailForm.length === 0) return;

        WhereToBuy.$mailForm.on("click", ".close", WhereToBuy.closeMailForm);

        if (!fromAsync) return;

        if (WhereToBuy.$mailForm.find("#returnMessage").length === 0) {
            WhereToBuy.$mailForm.find("#shareForm").show();
            WhereToBuy.$mailForm.find("#returnMessage").hide();
        } else {
            WhereToBuy.$mailForm.find("#shareForm").hide();
            WhereToBuy.$mailForm.find("#returnMessage").show();
        }

    },

    closeMailForm: function (e) {

        e.preventDefault();
        var $mailForm = $(this).closest(".mail-form");
        $mailForm.find("#returnMessage").remove();
        $mailForm.hide();

    },

    shareItem: function (e) {

        e.preventDefault();

        var $listItem = $(this).closest(".where-to-buy-search-results__list-item");

        //add mail form to item
        $listItem.append(WhereToBuy.$mailForm);

        var title = $listItem.find(".where-to-buy-search-results__title").text();
        var address = $listItem.find(".where-to-buy-search-results__info--address .address").text();
        var postcode = $listItem.find(".where-to-buy-search-results__info--address .postcode").text();
        var city = $listItem.find(".where-to-buy-search-results__info--address .city").text();

        var showAddress = address;
        if (city !== "") showAddress += "; " + city;

        var details = title + ": " + address;
        if (postcode !== "") details += ", " + postcode;
        if (city !== "") details += "; " + city;

        //fill hidden inputs
        WhereToBuy.$mailForm.find(".mail-form__hidden-postcode").val(postcode || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-type").val($listItem.find(".where-to-buy-search-results__type").text() || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-title").val(title || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-address").val(showAddress || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-phone").val($listItem.find(".where-to-buy-search-results__info--phone").text() || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-details").val(details || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-mail").val($listItem.find(".where-to-buy-search-results__info--mail").text() || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-site").val($listItem.find(".where-to-buy-search-results__info--website").text() || " ");
        WhereToBuy.$mailForm.find(".mail-form__hidden-distance").val($listItem.find(".where-to-buy-search-results__distance").text() || " ");

        //show
        WhereToBuy.$mailForm.find("#shareForm").show();
        WhereToBuy.$mailForm.show();

    },

    getUserLocation: function () {

        var placeOfUser = SessionStorage.get(WhereToBuy.sessionNameStoredCurrentPlacename);
        var permission = SessionStorage.get(WhereToBuy.sessionNameStoredGeolocationPermission);

        if (placeOfUser) {

            WhereToBuy.showUserLocation(placeOfUser);

        } else if (navigator.geolocation) {

            if (permission === "false") {
                return;
            }

            navigator.geolocation.getCurrentPosition(WhereToBuy.getUserLocationResult, WhereToBuy.geolocationError);
        }

    },

    geolocationError: function (error) {

        if (error.code === 1) {
            SessionStorage.set(WhereToBuy.sessionNameStoredGeolocationPermission, "false");
            // WhereToBuy.applyFilters();
        }

    },

    getUserLocationResult: function (position) {

        SessionStorage.set(WhereToBuy.sessionNameStoredGeolocationPermission, "true");

        WhereToBuy.setUserPlaceFromLatLng(position.coords.latitude, position.coords.longitude);

    },

    setUserPlaceFromLatLng: function (lat, lng) {

        var latlng = {
            "lat": lat,
            "lng": lng
        };

        SessionStorage.set(WhereToBuy.sessionNameStoredCurrentLat, lat);
        SessionStorage.set(WhereToBuy.sessionNameStoredCurrentLng, lng);

        WhereToBuy.geocoder.geocode({'location': latlng}, function (results, status) { // status is empty
            if (status == google.maps.GeocoderStatus.OK) {

                var placeOfUser = results[0].address_components[3].long_name;

                SessionStorage.set(WhereToBuy.sessionNameStoredCurrentPlacename, placeOfUser);

                WhereToBuy.showUserLocation();
            }
        });

    },

    setDefaultLocation: function () {


        var current_domain = config.siteCountry;

        // When on localhost default to NL
        if (current_domain === "localhost" || current_domain === "local") {
            current_domain = "de";
        }

        WhereToBuy.currentDomain = current_domain;
        //Send request 4 country info
        WhereToBuy.geocoder.geocode({
            componentRestrictions: {
                country: current_domain
            }
        }, function (results, status) {
            if (status == 'OK') {

                WhereToBuy.$locationSearchInputUser.attr("placeholder", WhereToBuy.$locationSearchInputUser.data("location-text") + " '" + results[0].address_components[0].long_name);
                // Here we set bounds form country
                WhereToBuy.map.fitBounds(results[0].geometry.bounds);
                WhereToBuy.maxZoom = WhereToBuy.map.getZoom();

                var listener = google.maps.event.addListener(WhereToBuy.map, "idle", function () {
                    google.maps.event.removeListener(listener);

                    // Disables zoom & scroll event handlers
                    WhereToBuy.mapIsFinishedInitting = false;

                    var lat = WhereToBuy.$locationSearchLatHiddenInput.val();
                    var lng = WhereToBuy.$locationSearchLngHiddenInput.val();
                    var latLng = new google.maps.LatLng(lat, lng);

                    //Saves default location data
                    WhereToBuy.locationDefaultData = results[0];
                    WhereToBuy.$locationSearchIsCountryHiddenInput.val("1")

                    // 0.0 near Africa if first load & locationSearchInputUser empty
                    WhereToBuy.currentDomainLatLng = latLng;

                    if( WhereToBuy.$keywordSearchInput.val() !== ""){
                      WhereToBuy.map.panTo(latLng);
                      WhereToBuy.map.setZoom(WhereToBuy.default_keyword_zoom_level);
                    } else if( WhereToBuy.$locationSearchInputUser.val() !== "" ){
                        WhereToBuy.map.panTo(latLng);
                        WhereToBuy.submitForm();
                    } else {
                        var location = WhereToBuy.locationDefaultData.address_components[0].long_name;
                        // Here we set location to filter markers on map (has't any reletionship to map position)
                        WhereToBuy.getAllMarkers(location);
                    }

                });


            }
        });

    },
    showUserLocation: function () {

        var lat = SessionStorage.get(WhereToBuy.sessionNameStoredCurrentLat);
        var lng = SessionStorage.get(WhereToBuy.sessionNameStoredCurrentLng);

        WhereToBuy.$currentLocationLatHiddenInput.val(lat);
        WhereToBuy.$currentLocationLngHiddenInput.val(lng);

        WhereToBuy.setLocationMarker();

    },

    createCurrentLocationInMap: function (lat, lng) {

        var imgUrl = "../images/gm-icons/current-location.png";
        var imgSize = 63;

        return WhereToBuy.newMarker(imgUrl, imgSize, lat, lng, "", "location");

    },

    initAutoCompleteLocationField: function () {

        WhereToBuy.autocomplete = new google.maps.places.Autocomplete(document.getElementById('googlemap-autocomplete'),{fields:["ALL"]});
        WhereToBuy.autocomplete.addListener('place_changed', WhereToBuy.prefillSearchLocation);
        WhereToBuy.$locationSearchInputUser.keydown(WhereToBuy.stopEnterToSubmit);

    },

    stopEnterToSubmit: function (e) {

        if (e.keyCode == 13 && WhereToBuy.$locationSearchInputUser.val() !== "") {

            e.preventDefault();

        }

    },
    prefillSearchLocation: function () {

        WhereToBuy.foundCoordinates = true;

        var place = WhereToBuy.autocomplete.getPlace();

        WhereToBuy.$locationSearchIsCountryHiddenInput.val("");

        //For base location
        if (WhereToBuy.$locationSearchInputUser.val() === ""){
            if (!WhereToBuy.locationDefaultData) WhereToBuy.setDefaultLocation();

            // coz default location is country
            WhereToBuy.$locationSearchIsCountryHiddenInput.val("1");
            //! Disables  markers render on zoom & scroll
            WhereToBuy.mapIsFinishedInitting = false;

            WhereToBuy.map.fitBounds(WhereToBuy.locationDefaultData.geometry.bounds);
            var lat = WhereToBuy.locationDefaultData.geometry.location.lat();
            var lng = WhereToBuy.locationDefaultData.geometry.location.lng();

            WhereToBuy.$locationSearchLatHiddenInput.val(lat);
            WhereToBuy.$locationSearchLngHiddenInput.val(lng);

            WhereToBuy.submitForm();
            return;
        }

        if (typeof place === "undefined" || typeof place.geometry === "undefined") {

            var searchWith = "";
            if (typeof place === "undefined") {
                searchWith =  WhereToBuy.$locationSearchInputUser.val();
            } else {
                searchWith = $(".pac-container .pac-item").eq(0).text();
            }

            var geocoder = new google.maps.Geocoder();
            geocoder.geocode({"address": searchWith}, function (results, status) {

                if (status == google.maps.GeocoderStatus.OK) {

                    WhereToBuy.mapIsFinishedInitting = true;
                    if (results[0].address_components.length === 1 && results[0].address_components[0].types[0] === "country") {
                        WhereToBuy.$locationSearchIsCountryHiddenInput.val("1");
                        //! Disables  markers render on zoom & scroll
                        WhereToBuy.mapIsFinishedInitting = false;
                    }

                    var viewport = results[0].geometry.viewport;
                    WhereToBuy.map.fitBounds(viewport);

                    var lat = results[0].geometry.location.lat();
                    var lng = results[0].geometry.location.lng();
                    var placeName = results[0].formatted_address;

                    WhereToBuy.$locationSearchInputUser.val(placeName);
                    WhereToBuy.$locationSearchLatHiddenInput.val(lat);
                    WhereToBuy.$locationSearchLngHiddenInput.val(lng);
                    WhereToBuy.$locationSearchInputEnglish.val(results[0].formatted_address);

                    WhereToBuy.submitForm();

                }
            });
            return;
        }

        WhereToBuy.mapIsFinishedInitting = true;
        if (WhereToBuy.autocomplete.getPlace().address_components.length === 1 && WhereToBuy.autocomplete.getPlace().address_components[0].types[0] === "country") {
            WhereToBuy.$locationSearchIsCountryHiddenInput.val("1");

            //! Disables  markers render on zoom & scroll
            WhereToBuy.mapIsFinishedInitting = false;
        }

        var position = WhereToBuy.autocomplete.getPlace().geometry.location;
        var viewport = WhereToBuy.autocomplete.getPlace().geometry.viewport;

        WhereToBuy.map.fitBounds(viewport);

        var lat = position.lat();
        var lng = position.lng();

        WhereToBuy.$locationSearchLatHiddenInput.val(lat);
        WhereToBuy.$locationSearchLngHiddenInput.val(lng);

        WhereToBuy.$locationSearchInputEnglish.val(WhereToBuy.autocomplete.getPlace().formatted_address);

        var latLng = new google.maps.LatLng(lat, lng);

        WhereToBuy.submitForm();

    },

    initAutoCompleteKeywordField: function () {
        WhereToBuy.$keywordSearchInput.autocomplete({
            source: config.baseUrl + config.filterUrl.keywords,
            minLength: 3,
            select: function () {
                WhereToBuy.submitForm();
            }
        });

    },

    changeSearchType: function () {

        var type = $(this).val();

        WhereToBuy.showSearchType(type);

    },

    showSearchType: function (type) {

        if (type === "keyword") {
            WhereToBuy.$locationSearchInputUser.val("");
            WhereToBuy.$locationSearchLatHiddenInput.val("");
            WhereToBuy.$locationSearchLngHiddenInput.val("");
            WhereToBuy.$locationSearchIsCountryHiddenInput.val("");
            WhereToBuy.$locationSearchInputUser.hide();

            WhereToBuy.$keywordSearchInput.show();

            return;
        }

        //location
        WhereToBuy.$keywordSearchInput.val("");
        WhereToBuy.$keywordSearchInput.hide();
        WhereToBuy.$locationSearchInputUser.show();
    },

    initGoogleMaps: function () {

        WhereToBuy.geocoder = new google.maps.Geocoder();

        var map_options = {
            backgroundColor: '#AADAFF',
            zoom: 10,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            panControl: true,
            zoomControl: true,
            scrollwheel: false,
            mapTypeControl: false,
            scaleControl: false,
            streetViewControl: false,
            overviewMapControl: false,
            draggable: true,
        };


        WhereToBuy.map = new google.maps.Map(WhereToBuy.$googleMaps[0], map_options);
        WhereToBuy.markerClusterer = new MarkerClusterer( WhereToBuy.map );

        //set up bounds
        WhereToBuy.bounds = new google.maps.LatLngBounds();

        // set default location from website domain or search
        WhereToBuy.setDefaultLocation();

        // use user location to show a location marker
        WhereToBuy.getUserLocation();


        // listen for new bounds and update markers after 500ms of map being idle
        WhereToBuy.map.addListener('zoom_changed', function () {

            if (!WhereToBuy.mapIsFinishedInitting) return;

            WhereToBuy.resetMarkerStuff();
            WhereToBuy.getAllMarkers(false, true);

        });

        WhereToBuy.map.addListener('dragend', function () {

            if (!WhereToBuy.mapIsFinishedInitting) return;

            if (WhereToBuy.mapIdleTimer) clearTimeout(WhereToBuy.mapIdleTimer);

            WhereToBuy.mapIdleTimer = setTimeout(function () {

                WhereToBuy.resetMarkerStuff();
                WhereToBuy.getAllMarkers(false, true);

            }, 500);

        });

    },

    submitForm: function (e) {

        if (e) e.preventDefault();

        if (!WhereToBuy.foundCoordinates) {
            WhereToBuy.prefillSearchLocation();
            return;
        }

        var filterValues = WhereToBuy.$form.serializeObject();

        WhereToBuy.foundCoordinates = false;

        WhereToBuy.resetMarkerStuff();
        WhereToBuy.resetInputs();

        WhereToBuy.saveFilters();

        if(filterValues.keyword){
          var searchingLocation = WhereToBuy.currentDomainLatLng;
          //! Triggers event
          WhereToBuy.map.panTo(searchingLocation);
          WhereToBuy.map.setZoom(WhereToBuy.default_keyword_zoom_level);
          //set Zoom triggers getAllMarkers() through eventlistener of the map
          return;
        }
        var location = false;
        // Independent from form filters value
        if (WhereToBuy.$locationSearchInputUser.val() == "") {
            // Setting default location
            location = WhereToBuy.locationDefaultData.address_components[0].long_name;
        } else if (WhereToBuy.$locationSearchIsCountryHiddenInput.val() == "1"){
                //get country name
                location = WhereToBuy.$locationSearchInputUser.val();
        }

        WhereToBuy.getAllMarkers(location);

    },

    resetMarkerStuff: function () {

        if ( WhereToBuy.markerClusterer ) WhereToBuy.markerClusterer.clearMarkers();

        WhereToBuy.bounds = new google.maps.LatLngBounds();

        for (var i = 0; i < WhereToBuy.markers.length; i++) {
            WhereToBuy.markers[i].setMap(null);
        }

        WhereToBuy.markers = [];
        WhereToBuy.infowindows = [];

    },

    resetInputs: function () {

        if (WhereToBuy.$locationSearchInputUser.val() === "") {
            WhereToBuy.$locationSearchLatHiddenInput.val("");
            WhereToBuy.$locationSearchLngHiddenInput.val("");
            WhereToBuy.$locationSearchIsCountryHiddenInput.val("");
        }

        sessionStorage.setItem(WhereToBuy.sessionNameCurrentPageNumber, "1");
        WhereToBuy.$hiddenPageNumberInput.val("1");
    },
    // TODO: render only new markers
    getAllMarkers: function (location, reset) {

        var bounds = WhereToBuy.map.getBounds();

        WhereToBuy.showLoader();
        WhereToBuy.gettingNewResults = true;

        //get filter values
        var filterValues = WhereToBuy.$form.serializeObject();

        //grab from map bounds
        filterValues.west = bounds.getSouthWest().lng();
        filterValues.south = bounds.getSouthWest().lat();
        filterValues.east = bounds.getNorthEast().lng();
        filterValues.north = bounds.getNorthEast().lat();

        if(location) {
            filterValues.location = location;
            filterValues.isCountry = 1
        }

        if(reset){
            filterValues.location = '';
            filterValues.isCountry = 0;
        }

        filterValues.zoomLevel = WhereToBuy.map.getZoom();

        $.ajax({
            type: "GET",
            url: config.baseUrl + "/api/v1/locations/box/",
            data: filterValues,
            success: function (data) {
                WhereToBuy.items = data.items;
                WhereToBuy.totalCount = data.totalCount;
                WhereToBuy.showSearchResult(data.totalCount, data.items);
                WhereToBuy.gettingNewResults = false;
                WhereToBuy.hideLoader();
            },
            error: function (jqXHR, textStatus) {
                WhereToBuy.hideLoader();
                WhereToBuy.gettingNewResults = false;
            },
            dataType: 'json'
        });

    },

    setLocationMarker: function () {

        //reset location marker
        if (WhereToBuy.locationMarker !== null) {
            WhereToBuy.locationMarker.setMap(null);
            WhereToBuy.locationMarker = null;
        }

        var locationMarkerLat = "";
        var locationMarkerLng = "";

        //show correct location marker
        if (SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationUserInput) === "") {
            locationMarkerLat = SessionStorage.get(WhereToBuy.sessionNameStoredCurrentLat);
            locationMarkerLng = SessionStorage.get(WhereToBuy.sessionNameStoredCurrentLng);

        } else {
            locationMarkerLat = SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationLat);
            locationMarkerLng = SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationLng);
        }

        if (typeof locationMarkerLat === "undefined") return;

        WhereToBuy.locationMarker = WhereToBuy.createCurrentLocationInMap(locationMarkerLat, locationMarkerLng);

        WhereToBuy.locationMarker.setMap(WhereToBuy.map);

    },

    showSearchResult: function (totalItems, items) {

        var clusterStyle = {
            url: '../images/gm-icons/m3.png',
            height: 66,
            width: 66,
            textSize: 1,
            textColor: '#333333',
            anchor: [16, 0]
        };


        var clusterOptions = {
            imagePath: '',
            styles: [
                clusterStyle,
                clusterStyle,
                clusterStyle
            ]
        };

        //put amount in results text
        WhereToBuy.$totalResultsLabel.find(".total").text(totalItems);
        WhereToBuy.$totalResultsLabel.show();

        //clear search list
        WhereToBuy.$resultList.html("");

        //scroll to the top
        if (WhereToBuy.$results.scrollTop() > 0) WhereToBuy.$results.animate({'scrollTop': 0}, 400);

        //set the correct location marker
        // WhereToBuy.setLocationMarker();

        //no items
        if (totalItems === 0) {
            WhereToBuy.$noResults.show();
            return;
        }

        //found items
        WhereToBuy.$noResults.hide();

        var resultHTMLString = "";

        var mapBounds = WhereToBuy.map.getBounds();
        // var t0 = performance.now();

        WhereToBuy.resetMarkerStuff();

        for (var i = 0, len = items.length; i < len; i++) {

            var item = items[i];

            if (item.lat === "" || item.lng === "") {
                continue; //dont show markers without lat lng
            }

            var type = item.type;
            var title = item.title;
            var address = item.address;
            var postcode = item.postcode;
            var city = item.city;
            var phone = item.phone;
            var mail = item.mail;
            var url = item.url;
            var distance = item.distance;
            var googleMapUrl = "https://www.google.nl/maps/dir//" + item.lat + "," + item.lng + "/";
            var lat = item.lat;
            var lng = item.lng;
            var latLng = new google.maps.LatLng(lat, lng);
            var subcategory = item.subcategory;

            if (mapBounds.contains(latLng)) {
                var key = WhereToBuy.markers.length;

                var itemHTML = WhereToBuy.createItemHTML(key, type, title, address, postcode, city, phone, mail, url, distance, googleMapUrl, false, subcategory);
                var itemInfoWindowHTML = WhereToBuy.createItemHTML(key, type, title, address, postcode, city, phone, mail, url, distance, googleMapUrl, true, subcategory);

                //createinfowindow also puts marker in wheretobuy.markers array fo the clusterer!
                WhereToBuy.createInfoWindow(key, lat, lng, title, type, itemInfoWindowHTML);

                resultHTMLString += itemHTML;
            }
        }

        WhereToBuy.markerClusterer = new MarkerClusterer( WhereToBuy.map, WhereToBuy.markers, clusterOptions );

        WhereToBuy.$resultList.html(resultHTMLString);

        // var t1 = performance.now();
    },

    createInfoWindow: function (key, lat, lng, title, type, itemInfoWindowHTML) {

        // WhereToBuy.infowindows[key] = new InfoBubble({
        //     map: WhereToBuy.map,
        //     shadowStyle: 1,
        //     arrowSize: 15,
        //     disableAutoPan: true,
        //     padding: 0,
        //     maxWidth: 360,
        //     disableAnimation: true,
        //     closeSrc: "../images/icons/icn_close.svg"
        // });
        //
        // WhereToBuy.infowindows[key].itemInfoWindowHTML = itemInfoWindowHTML;

        var imgUrl = "../images/gm-icons/" + type + ".png";
        var imgSize = 66;

        WhereToBuy.markers[key] = WhereToBuy.newMarker(imgUrl, imgSize, lat, lng, title, type);

        google.maps.event.addListener(WhereToBuy.markers[key], "click", function(){

            var allListItems = $('.where-to-buy-search-results__list-item');
            var currentEl = $('.where-to-buy-search-results__list-item[data-key="' + key +'"]');
            var scrollAmount = currentEl.offset().top - WhereToBuy.$results.offset().top + WhereToBuy.$results.scrollTop();


            $.each(allListItems, function(i, item) {
                $(item).removeClass('is--active');
            })

            currentEl.addClass('is--active');

            WhereToBuy.$results.animate({
                scrollTop: scrollAmount
            },1000);

            //
        });
        //
        // google.maps.event.addListener(WhereToBuy.infowindows[key], 'closeclick', WhereToBuy.closeInformationWindow(key));

    },

    newMarker: function (imgUrl, imgSize, lat, lng, title, type) {

        var latlng = new google.maps.LatLng(parseFloat(lat), parseFloat(lng));

        var anchorX = imgSize / 2;
        var anchorY = imgSize / 2;
        var zIndex = 0;

        if (type === "location") {
            anchorY = 50;
            zIndex = google.maps.Marker.MAX_ZINDEX + 1;
        }

        var image = {
            url: imgUrl,
            size: new google.maps.Size(imgSize, imgSize),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(anchorX, anchorY)
        };

        //bounds
        WhereToBuy.bounds.extend(latlng);

        return new google.maps.Marker({
            position: latlng,
            title: title,
            icon: image,
            type: type,
            // map: WhereToBuy.map,
            zIndex: zIndex
        });

    },

    closeInformationWindow: function (key) {

        return function () {

            var marker = WhereToBuy.markers[key];
            WhereToBuy.setMarkerIcon(marker, false);

        };

    },

    showInformationWindow: function (key) {

        return function () {

            if (( key == WhereToBuy.prevActiveKey) && WhereToBuy.infowindows[key].isOpen()) return;

            var html = WhereToBuy.infowindows[key].itemInfoWindowHTML;
            var marker = WhereToBuy.markers[key];

            //close the previous opened infowindow so no more then 1 is open at a time
            if (WhereToBuy.prevActiveKey > 0) {
                WhereToBuy.infowindows[WhereToBuy.prevActiveKey].close();
                WhereToBuy.setMarkerIcon(WhereToBuy.markers[WhereToBuy.prevActiveKey], false);
            }

            //set the active icon for the marker
            WhereToBuy.setMarkerIcon(marker, true);
            marker.setZIndex(google.maps.Marker.MAX_ZINDEX + 1);

            //set infoWindow content
            WhereToBuy.infowindows[key].setContent(html);

            //open the infowindow
            WhereToBuy.infowindows[key].open(WhereToBuy.map, marker);

            WhereToBuy.prevActiveKey = key;

        };

    },

    createItemHTML: function (key, type, title, address, postcode, city, phone, mail, url, distance, googleMapUrl, isForInfoWindow, subcategory) {

        var itemHTMLString = '';

        if (isForInfoWindow) {
            itemHTMLString += '<div class="where-to-buy-search-results__info-window">';
        } else {
            itemHTMLString += '<li class="where-to-buy-search-results__list-item" data-key="' + key + '">';
        }

        itemHTMLString += '<p class="where-to-buy-search-results__type where-to-buy-search-results__type--' + type + '">' + config.language[type] + '</p>';

        if (subcategory !== "") itemHTMLString += '<p class="where-to-buy-search-results__subcategory">' + subcategory + '</p>';

        if (title !== "") itemHTMLString += '<h2 class="where-to-buy-search-results__title">' + title + '</h2>';

        if (address !== "") itemHTMLString += '<p class="where-to-buy-search-results__info where-to-buy-search-results__info--address"><span class="address">' + address + '</span><span class="postcode">' + postcode + '</span><span class="city">' + city + '</span></p>';

        if (phone !== "") itemHTMLString += '<p class="where-to-buy-search-results__info where-to-buy-search-results__info--phone"><a href="tel:' + phone + '" title="' + phone + '">' + phone + '</a></p>';

        if (mail !== "") itemHTMLString += '<p class="where-to-buy-search-results__info where-to-buy-search-results__info--mail"><a href="mailto:' + mail + '" title="' + mail + '">' + mail + '</a></p>';

        if (url !== "") {

            var workingUrl = url;
            var showUrl = url;
            var checkFor = "http://";
            var checkFor2 = "https://";

            if (url.substring(0, checkFor.length) === checkFor) {
                showUrl = url.substring(checkFor.length, url.length);
            } else if (url.substring(0, checkFor2.length) === checkFor2) {
                showUrl = url.substring(checkFor2.length, url.length);
            } else {
                workingUrl = checkFor + workingUrl;
            }

            itemHTMLString += '<p class="where-to-buy-search-results__info where-to-buy-search-results__info--website"><a href="' + workingUrl + '" title = "' + showUrl + '" target="_blank">' + showUrl + '</a></p>';
        }

        if (distance !== "") itemHTMLString += '<p class="where-to-buy-search-results__distance">' + distance + ' km</p>';

        if (!isForInfoWindow) {
            itemHTMLString += '<a class="where-to-buy-search-results__share" href="#" title="Share via email"><img src="../images/icons/share-icon.svg" alt="Share"/></a>';
        }

        itemHTMLString += '<a class="where-to-buy-search-results__direction" target="_blank" href="' + googleMapUrl + '">' + config.language.getDirections + ' &rarr;</a>';

        if (isForInfoWindow) {
            itemHTMLString += '</div>';
        } else {
            itemHTMLString += '</li>';
        }

        return itemHTMLString;
    },

    showLoader: function () {

        WhereToBuy.$loader.show();

    },

    hideLoader: function () {

        WhereToBuy.$loader.hide();

    },

    saveFilters: function () {

        var filterJSON = WhereToBuy.$form.serializeObject();

        SessionStorage.set(WhereToBuy.sessionNameStoredFilterLocationUserInput, filterJSON.locationUserInput);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterLocationUserEnglish, filterJSON.location);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterLocationLat, filterJSON.locationlat);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterLocationLng, filterJSON.locationlng);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterIsContry, filterJSON.isCountry);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterKeyword, filterJSON.keyword);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterAftermarketDistributor, filterJSON.aftermarketDistributor || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterAftermarketSubDistributor, filterJSON.aftermarketSubDistributor || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterAftermarketRetail, filterJSON.aftermarketRetail || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterAftermarketOnline, filterJSON.aftermarketOnline || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterAC, filterJSON.ac || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterStation, filterJSON.station || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterDiagnostics, filterJSON.diagnostics || 0);
        SessionStorage.set(WhereToBuy.sessionNameStoredFilterDiesel, filterJSON.diesel || 0);

    },

    showStoredFilters: function () {

        var locationUserInput = SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationUserInput);
        var locationEnglish = SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationUserEnglish);
        var locationLat = SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationLat);
        var locationLng = SessionStorage.get(WhereToBuy.sessionNameStoredFilterLocationLng);
        var isCountry = SessionStorage.get(WhereToBuy.sessionNameStoredFilterIsContry);
        var keyword = SessionStorage.get(WhereToBuy.sessionNameStoredFilterKeyword);
        var aftermarketDistributor = SessionStorage.get(WhereToBuy.sessionNameStoredFilterAftermarketDistributor);
        var aftermarketSubDistributor = SessionStorage.get(WhereToBuy.sessionNameStoredFilterAftermarketSubDistributor);
        var aftermarketOnline = SessionStorage.get(WhereToBuy.sessionNameStoredFilterAftermarketOnline);
        var aftermarketRetail = SessionStorage.get(WhereToBuy.sessionNameStoredFilterAftermarketRetail);
        var ac = SessionStorage.get(WhereToBuy.sessionNameStoredFilterAC);
        var station = SessionStorage.get(WhereToBuy.sessionNameStoredFilterStation);
        var diagnostics = SessionStorage.get(WhereToBuy.sessionNameStoredFilterDiagnostics);
        var diesel = SessionStorage.get(WhereToBuy.sessionNameStoredFilterDiesel);



        if (typeof keyword === "undefined" || keyword === "") {
            WhereToBuy.$locationSearchInputUser.val(locationUserInput);
            WhereToBuy.$locationSearchInputEnglish.val(locationEnglish);
            WhereToBuy.$locationSearchLatHiddenInput.val(locationLat);
            WhereToBuy.$locationSearchLngHiddenInput.val(locationLng);
            WhereToBuy.$locationSearchIsCountryHiddenInput.val(isCountry);
            WhereToBuy.$typeSelect.val("location");
            WhereToBuy.showSearchType("location");

        } else {

            WhereToBuy.$keywordSearchInput.val(keyword);
            WhereToBuy.$typeSelect.val("keyword");
            WhereToBuy.showSearchType("keyword");
        }

        if (aftermarketDistributor === "1" || aftermarketSubDistributor === "1") {
            WhereToBuy.$aftermarketsDistributorCheckbox.prop("checked", true);
        }

        if (aftermarketDistributor === "1") {
            WhereToBuy.$aftermarketDistributorCheckbox.prop("checked", true);
        }

        if (aftermarketSubDistributor === "1") {
            WhereToBuy.$aftermarketSubDistributorCheckbox.prop("checked", true);
        }

        if (ac === "1" || diagnostics === "1" || diesel === "1" || station === "1") {
            WhereToBuy.$servicesCheckbox.prop("checked", true);
        }

        if (ac === "1") {
            WhereToBuy.$acCheckbox.prop("checked", true);
        }
        if (diagnostics === "1") {
            WhereToBuy.$diagnosticsCheckbox.prop("checked", true);
        }
        if (diesel === "1") {
            WhereToBuy.$dieselCheckbox.prop("checked", true);
        }
        if (station === "1") {
            WhereToBuy.$stationCheckbox.prop("checked", true);
        }
        if (aftermarketOnline === "1") {
            WhereToBuy.$aftermarketOnlineCheckbox.prop("checked", true);
        }

        if (aftermarketRetail === "1") {
            WhereToBuy.$aftermarketRetailCheckbox.prop("checked", true);
        }

    },

};

$(document).ready(function () {
    WhereToBuy.init();
});

$.fn.serializeObject = function () {
    var o = {};
    var a = this.serializeArray();
    $.each(a, function () {
        if (o[this.name]) {
            if (!o[this.name].push) {
                o[this.name] = [o[this.name]];
            }
            o[this.name].push(this.value || '');
        } else {
            o[this.name] = this.value || '';
        }
    });
    return o;
};
